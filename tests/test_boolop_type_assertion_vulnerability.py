import unittest
from typing import Union

from opshin import builder
from .utils import eval_uplc_value, eval_uplc, Unit


class BoolOpTypeAssertionVulnerabilityTest(unittest.TestCase):
    """
    Test case for the security vulnerability in AggressiveTypeInferencer.visit_BoolOp()
    where type assertion wrappers are not applied on the right-hand-side of BoolOp.

    These tests expect the code to work correctly. They will FAIL while the vulnerability
    exists and PASS once the vulnerability is fixed.
    """

    def test_isinstance_and_comparison_vulnerability(self):
        """
        Test the exact vulnerability described in the security report.

        This test expects the code to work correctly. When isinstance(a, int) is True,
        the type assertion should be applied to 'a' in the right-hand-side of the 'and'
        expression, allowing a == 10 to work without type errors.

        This test will FAIL while the vulnerability exists.
        """
        source_code = """
from typing import Dict, List, Union
from opshin.prelude import *

def validator(a: Union[int, bytes]) -> None:
    assert isinstance(a, int) and a == 10
"""

        # This should work correctly - isinstance(a, int) should cast 'a' to int type
        # for the right-hand-side evaluation of a == 10
        try:
            result = eval_uplc(source_code, 10)
        except Exception as e:
            self.fail(f"Code should execute successfully but failed with: {e}")

    def test_isinstance_and_attribute_access_vulnerability(self):
        """
        Test a variant where the right-hand-side accesses an attribute that only exists
        after the type assertion.

        This test will FAIL while the vulnerability exists.
        """
        source_code = """
from typing import Dict, List, Union
from opshin.prelude import *
from dataclasses import dataclass

@dataclass()
class A(PlutusData):
    CONSTR_ID = 0
    value: int

@dataclass()
class B(PlutusData):
    CONSTR_ID = 1
    data: bytes

def validator(x: Union[A, B]) -> None:
    assert isinstance(x, A) and x.value == 10
"""

        # This should work - isinstance(x, A) should make x.value accessible
        from dataclasses import dataclass
        from pycardano import PlutusData

        @dataclass()
        class A(PlutusData):
            CONSTR_ID = 0
            value: int

        test_data = A(value=10)
        try:
            result = eval_uplc(source_code, test_data)
        except Exception as e:
            self.fail(f"Code should execute successfully but failed with: {e}")

    def test_isinstance_or_comparison_vulnerability(self):
        """
        Test the vulnerability with OR operations.

        This test will FAIL while the vulnerability exists.
        """
        source_code = """
from typing import Dict, List, Union
from opshin.prelude import *

def validator(a: Union[int, bytes]) -> None:
    assert isinstance(a, bytes) or a == 10
"""

        # This should work - when isinstance(a, bytes) is False, 'a' should be cast to int
        # for the right-hand-side evaluation of a == 10
        try:
            result = eval_uplc(source_code, 10)
        except Exception as e:
            self.fail(f"Code should execute successfully but failed with: {e}")

    def test_nested_boolop_vulnerability(self):
        """
        Test with nested boolean operations.

        This test will FAIL while the vulnerability exists.
        """
        source_code = """
from typing import Dict, List, Union
from opshin.prelude import *

def validator(a: Union[int, bytes], b: Union[int, bytes]) -> None:
    assert (isinstance(a, int) and a == 10) and (isinstance(b, int) and b == 20)
"""

        # This should work with proper type assertion handling in nested boolean operations
        try:
            result = eval_uplc(source_code, 10, 20)
        except Exception as e:
            self.fail(f"Code should execute successfully but failed with: {e}")

    def test_if_statement_with_boolop_vulnerability(self):
        """
        Test that if statements with boolean operations should work correctly.

        This test will FAIL while the vulnerability exists.
        """
        source_code = """
from typing import Dict, List, Union
from opshin.prelude import *

def validator(a: Union[int, bytes]) -> bool:
    if isinstance(a, int) and a == 10:
        return True
    return False
"""

        # This should work correctly with proper type assertion handling
        try:
            result = eval_uplc_value(source_code, 10)
            self.assertTrue(result)

            result = eval_uplc_value(source_code, b"test")
            self.assertFalse(result)
        except Exception as e:
            self.fail(f"Code should execute successfully but failed with: {e}")

    def test_compilation_and_runtime_both_succeed(self):
        """
        Test that the code compiles successfully AND runs successfully.
        This test demonstrates the expected behavior after the vulnerability is fixed.

        This test will FAIL while the vulnerability exists.
        """
        source_code = """
from typing import Dict, List, Union
from opshin.prelude import *

def validator(a: Union[int, bytes]) -> None:
    assert isinstance(a, int) and a == 10
"""

        # Compilation should succeed
        try:
            compiled_code = builder._compile(source_code)
            compilation_successful = True
        except Exception as e:
            compilation_successful = False
            self.fail(f"Code should compile successfully but failed with: {e}")

        self.assertTrue(compilation_successful, "Code should compile successfully")

        # Runtime should also succeed
        try:
            result = eval_uplc(source_code, 10)
        except Exception as e:
            self.fail(f"Code should execute successfully but failed with: {e}")


if __name__ == "__main__":
    unittest.main()
