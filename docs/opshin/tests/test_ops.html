<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/opshin/dev/docs/opshin_32.png" sizes="32x32" type="image/png">
<title>opshin.tests.test_ops API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/opshin" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>opshin.tests.test_ops</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import unittest

import cbor2
import hypothesis
import pycardano
from frozendict import frozendict
import frozenlist as fl
from hypothesis import example, given
from hypothesis import strategies as st
from uplc import ast as uplc, eval as uplc_eval
from uplc.ast import (
    PlutusMap,
    PlutusConstr,
    PlutusList,
    PlutusInteger,
    PlutusByteString,
)

from . import PLUTUS_VM_PROFILE
from .. import compiler

hypothesis.settings.load_profile(PLUTUS_VM_PROFILE)

from opshin.ledger.api_v2 import (
    FinitePOSIXTime,
    PosInfPOSIXTime,
    UpperBoundPOSIXTime,
    FalseData,
    TrueData,
)


def frozenlist(l):
    l = fl.FrozenList(l)
    l.freeze()
    return l


pos_int = st.integers(min_value=0, max_value=2**64 - 1)


uplc_data_integer = st.builds(PlutusInteger, st.integers())
uplc_data_bytestring = st.builds(PlutusByteString, st.binary())


def rec_data_strategies(uplc_data):
    uplc_data_list = st.builds(lambda x: PlutusList(frozenlist(x)), st.lists(uplc_data))
    uplc_data_constr = st.builds(
        lambda x, y: PlutusConstr(x, frozenlist(y)),
        pos_int,
        st.lists(uplc_data),
    )
    uplc_data_map = st.builds(
        PlutusMap,
        st.dictionaries(
            st.one_of(
                uplc_data_integer, uplc_data_bytestring
            ),  # TODO technically constr is legal too, but causes hashing error
            uplc_data,
            dict_class=frozendict,
        ),
    )
    return st.one_of(uplc_data_map, uplc_data_list, uplc_data_constr)


uplc_data = st.recursive(
    st.one_of(uplc_data_bytestring, uplc_data_integer),
    rec_data_strategies,
    max_leaves=4,
)

# TODO fix handling of these strings
formattable_text = st.from_regex(r&#34;\A((?![&#39;\\])[ -~])*\Z&#34;)


class OpTest(unittest.TestCase):
    @given(x=st.booleans(), y=st.booleans())
    def test_and_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x and y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, x and y, &#34;and returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_or_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x or y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, x or y, &#34;or returned wrong value&#34;)

    @given(x=st.booleans())
    def test_not_bool(self, x):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, not x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_usub_int(self, x):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; int:
    return -x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, -x, &#34;not returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_add_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_sub_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x - y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x - y, &#34;- returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mul_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_div_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x // y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x // y
        except ZeroDivisionError:
            exp = None
        try:
            for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;// returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mod_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x % y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x % y
        except ZeroDivisionError:
            exp = None
        try:
            for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;% returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers(min_value=0, max_value=20))
    def test_pow_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x ** y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x**y, &#34;** returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_add_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bytes:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusByteString(bytes(x)), uplc.PlutusByteString(bytes(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_add_str(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [
            uplc.PlutusByteString(bytes(x.encode(&#34;utf8&#34;))),
            uplc.PlutusByteString(bytes(y.encode(&#34;utf8&#34;))),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(), z=st.integers())
    @example(b&#34;\x00&#34;, -2, 0)
    @example(b&#34;1234&#34;, 1, 2)
    @example(b&#34;1234&#34;, 2, 4)
    @example(b&#34;1234&#34;, 2, 2)
    @example(b&#34;1234&#34;, 3, 3)
    @example(b&#34;1234&#34;, 3, 1)
    def test_slice_bytes(self, x, y, z):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int, z: int) -&gt; bytes:
    return x[y:z]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x[y:z]
        except IndexError:
            exp = None
        try:
            for d in [
                uplc.PlutusByteString(x),
                uplc.PlutusInteger(y),
                uplc.PlutusInteger(z),
            ]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;1234&#34;, 0)
    @example(b&#34;1234&#34;, 1)
    @example(b&#34;1234&#34;, -1)
    def test_index_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x[y]
        except IndexError:
            exp = None
        try:
            for d in [uplc.PlutusByteString(x), uplc.PlutusInteger(y)]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte index returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0], y=-1)
    @example(xs=[0], y=0)
    def test_index_list(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = xs[y]
        except IndexError:
            exp = None
        try:
            for d in [
                uplc.PlutusList([uplc.PlutusInteger(x) for x in xs]),
                uplc.PlutusInteger(y),
            ]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception as e:
            ret = None
        self.assertEqual(ret, exp, &#34;list index returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0, 1], y=-1)
    @example(xs=[0, 1], y=0)
    def test_in_list_int(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = y in xs
        for d in [
            uplc.PlutusList([uplc.PlutusInteger(x) for x in xs]),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;list in returned wrong value&#34;)

    @given(xs=st.lists(st.binary()), y=st.binary())
    def test_in_list_bytes(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[bytes], y: bytes) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = y in xs
        for d in [
            uplc.PlutusList([uplc.PlutusByteString(x) for x in xs]),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;list in returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_eq_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusByteString(x),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bytes eq returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_eq_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;int eq returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_eq_str(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
            uplc.PlutusByteString(y.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;str eq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_eq_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusInteger(int(x)),
            uplc.PlutusInteger(int(y)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bool eq returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.text())
    def test_mul_int_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: str) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusByteString(str(y).encode())]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode()
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.text(), y=st.integers(min_value=0, max_value=150))
    def test_mul_str_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: int) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusByteString(str(x).encode()), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode()
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.binary())
    def test_mul_int_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: bytes) -&gt; bytes:
    return x * y
        &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = x * y
        for d in [
            uplc.PlutusInteger(int(x)),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bytes int multiplication returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(min_value=0, max_value=150))
    def test_mul_bytes_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying

        for d in [uplc.PlutusByteString(x), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers())
    def test_fmt_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusInteger(int(x)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;int string formatting returned wrong value&#34;)

    @given(x=st.booleans())
    def test_fmt_bool(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusInteger(int(x)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;bool string formatting returned wrong value&#34;)

    @given(x=st.text())
    def test_fmt_str(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: str) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;string string formatting returned wrong value&#34;)

    @given(x=st.binary())
    @example(b&#34;&#39;&#34;)
    @example(b&#39;&#34;&#39;)
    @example(b&#34;\\&#34;)
    @example(b&#34;\r&#34;)
    @example(b&#34;\n&#34;)
    @example(b&#34;\t&#34;)
    @example(b&#34;\x7f&#34;)
    def test_fmt_bytes(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; str:
    return f&#34;{x}&#34;
        &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusByteString(x),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        if b&#34;&#39;&#34; not in x:
            self.assertEqual(ret, exp, &#34;bytes string formatting returned wrong value&#34;)
        else:
            # NOTE: formally this is a bug where we do not have the same semantics as python
            # specifically when &#39; is contained in the string we do not change the quotation marks
            self.assertEqual(
                eval(ret), x, &#34;bytes string formatting returned wrong value&#34;
            )

    @given(x=st.none())
    def test_fmt_none(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: None) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusConstr(0, []),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;none string formatting returned wrong value&#34;)

    @given(
        x=st.builds(
            UpperBoundPOSIXTime,
            st.one_of(
                st.builds(FinitePOSIXTime, st.integers()), st.builds(PosInfPOSIXTime)
            ),
            st.one_of(st.builds(TrueData), st.builds(FalseData)),
        )
    )
    @example(UpperBoundPOSIXTime(PosInfPOSIXTime(), TrueData()))
    def test_fmt_dataclass(self, x: UpperBoundPOSIXTime):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: UpperBoundPOSIXTime) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;

        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.data_from_cbor(x.to_cbor()),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.integers(), y=st.integers())
    def test_fmt_multiple(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    return f&#34;a{x}b{y}c&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;a{x}b{y}c&#34;
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_tuple_int(self, x):
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: int&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{tuple(x)}&#34;
        for d in (
            [uplc.PlutusInteger(xi) for xi in x] if x else [uplc.PlutusConstr(0, [])]
        ):
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(x=st.lists(formattable_text))
    def test_fmt_tuple_str(self, x):
        # TODO strings are not properly escaped here
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: str&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{tuple(x)}&#34;
        for d in (
            [uplc.PlutusByteString(xi.encode(&#34;utf8&#34;)) for xi in x]
            if x
            else [uplc.PlutusConstr(0, [])]
        ):
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;tuple string formatting returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_fmt_pair_int(self, x, y):
        source_code = f&#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{(x, y)}&#34;
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(x=formattable_text, y=formattable_text)
    def test_fmt_pair_str(self, x, y):
        # TODO strings are not properly escaped here
        source_code = f&#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{(x, y)}&#34;
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
            uplc.PlutusByteString(y.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;string tuple string formatting returned wrong value&#34;
        )

    @given(xs=st.lists(formattable_text))
    @example([])
    @example([&#34;x&#34;])
    def test_fmt_list_str(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[str]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{list(xs)}&#34;
        for d in [
            uplc.PlutusList([uplc.PlutusByteString(x.encode(&#34;utf8&#34;)) for x in xs])
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;string list string formatting returned wrong value&#34;)

    @given(xs=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_list_int(self, xs):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{list(xs)}&#34;
        for d in [uplc.PlutusList([uplc.PlutusInteger(x) for x in xs])]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer list string formatting returned wrong value&#34;
        )

    @given(xs=st.dictionaries(formattable_text, st.integers()))
    @example(dict())
    @example({&#34;&#34;: 0})
    def test_fmt_dict_int(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Dict[str, int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{dict(xs)}&#34;
        for d in [
            uplc.PlutusMap(
                {
                    uplc.PlutusByteString(k.encode(&#34;utf8&#34;)): uplc.PlutusInteger(v)
                    for (k, v) in xs.items()
                }
            )
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;dict string formatting returned wrong value&#34;)

    @given(x=uplc_data)
    @example(PlutusConstr(0, [PlutusByteString(b&#34;&#39;&#34;)]))
    def test_fmt_any(self, x):
        x_data = pycardano.RawPlutusData(cbor2.loads(uplc.plutus_cbor_dumps(x)))
        source_code = &#34;&#34;&#34;
def validator(x: Anything) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x_data}&#34;
        for d in [x]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        if &#34;\\&#39;&#34; in ret:
            RawPlutusData = pycardano.RawPlutusData
            CBORTag = cbor2.CBORTag
            self.assertEqual(
                eval(ret), x_data, &#34;raw cbor string formatting returned wrong value&#34;
            )
        else:
            self.assertEqual(
                ret, exp, &#34;raw cbor string formatting returned wrong value&#34;
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opshin.tests.test_ops.frozenlist"><code class="name flex">
<span>def <span class="ident">frozenlist</span></span>(<span>l)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frozenlist(l):
    l = fl.FrozenList(l)
    l.freeze()
    return l</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.rec_data_strategies"><code class="name flex">
<span>def <span class="ident">rec_data_strategies</span></span>(<span>uplc_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rec_data_strategies(uplc_data):
    uplc_data_list = st.builds(lambda x: PlutusList(frozenlist(x)), st.lists(uplc_data))
    uplc_data_constr = st.builds(
        lambda x, y: PlutusConstr(x, frozenlist(y)),
        pos_int,
        st.lists(uplc_data),
    )
    uplc_data_map = st.builds(
        PlutusMap,
        st.dictionaries(
            st.one_of(
                uplc_data_integer, uplc_data_bytestring
            ),  # TODO technically constr is legal too, but causes hashing error
            uplc_data,
            dict_class=frozendict,
        ),
    )
    return st.one_of(uplc_data_map, uplc_data_list, uplc_data_constr)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opshin.tests.test_ops.OpTest"><code class="flex name class">
<span>class <span class="ident">OpTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpTest(unittest.TestCase):
    @given(x=st.booleans(), y=st.booleans())
    def test_and_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x and y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, x and y, &#34;and returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_or_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x or y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, x or y, &#34;or returned wrong value&#34;)

    @given(x=st.booleans())
    def test_not_bool(self, x):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, not x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_usub_int(self, x):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; int:
    return -x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, -x, &#34;not returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_add_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_sub_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x - y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x - y, &#34;- returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mul_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_div_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x // y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x // y
        except ZeroDivisionError:
            exp = None
        try:
            for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;// returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mod_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x % y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x % y
        except ZeroDivisionError:
            exp = None
        try:
            for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;% returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers(min_value=0, max_value=20))
    def test_pow_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x ** y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x**y, &#34;** returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_add_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bytes:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusByteString(bytes(x)), uplc.PlutusByteString(bytes(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_add_str(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [
            uplc.PlutusByteString(bytes(x.encode(&#34;utf8&#34;))),
            uplc.PlutusByteString(bytes(y.encode(&#34;utf8&#34;))),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(), z=st.integers())
    @example(b&#34;\x00&#34;, -2, 0)
    @example(b&#34;1234&#34;, 1, 2)
    @example(b&#34;1234&#34;, 2, 4)
    @example(b&#34;1234&#34;, 2, 2)
    @example(b&#34;1234&#34;, 3, 3)
    @example(b&#34;1234&#34;, 3, 1)
    def test_slice_bytes(self, x, y, z):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int, z: int) -&gt; bytes:
    return x[y:z]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x[y:z]
        except IndexError:
            exp = None
        try:
            for d in [
                uplc.PlutusByteString(x),
                uplc.PlutusInteger(y),
                uplc.PlutusInteger(z),
            ]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;1234&#34;, 0)
    @example(b&#34;1234&#34;, 1)
    @example(b&#34;1234&#34;, -1)
    def test_index_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x[y]
        except IndexError:
            exp = None
        try:
            for d in [uplc.PlutusByteString(x), uplc.PlutusInteger(y)]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte index returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0], y=-1)
    @example(xs=[0], y=0)
    def test_index_list(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = xs[y]
        except IndexError:
            exp = None
        try:
            for d in [
                uplc.PlutusList([uplc.PlutusInteger(x) for x in xs]),
                uplc.PlutusInteger(y),
            ]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception as e:
            ret = None
        self.assertEqual(ret, exp, &#34;list index returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0, 1], y=-1)
    @example(xs=[0, 1], y=0)
    def test_in_list_int(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = y in xs
        for d in [
            uplc.PlutusList([uplc.PlutusInteger(x) for x in xs]),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;list in returned wrong value&#34;)

    @given(xs=st.lists(st.binary()), y=st.binary())
    def test_in_list_bytes(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[bytes], y: bytes) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = y in xs
        for d in [
            uplc.PlutusList([uplc.PlutusByteString(x) for x in xs]),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;list in returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_eq_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusByteString(x),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bytes eq returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_eq_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;int eq returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_eq_str(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
            uplc.PlutusByteString(y.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;str eq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_eq_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusInteger(int(x)),
            uplc.PlutusInteger(int(y)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bool eq returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.text())
    def test_mul_int_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: str) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusByteString(str(y).encode())]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode()
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.text(), y=st.integers(min_value=0, max_value=150))
    def test_mul_str_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: int) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusByteString(str(x).encode()), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode()
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.binary())
    def test_mul_int_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: bytes) -&gt; bytes:
    return x * y
        &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = x * y
        for d in [
            uplc.PlutusInteger(int(x)),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bytes int multiplication returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(min_value=0, max_value=150))
    def test_mul_bytes_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying

        for d in [uplc.PlutusByteString(x), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers())
    def test_fmt_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusInteger(int(x)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;int string formatting returned wrong value&#34;)

    @given(x=st.booleans())
    def test_fmt_bool(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusInteger(int(x)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;bool string formatting returned wrong value&#34;)

    @given(x=st.text())
    def test_fmt_str(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: str) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;string string formatting returned wrong value&#34;)

    @given(x=st.binary())
    @example(b&#34;&#39;&#34;)
    @example(b&#39;&#34;&#39;)
    @example(b&#34;\\&#34;)
    @example(b&#34;\r&#34;)
    @example(b&#34;\n&#34;)
    @example(b&#34;\t&#34;)
    @example(b&#34;\x7f&#34;)
    def test_fmt_bytes(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; str:
    return f&#34;{x}&#34;
        &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusByteString(x),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        if b&#34;&#39;&#34; not in x:
            self.assertEqual(ret, exp, &#34;bytes string formatting returned wrong value&#34;)
        else:
            # NOTE: formally this is a bug where we do not have the same semantics as python
            # specifically when &#39; is contained in the string we do not change the quotation marks
            self.assertEqual(
                eval(ret), x, &#34;bytes string formatting returned wrong value&#34;
            )

    @given(x=st.none())
    def test_fmt_none(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: None) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusConstr(0, []),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;none string formatting returned wrong value&#34;)

    @given(
        x=st.builds(
            UpperBoundPOSIXTime,
            st.one_of(
                st.builds(FinitePOSIXTime, st.integers()), st.builds(PosInfPOSIXTime)
            ),
            st.one_of(st.builds(TrueData), st.builds(FalseData)),
        )
    )
    @example(UpperBoundPOSIXTime(PosInfPOSIXTime(), TrueData()))
    def test_fmt_dataclass(self, x: UpperBoundPOSIXTime):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: UpperBoundPOSIXTime) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;

        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.data_from_cbor(x.to_cbor()),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.integers(), y=st.integers())
    def test_fmt_multiple(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    return f&#34;a{x}b{y}c&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;a{x}b{y}c&#34;
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_tuple_int(self, x):
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: int&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{tuple(x)}&#34;
        for d in (
            [uplc.PlutusInteger(xi) for xi in x] if x else [uplc.PlutusConstr(0, [])]
        ):
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(x=st.lists(formattable_text))
    def test_fmt_tuple_str(self, x):
        # TODO strings are not properly escaped here
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: str&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{tuple(x)}&#34;
        for d in (
            [uplc.PlutusByteString(xi.encode(&#34;utf8&#34;)) for xi in x]
            if x
            else [uplc.PlutusConstr(0, [])]
        ):
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;tuple string formatting returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_fmt_pair_int(self, x, y):
        source_code = f&#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{(x, y)}&#34;
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(x=formattable_text, y=formattable_text)
    def test_fmt_pair_str(self, x, y):
        # TODO strings are not properly escaped here
        source_code = f&#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{(x, y)}&#34;
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
            uplc.PlutusByteString(y.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;string tuple string formatting returned wrong value&#34;
        )

    @given(xs=st.lists(formattable_text))
    @example([])
    @example([&#34;x&#34;])
    def test_fmt_list_str(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[str]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{list(xs)}&#34;
        for d in [
            uplc.PlutusList([uplc.PlutusByteString(x.encode(&#34;utf8&#34;)) for x in xs])
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;string list string formatting returned wrong value&#34;)

    @given(xs=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_list_int(self, xs):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{list(xs)}&#34;
        for d in [uplc.PlutusList([uplc.PlutusInteger(x) for x in xs])]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer list string formatting returned wrong value&#34;
        )

    @given(xs=st.dictionaries(formattable_text, st.integers()))
    @example(dict())
    @example({&#34;&#34;: 0})
    def test_fmt_dict_int(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Dict[str, int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{dict(xs)}&#34;
        for d in [
            uplc.PlutusMap(
                {
                    uplc.PlutusByteString(k.encode(&#34;utf8&#34;)): uplc.PlutusInteger(v)
                    for (k, v) in xs.items()
                }
            )
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;dict string formatting returned wrong value&#34;)

    @given(x=uplc_data)
    @example(PlutusConstr(0, [PlutusByteString(b&#34;&#39;&#34;)]))
    def test_fmt_any(self, x):
        x_data = pycardano.RawPlutusData(cbor2.loads(uplc.plutus_cbor_dumps(x)))
        source_code = &#34;&#34;&#34;
def validator(x: Anything) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x_data}&#34;
        for d in [x]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        if &#34;\\&#39;&#34; in ret:
            RawPlutusData = pycardano.RawPlutusData
            CBORTag = cbor2.CBORTag
            self.assertEqual(
                eval(ret), x_data, &#34;raw cbor string formatting returned wrong value&#34;
            )
        else:
            self.assertEqual(
                ret, exp, &#34;raw cbor string formatting returned wrong value&#34;
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.tests.test_ops.OpTest.test_add_bytes"><code class="name flex">
<span>def <span class="ident">test_add_bytes</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.binary(), y=st.binary())
    def test_add_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bytes:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusByteString(bytes(x)), uplc.PlutusByteString(bytes(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_add_int"><code class="name flex">
<span>def <span class="ident">test_add_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_add_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_add_str"><code class="name flex">
<span>def <span class="ident">test_add_str</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.text(), y=st.text())
    def test_add_str(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    return x + y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [
            uplc.PlutusByteString(bytes(x.encode(&#34;utf8&#34;))),
            uplc.PlutusByteString(bytes(y.encode(&#34;utf8&#34;))),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_and_bool"><code class="name flex">
<span>def <span class="ident">test_and_bool</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.booleans(), y=st.booleans())
    def test_and_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x and y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, x and y, &#34;and returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_div_int"><code class="name flex">
<span>def <span class="ident">test_div_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_div_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x // y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x // y
        except ZeroDivisionError:
            exp = None
        try:
            for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;// returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_bool"><code class="name flex">
<span>def <span class="ident">test_eq_bool</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.booleans(), y=st.booleans())
    def test_eq_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusInteger(int(x)),
            uplc.PlutusInteger(int(y)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bool eq returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_bytes"><code class="name flex">
<span>def <span class="ident">test_eq_bytes</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_eq_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;int eq returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_str"><code class="name flex">
<span>def <span class="ident">test_eq_str</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.text(), y=st.text())
    def test_eq_str(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = x == y
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
            uplc.PlutusByteString(y.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;str eq returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_any"><code class="name flex">
<span>def <span class="ident">test_fmt_any</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=uplc_data)
    @example(PlutusConstr(0, [PlutusByteString(b&#34;&#39;&#34;)]))
    def test_fmt_any(self, x):
        x_data = pycardano.RawPlutusData(cbor2.loads(uplc.plutus_cbor_dumps(x)))
        source_code = &#34;&#34;&#34;
def validator(x: Anything) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x_data}&#34;
        for d in [x]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        if &#34;\\&#39;&#34; in ret:
            RawPlutusData = pycardano.RawPlutusData
            CBORTag = cbor2.CBORTag
            self.assertEqual(
                eval(ret), x_data, &#34;raw cbor string formatting returned wrong value&#34;
            )
        else:
            self.assertEqual(
                ret, exp, &#34;raw cbor string formatting returned wrong value&#34;
            )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_bool"><code class="name flex">
<span>def <span class="ident">test_fmt_bool</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.booleans())
    def test_fmt_bool(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusInteger(int(x)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;bool string formatting returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_bytes"><code class="name flex">
<span>def <span class="ident">test_fmt_bytes</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.binary())
    @example(b&#34;&#39;&#34;)
    @example(b&#39;&#34;&#39;)
    @example(b&#34;\\&#34;)
    @example(b&#34;\r&#34;)
    @example(b&#34;\n&#34;)
    @example(b&#34;\t&#34;)
    @example(b&#34;\x7f&#34;)
    def test_fmt_bytes(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; str:
    return f&#34;{x}&#34;
        &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusByteString(x),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        if b&#34;&#39;&#34; not in x:
            self.assertEqual(ret, exp, &#34;bytes string formatting returned wrong value&#34;)
        else:
            # NOTE: formally this is a bug where we do not have the same semantics as python
            # specifically when &#39; is contained in the string we do not change the quotation marks
            self.assertEqual(
                eval(ret), x, &#34;bytes string formatting returned wrong value&#34;
            )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_dataclass"><code class="name flex">
<span>def <span class="ident">test_fmt_dataclass</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(
        x=st.builds(
            UpperBoundPOSIXTime,
            st.one_of(
                st.builds(FinitePOSIXTime, st.integers()), st.builds(PosInfPOSIXTime)
            ),
            st.one_of(st.builds(TrueData), st.builds(FalseData)),
        )
    )
    @example(UpperBoundPOSIXTime(PosInfPOSIXTime(), TrueData()))
    def test_fmt_dataclass(self, x: UpperBoundPOSIXTime):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: UpperBoundPOSIXTime) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;

        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.data_from_cbor(x.to_cbor()),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;several element string formatting returned wrong value&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_dict_int"><code class="name flex">
<span>def <span class="ident">test_fmt_dict_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(xs=st.dictionaries(formattable_text, st.integers()))
    @example(dict())
    @example({&#34;&#34;: 0})
    def test_fmt_dict_int(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Dict[str, int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{dict(xs)}&#34;
        for d in [
            uplc.PlutusMap(
                {
                    uplc.PlutusByteString(k.encode(&#34;utf8&#34;)): uplc.PlutusInteger(v)
                    for (k, v) in xs.items()
                }
            )
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;dict string formatting returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_int"><code class="name flex">
<span>def <span class="ident">test_fmt_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers())
    def test_fmt_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusInteger(int(x)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;int string formatting returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_list_int"><code class="name flex">
<span>def <span class="ident">test_fmt_list_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(xs=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_list_int(self, xs):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{list(xs)}&#34;
        for d in [uplc.PlutusList([uplc.PlutusInteger(x) for x in xs])]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer list string formatting returned wrong value&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_list_str"><code class="name flex">
<span>def <span class="ident">test_fmt_list_str</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(xs=st.lists(formattable_text))
    @example([])
    @example([&#34;x&#34;])
    def test_fmt_list_str(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[str]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{list(xs)}&#34;
        for d in [
            uplc.PlutusList([uplc.PlutusByteString(x.encode(&#34;utf8&#34;)) for x in xs])
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;string list string formatting returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_multiple"><code class="name flex">
<span>def <span class="ident">test_fmt_multiple</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_fmt_multiple(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    return f&#34;a{x}b{y}c&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;a{x}b{y}c&#34;
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;several element string formatting returned wrong value&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_none"><code class="name flex">
<span>def <span class="ident">test_fmt_none</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.none())
    def test_fmt_none(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: None) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusConstr(0, []),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;none string formatting returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_pair_int"><code class="name flex">
<span>def <span class="ident">test_fmt_pair_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_fmt_pair_int(self, x, y):
        source_code = f&#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{(x, y)}&#34;
        for d in [
            uplc.PlutusInteger(x),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_pair_str"><code class="name flex">
<span>def <span class="ident">test_fmt_pair_str</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=formattable_text, y=formattable_text)
    def test_fmt_pair_str(self, x, y):
        # TODO strings are not properly escaped here
        source_code = f&#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{(x, y)}&#34;
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
            uplc.PlutusByteString(y.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;string tuple string formatting returned wrong value&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_str"><code class="name flex">
<span>def <span class="ident">test_fmt_str</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.text())
    def test_fmt_str(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: str) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{x}&#34;
        for d in [
            uplc.PlutusByteString(x.encode(&#34;utf8&#34;)),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;string string formatting returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_tuple_int"><code class="name flex">
<span>def <span class="ident">test_fmt_tuple_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_tuple_int(self, x):
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: int&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{tuple(x)}&#34;
        for d in (
            [uplc.PlutusInteger(xi) for xi in x] if x else [uplc.PlutusConstr(0, [])]
        ):
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_tuple_str"><code class="name flex">
<span>def <span class="ident">test_fmt_tuple_str</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.lists(formattable_text))
    def test_fmt_tuple_str(self, x):
        # TODO strings are not properly escaped here
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: str&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = f&#34;{tuple(x)}&#34;
        for d in (
            [uplc.PlutusByteString(xi.encode(&#34;utf8&#34;)) for xi in x]
            if x
            else [uplc.PlutusConstr(0, [])]
        ):
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;tuple string formatting returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_in_list_bytes"><code class="name flex">
<span>def <span class="ident">test_in_list_bytes</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(xs=st.lists(st.binary()), y=st.binary())
    def test_in_list_bytes(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[bytes], y: bytes) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = y in xs
        for d in [
            uplc.PlutusList([uplc.PlutusByteString(x) for x in xs]),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;list in returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_in_list_int"><code class="name flex">
<span>def <span class="ident">test_in_list_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0, 1], y=-1)
    @example(xs=[0, 1], y=0)
    def test_in_list_int(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        exp = y in xs
        for d in [
            uplc.PlutusList([uplc.PlutusInteger(x) for x in xs]),
            uplc.PlutusInteger(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;list in returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_index_bytes"><code class="name flex">
<span>def <span class="ident">test_index_bytes</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.binary(), y=st.integers())
    @example(b&#34;1234&#34;, 0)
    @example(b&#34;1234&#34;, 1)
    @example(b&#34;1234&#34;, -1)
    def test_index_bytes(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x[y]
        except IndexError:
            exp = None
        try:
            for d in [uplc.PlutusByteString(x), uplc.PlutusInteger(y)]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte index returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_index_list"><code class="name flex">
<span>def <span class="ident">test_index_list</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0], y=-1)
    @example(xs=[0], y=0)
    def test_index_list(self, xs, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = xs[y]
        except IndexError:
            exp = None
        try:
            for d in [
                uplc.PlutusList([uplc.PlutusInteger(x) for x in xs]),
                uplc.PlutusInteger(y),
            ]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception as e:
            ret = None
        self.assertEqual(ret, exp, &#34;list index returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mod_int"><code class="name flex">
<span>def <span class="ident">test_mod_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_mod_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x % y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x % y
        except ZeroDivisionError:
            exp = None
        try:
            for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;% returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_bytes_int"><code class="name flex">
<span>def <span class="ident">test_mul_bytes_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.binary(), y=st.integers(min_value=0, max_value=150))
    def test_mul_bytes_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying

        for d in [uplc.PlutusByteString(x), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_int"><code class="name flex">
<span>def <span class="ident">test_mul_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_mul_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_int_bytes"><code class="name flex">
<span>def <span class="ident">test_mul_int_bytes</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(min_value=0, max_value=150), y=st.binary())
    def test_mul_int_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: bytes) -&gt; bytes:
    return x * y
        &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        exp = x * y
        for d in [
            uplc.PlutusInteger(int(x)),
            uplc.PlutusByteString(y),
        ]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, exp, &#34;bytes int multiplication returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_int_str"><code class="name flex">
<span>def <span class="ident">test_mul_int_str</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(min_value=0, max_value=150), y=st.text())
    def test_mul_int_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: str) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusByteString(str(y).encode())]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode()
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_str_int"><code class="name flex">
<span>def <span class="ident">test_mul_str_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.text(), y=st.integers(min_value=0, max_value=150))
    def test_mul_str_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: int) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusByteString(str(x).encode()), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value.decode()
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_bool"><code class="name flex">
<span>def <span class="ident">test_not_bool</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.booleans())
    def test_not_bool(self, x):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, not x, &#34;not returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_or_bool"><code class="name flex">
<span>def <span class="ident">test_or_bool</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.booleans(), y=st.booleans())
    def test_or_bool(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x or y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = bool(uplc_eval(f).value)
        self.assertEqual(ret, x or y, &#34;or returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_pow_int"><code class="name flex">
<span>def <span class="ident">test_pow_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers(min_value=0, max_value=20))
    def test_pow_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x ** y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x**y, &#34;** returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_bytes"><code class="name flex">
<span>def <span class="ident">test_slice_bytes</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.binary(), y=st.integers(), z=st.integers())
    @example(b&#34;\x00&#34;, -2, 0)
    @example(b&#34;1234&#34;, 1, 2)
    @example(b&#34;1234&#34;, 2, 4)
    @example(b&#34;1234&#34;, 2, 2)
    @example(b&#34;1234&#34;, 3, 3)
    @example(b&#34;1234&#34;, 3, 1)
    def test_slice_bytes(self, x, y, z):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int, z: int) -&gt; bytes:
    return x[y:z]
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        try:
            exp = x[y:z]
        except IndexError:
            exp = None
        try:
            for d in [
                uplc.PlutusByteString(x),
                uplc.PlutusInteger(y),
                uplc.PlutusInteger(z),
            ]:
                f = uplc.Apply(f, d)
            ret = uplc_eval(f).value
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_sub_int"><code class="name flex">
<span>def <span class="ident">test_sub_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers(), y=st.integers())
    def test_sub_int(self, x, y):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x - y
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x)), uplc.PlutusInteger(int(y))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, x - y, &#34;- returned wrong value&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_usub_int"><code class="name flex">
<span>def <span class="ident">test_usub_int</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @given(x=st.integers())
    def test_usub_int(self, x):
        # this tests that errors that are caused by assignments are actually triggered at the time of assigning
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; int:
    return -x
            &#34;&#34;&#34;
        ast = compiler.parse(source_code)
        code = compiler.compile(ast)
        code = code.compile()
        f = code.term
        # UPLC lambdas may only take one argument at a time, so we evaluate by repeatedly applying
        for d in [uplc.PlutusInteger(int(x))]:
            f = uplc.Apply(f, d)
        ret = uplc_eval(f).value
        self.assertEqual(ret, -x, &#34;not returned wrong value&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="opshin Home" href="https://opshin.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/opshin/master/opshin.png" alt="opshin logo"> &nbsp; opshin
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opshin.tests" href="index.html">opshin.tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opshin.tests.test_ops.frozenlist" href="#opshin.tests.test_ops.frozenlist">frozenlist</a></code></li>
<li><code><a title="opshin.tests.test_ops.rec_data_strategies" href="#opshin.tests.test_ops.rec_data_strategies">rec_data_strategies</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opshin.tests.test_ops.OpTest" href="#opshin.tests.test_ops.OpTest">OpTest</a></code></h4>
<ul class="two-column">
<li><code><a title="opshin.tests.test_ops.OpTest.test_add_bytes" href="#opshin.tests.test_ops.OpTest.test_add_bytes">test_add_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_add_int" href="#opshin.tests.test_ops.OpTest.test_add_int">test_add_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_add_str" href="#opshin.tests.test_ops.OpTest.test_add_str">test_add_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_and_bool" href="#opshin.tests.test_ops.OpTest.test_and_bool">test_and_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_div_int" href="#opshin.tests.test_ops.OpTest.test_div_int">test_div_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_bool" href="#opshin.tests.test_ops.OpTest.test_eq_bool">test_eq_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_bytes" href="#opshin.tests.test_ops.OpTest.test_eq_bytes">test_eq_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_str" href="#opshin.tests.test_ops.OpTest.test_eq_str">test_eq_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_any" href="#opshin.tests.test_ops.OpTest.test_fmt_any">test_fmt_any</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_bool" href="#opshin.tests.test_ops.OpTest.test_fmt_bool">test_fmt_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_bytes" href="#opshin.tests.test_ops.OpTest.test_fmt_bytes">test_fmt_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_dataclass" href="#opshin.tests.test_ops.OpTest.test_fmt_dataclass">test_fmt_dataclass</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_dict_int" href="#opshin.tests.test_ops.OpTest.test_fmt_dict_int">test_fmt_dict_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_int" href="#opshin.tests.test_ops.OpTest.test_fmt_int">test_fmt_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_list_int" href="#opshin.tests.test_ops.OpTest.test_fmt_list_int">test_fmt_list_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_list_str" href="#opshin.tests.test_ops.OpTest.test_fmt_list_str">test_fmt_list_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_multiple" href="#opshin.tests.test_ops.OpTest.test_fmt_multiple">test_fmt_multiple</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_none" href="#opshin.tests.test_ops.OpTest.test_fmt_none">test_fmt_none</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_pair_int" href="#opshin.tests.test_ops.OpTest.test_fmt_pair_int">test_fmt_pair_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_pair_str" href="#opshin.tests.test_ops.OpTest.test_fmt_pair_str">test_fmt_pair_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_str" href="#opshin.tests.test_ops.OpTest.test_fmt_str">test_fmt_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_tuple_int" href="#opshin.tests.test_ops.OpTest.test_fmt_tuple_int">test_fmt_tuple_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_tuple_str" href="#opshin.tests.test_ops.OpTest.test_fmt_tuple_str">test_fmt_tuple_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_in_list_bytes" href="#opshin.tests.test_ops.OpTest.test_in_list_bytes">test_in_list_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_in_list_int" href="#opshin.tests.test_ops.OpTest.test_in_list_int">test_in_list_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_index_bytes" href="#opshin.tests.test_ops.OpTest.test_index_bytes">test_index_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_index_list" href="#opshin.tests.test_ops.OpTest.test_index_list">test_index_list</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mod_int" href="#opshin.tests.test_ops.OpTest.test_mod_int">test_mod_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_bytes_int" href="#opshin.tests.test_ops.OpTest.test_mul_bytes_int">test_mul_bytes_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_int" href="#opshin.tests.test_ops.OpTest.test_mul_int">test_mul_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_int_bytes" href="#opshin.tests.test_ops.OpTest.test_mul_int_bytes">test_mul_int_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_int_str" href="#opshin.tests.test_ops.OpTest.test_mul_int_str">test_mul_int_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_str_int" href="#opshin.tests.test_ops.OpTest.test_mul_str_int">test_mul_str_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_bool" href="#opshin.tests.test_ops.OpTest.test_not_bool">test_not_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_or_bool" href="#opshin.tests.test_ops.OpTest.test_or_bool">test_or_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_pow_int" href="#opshin.tests.test_ops.OpTest.test_pow_int">test_pow_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_bytes" href="#opshin.tests.test_ops.OpTest.test_slice_bytes">test_slice_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_sub_int" href="#opshin.tests.test_ops.OpTest.test_sub_int">test_sub_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_usub_int" href="#opshin.tests.test_ops.OpTest.test_usub_int">test_usub_int</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>