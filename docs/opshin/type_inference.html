<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/opshin/dev/docs/opshin_32.png" sizes="32x32" type="image/png">
<title>opshin.type_inference API documentation</title>
<meta name="description" content="An aggressive type inference based on the work of Aycock [1].
It only allows a subset of legal python operations which
allow us to infer the type of â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/opshin" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>opshin.type_inference</code></h1>
</header>
<section id="section-intro">
<p>An aggressive type inference based on the work of Aycock <a href="https://legacy.python.org/workshops/2000-01/proceedings/papers/aycock/aycock.html">1</a>.
It only allows a subset of legal python operations which
allow us to infer the type of all involved variables
statically.
Using this we can resolve overloaded functions when translating Python
into UPLC where there is no dynamic type checking.
Additionally, this conveniently implements an additional layer of
security into the Smart Contract by checking type correctness.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
An aggressive type inference based on the work of Aycock [1].
It only allows a subset of legal python operations which
allow us to infer the type of all involved variables
statically.
Using this we can resolve overloaded functions when translating Python
into UPLC where there is no dynamic type checking.
Additionally, this conveniently implements an additional layer of
security into the Smart Contract by checking type correctness.


[1]: https://legacy.python.org/workshops/2000-01/proceedings/papers/aycock/aycock.html
&#34;&#34;&#34;

import re

from pycardano import PlutusData

from .typed_ast import *
from .util import CompilingNodeTransformer
from .fun_impls import PythonBuiltInTypes
from .rewrite.rewrite_cast_condition import SPECIAL_BOOL

# from frozendict import frozendict

_LOGGER = logging.getLogger(__name__)


INITIAL_SCOPE = {
    # class annotations
    &#34;bytes&#34;: ByteStringType(),
    &#34;bytearray&#34;: ByteStringType(),
    &#34;int&#34;: IntegerType(),
    &#34;bool&#34;: BoolType(),
    &#34;str&#34;: StringType(),
    &#34;Anything&#34;: AnyType(),
}

INITIAL_SCOPE.update(
    {
        name.name: typ
        for name, typ in PythonBuiltInTypes.items()
        if isinstance(typ.typ, PolymorphicFunctionType)
    }
)


def record_from_plutusdata(c: PlutusData):
    return Record(
        name=c.__class__.__name__,
        orig_name=c.__class__.__name__,
        constructor=c.CONSTR_ID,
        fields=frozenlist([(k, constant_type(v)) for k, v in c.__dict__.items()]),
    )


def constant_type(c):
    if isinstance(c, bool):
        return BoolInstanceType
    if isinstance(c, int):
        return IntegerInstanceType
    if isinstance(c, type(None)):
        return UnitInstanceType
    if isinstance(c, bytes):
        return ByteStringInstanceType
    if isinstance(c, str):
        return StringInstanceType
    if isinstance(c, list):
        assert len(c) &gt; 0, &#34;Lists must be non-empty&#34;
        first_typ = constant_type(c[0])
        assert all(
            constant_type(ce) == first_typ for ce in c[1:]
        ), &#34;Constant lists must contain elements of a single type only&#34;
        return InstanceType(ListType(first_typ))
    if isinstance(c, dict):
        assert len(c) &gt; 0, &#34;Dicts must be non-empty&#34;
        first_key_typ = constant_type(next(iter(c.keys())))
        first_value_typ = constant_type(next(iter(c.values())))
        assert all(
            constant_type(ce) == first_key_typ for ce in c.keys()
        ), &#34;Constant dicts must contain keys of a single type only&#34;
        assert all(
            constant_type(ce) == first_value_typ for ce in c.values()
        ), &#34;Constant dicts must contain values of a single type only&#34;
        return InstanceType(DictType(first_key_typ, first_value_typ))
    if isinstance(c, PlutusData):
        return InstanceType(RecordType(record=record_from_plutusdata(c)))
    raise NotImplementedError(f&#34;Type {type(c)} not supported&#34;)


TypeMap = typing.Dict[str, Type]
TypeMapPair = typing.Tuple[TypeMap, TypeMap]


def union_types(*ts: Type):
    ts = OrderedSet(ts)
    # If all types are the same, just return the type
    if len(ts) == 1:
        return ts[0]
    # If there is a type that is compatible with all other types, choose the maximum
    for t in ts:
        if all(t &gt;= tp for tp in ts):
            return t
    assert ts, &#34;Union must combine multiple classes&#34;
    ts = [t if isinstance(t, UnionType) else UnionType(frozenlist([t])) for t in ts]
    for e in ts:
        for e2 in e.typs:
            assert isinstance(
                e2, RecordType
            ), f&#34;Union must combine multiple PlutusData classes but found {e2.__class__.__name__}&#34;
    union_set = OrderedSet()
    for t in ts:
        union_set.update(t.typs)
    assert distinct(
        [e.record.constructor for e in union_set]
    ), &#34;Union must combine PlutusData classes with unique constructors&#34;
    return UnionType(frozenlist(union_set))


def intersection_types(*ts: Type):
    ts = OrderedSet(ts)
    if len(ts) == 1:
        return ts[0]
    ts = [t if isinstance(t, UnionType) else UnionType(frozenlist([t])) for t in ts]
    assert ts, &#34;Must have at least one type to intersect&#34;
    intersection_set = OrderedSet(ts[0].typs)
    for t in ts[1:]:
        intersection_set.intersection_update(t.typs)
    return UnionType(frozenlist(intersection_set))


class TypeCheckVisitor(TypedNodeVisitor):
    &#34;&#34;&#34;
    Generates the types to which objects are cast due to a boolean expression
    It returns a tuple of dictionaries which are a name -&gt; type mapping
    for variable names that are assured to have a specific type if this expression
    is True/False respectively
    &#34;&#34;&#34;

    def __init__(self, allow_isinstance_anything=False):
        self.allow_isinstance_anything = allow_isinstance_anything

    def generic_visit(self, node: AST) -&gt; TypeMapPair:
        return getattr(node, &#34;typechecks&#34;, ({}, {}))

    def visit_Call(self, node: Call) -&gt; TypeMapPair:
        if isinstance(node.func, Name) and node.func.orig_id == SPECIAL_BOOL:
            return self.visit(node.args[0])
        if not (isinstance(node.func, Name) and node.func.orig_id == &#34;isinstance&#34;):
            return ({}, {})
        # special case for Union
        assert isinstance(
            node.args[0], Name
        ), &#34;Target 0 of an isinstance cast must be a variable name&#34;
        assert isinstance(
            node.args[1], Name
        ), &#34;Target 1 of an isinstance cast must be a class name&#34;
        target_class: RecordType = node.args[1].typ
        inst = node.args[0]
        inst_class = inst.typ
        assert isinstance(
            inst_class, InstanceType
        ), &#34;Can only cast instances, not classes&#34;
        assert isinstance(target_class, RecordType), &#34;Can only cast to PlutusData&#34;
        if isinstance(inst_class.typ, UnionType):
            assert (
                target_class in inst_class.typ.typs
            ), f&#34;Trying to cast an instance of Union type to non-instance of union type&#34;
            union_without_target_class = union_types(
                *(x for x in inst_class.typ.typs if x != target_class)
            )
        elif isinstance(inst_class.typ, AnyType) and self.allow_isinstance_anything:
            union_without_target_class = AnyType()
        else:
            assert (
                inst_class.typ == target_class
            ), &#34;Can only cast instances of Union types of PlutusData or cast the same class. If you know what you are doing, enable the flag &#39;--allow-isinstance-anything&#39;&#34;
            union_without_target_class = target_class
        varname = node.args[0].id
        return ({varname: target_class}, {varname: union_without_target_class})

    def visit_BoolOp(self, node: BoolOp) -&gt; PairType:
        res = {}
        inv_res = {}
        checks = [self.visit(v) for v in node.values]
        checked_types = defaultdict(list)
        inv_checked_types = defaultdict(list)
        for c, inv_c in checks:
            for v, t in c.items():
                checked_types[v].append(t)
            for v, t in inv_c.items():
                inv_checked_types[v].append(t)
        if isinstance(node.op, And):
            # a conjunction is just the intersection
            for v, ts in checked_types.items():
                res[v] = intersection_types(*ts)
            # if the conjunction fails, its any of the respective reverses, but only if the type is checked in every conjunction
            for v, ts in inv_checked_types.items():
                if len(ts) &lt; len(checks):
                    continue
                inv_res[v] = union_types(*ts)
        if isinstance(node.op, Or):
            # a disjunction is just the union, but some type must be checked in every disjunction
            for v, ts in checked_types.items():
                if len(ts) &lt; len(checks):
                    continue
                res[v] = union_types(*ts)
            # if the disjunction fails, then it must be in the intersection of the inverses
            for v, ts in inv_checked_types.items():
                inv_res[v] = intersection_types(*ts)
        return (res, inv_res)

    def visit_UnaryOp(self, node: UnaryOp) -&gt; PairType:
        (res, inv_res) = self.visit(node.operand)
        if isinstance(node.op, Not):
            return (inv_res, res)
        return (res, inv_res)


def merge_scope(s1: typing.Dict[str, Type], s2: typing.Dict[str, Type]):
    keys = OrderedSet(s1.keys()).union(s2.keys())
    merged = {}
    for k in keys:
        if k not in s1.keys():
            merged[k] = s2[k]
        elif k not in s2.keys():
            merged[k] = s1[k]
        else:
            try:
                assert isinstance(s1[k], InstanceType) and isinstance(
                    s2[k], InstanceType
                ), &#34;Can only merge instance types&#34;
                merged[k] = InstanceType(union_types(s1[k].typ, s2[k].typ))
            except AssertionError as e:
                raise AssertionError(
                    f&#34;Can not merge scopes after branching, conflicting types for {k}: {e}&#34;
                )
    return merged


class AggressiveTypeInferencer(CompilingNodeTransformer):
    def __init__(self, allow_isinstance_anything=False):
        self.allow_isinstance_anything = allow_isinstance_anything

    step = &#34;Static Type Inference&#34;

    # A stack of dictionaries for storing scoped knowledge of variable types
    scopes = [INITIAL_SCOPE]

    # Obtain the type of a variable name in the current scope
    def variable_type(self, name: str) -&gt; Type:
        name = name
        for scope in reversed(self.scopes):
            if name in scope:
                return scope[name]
        raise TypeInferenceError(
            f&#34;Variable {map_to_orig_name(name)} not initialized at access&#34;
        )

    def enter_scope(self):
        self.scopes.append({})

    def exit_scope(self):
        self.scopes.pop()

    def set_variable_type(self, name: str, typ: Type, force=False):
        if not force and name in self.scopes[-1] and self.scopes[-1][name] != typ:
            if self.scopes[-1][name] &gt;= typ:
                # the specified type is broader, we pass on this
                return
            raise TypeInferenceError(
                f&#34;Type {self.scopes[-1][name]} of variable {map_to_orig_name(name)} in local scope does not match inferred type {typ}&#34;
            )
        self.scopes[-1][name] = typ

    def implement_typechecks(self, typchecks: TypeMap):
        prevtyps = {}
        for n, t in typchecks.items():
            prevtyps[n] = self.variable_type(n).typ
            self.set_variable_type(n, InstanceType(t), force=True)
        return prevtyps

    def type_from_annotation(self, ann: expr):
        if isinstance(ann, Constant):
            if ann.value is None:
                return UnitType()
        if isinstance(ann, Name):
            if ann.id in ATOMIC_TYPES:
                return ATOMIC_TYPES[ann.id]
            v_t = self.variable_type(ann.id)
            if isinstance(v_t, ClassType):
                return v_t
            raise TypeInferenceError(
                f&#34;Class name {ann.orig_id} not initialized before annotating variable&#34;
            )
        if isinstance(ann, Subscript):
            assert isinstance(
                ann.value, Name
            ), &#34;Only Union, Dict and List are allowed as Generic types&#34;
            if ann.value.orig_id == &#34;Union&#34;:
                ann_types = frozenlist(
                    [self.type_from_annotation(e) for e in ann.slice.elts]
                )
                return union_types(*ann_types)
            if ann.value.orig_id == &#34;List&#34;:
                ann_type = self.type_from_annotation(ann.slice)
                assert isinstance(
                    ann_type, ClassType
                ), &#34;List must have a single type as parameter&#34;
                assert not isinstance(
                    ann_type, TupleType
                ), &#34;List can currently not hold tuples&#34;
                return ListType(InstanceType(ann_type))
            if ann.value.orig_id == &#34;Dict&#34;:
                assert isinstance(ann.slice, Tuple), &#34;Dict must combine two classes&#34;
                assert len(ann.slice.elts) == 2, &#34;Dict must combine two classes&#34;
                ann_types = self.type_from_annotation(
                    ann.slice.elts[0]
                ), self.type_from_annotation(ann.slice.elts[1])
                assert all(
                    isinstance(e, ClassType) for e in ann_types
                ), &#34;Dict must combine two classes&#34;
                assert not any(
                    isinstance(e, TupleType) for e in ann_types
                ), &#34;Dict can currently not hold tuples&#34;
                return DictType(*(InstanceType(a) for a in ann_types))
            if ann.value.orig_id == &#34;Tuple&#34;:
                assert isinstance(
                    ann.slice, Tuple
                ), &#34;Tuple must combine several classes&#34;
                ann_types = [self.type_from_annotation(e) for e in ann.slice.elts]
                assert all(
                    isinstance(e, ClassType) for e in ann_types
                ), &#34;Tuple must combine classes&#34;
                return TupleType(frozenlist([InstanceType(a) for a in ann_types]))
            raise NotImplementedError(
                &#34;Only Union, Dict and List are allowed as Generic types&#34;
            )
        if ann is None:
            return AnyType()
        raise NotImplementedError(f&#34;Annotation type {ann.__class__} is not supported&#34;)

    def visit_sequence(self, node_seq: typing.List[stmt]) -&gt; plt.AST:
        stmts = []
        prevtyps = {}
        for n in node_seq:
            stmt = self.visit(n)
            stmts.append(stmt)
            # if an assert is amng the statements apply the isinstance cast
            if isinstance(stmt, Assert):
                typchecks, _ = TypeCheckVisitor(self.allow_isinstance_anything).visit(
                    stmt.test
                )
                # for the time after this assert, the variable has the specialized type
                prevtyps.update(self.implement_typechecks(typchecks))
        self.implement_typechecks(prevtyps)
        return stmts

    def visit_ClassDef(self, node: ClassDef) -&gt; TypedClassDef:
        class_record = RecordReader.extract(node, self)
        typ = RecordType(class_record)
        self.set_variable_type(node.name, typ)
        typed_node = copy(node)
        typed_node.class_typ = typ
        return typed_node

    def visit_Constant(self, node: Constant) -&gt; TypedConstant:
        tc = copy(node)
        assert type(node.value) not in [
            float,
            complex,
            type(...),
        ], &#34;Float, complex numbers and ellipsis currently not supported&#34;
        tc.typ = constant_type(node.value)
        return tc

    def visit_Tuple(self, node: Tuple) -&gt; TypedTuple:
        tt = copy(node)
        tt.elts = [self.visit(e) for e in node.elts]
        tt.typ = InstanceType(TupleType(frozenlist([e.typ for e in tt.elts])))
        return tt

    def visit_List(self, node: List) -&gt; TypedList:
        tt = copy(node)
        tt.elts = [self.visit(e) for e in node.elts]
        l_typ = tt.elts[0].typ
        assert all(
            l_typ &gt;= e.typ for e in tt.elts
        ), &#34;All elements of a list must have the same type&#34;
        tt.typ = InstanceType(ListType(l_typ))
        return tt

    def visit_Dict(self, node: Dict) -&gt; TypedDict:
        tt = copy(node)
        tt.keys = [self.visit(k) for k in node.keys]
        tt.values = [self.visit(v) for v in node.values]
        k_typ = tt.keys[0].typ
        assert all(k_typ &gt;= k.typ for k in tt.keys), &#34;All keys must have the same type&#34;
        v_typ = tt.values[0].typ
        assert all(
            v_typ &gt;= v.typ for v in tt.values
        ), &#34;All values must have the same type&#34;
        tt.typ = InstanceType(DictType(k_typ, v_typ))
        return tt

    def visit_Assign(self, node: Assign) -&gt; TypedAssign:
        typed_ass = copy(node)
        typed_ass.value: TypedExpression = self.visit(node.value)
        # Make sure to first set the type of each target name so we can load it when visiting it
        for t in node.targets:
            assert isinstance(
                t, Name
            ), &#34;Can only assign to variable names, no type deconstruction&#34;
            # Check compatability to previous types -&gt; variable can be bound in a function before and needs to maintain type
            self.set_variable_type(t.id, typed_ass.value.typ)
        typed_ass.targets = [self.visit(t) for t in node.targets]
        return typed_ass

    def visit_AnnAssign(self, node: AnnAssign) -&gt; TypedAnnAssign:
        typed_ass = copy(node)
        typed_ass.annotation = self.type_from_annotation(node.annotation)
        if isinstance(typed_ass.annotation, ListType) and (
            (isinstance(node.value, Constant) and node.value.value == [])
            or (isinstance(node.value, List) and node.value.elts == [])
        ):
            # Empty lists are only allowed in annotated assignments
            typed_ass.value: TypedExpression = copy(node.value)
            typed_ass.value.typ = InstanceType(typed_ass.annotation)
        elif isinstance(typed_ass.annotation, DictType) and (
            (isinstance(node.value, Constant) and node.value.value == {})
            or (
                isinstance(node.value, Dict)
                and node.value.keys == []
                and node.value.values == []
            )
        ):
            # Empty lists are only allowed in annotated assignments
            typed_ass.value: TypedExpression = copy(node.value)
            typed_ass.value.typ = InstanceType(typed_ass.annotation)
        else:
            typed_ass.value: TypedExpression = self.visit(node.value)
        assert isinstance(
            node.target, Name
        ), &#34;Can only assign to variable names, no type deconstruction&#34;
        # Check compatability to previous types -&gt; variable can be bound in a function before and needs to maintain type
        self.set_variable_type(node.target.id, InstanceType(typed_ass.annotation))
        typed_ass.target = self.visit(node.target)
        assert (
            typed_ass.value.typ &gt;= InstanceType(typed_ass.annotation)
            or InstanceType(typed_ass.annotation) &gt;= typed_ass.value.typ
        ), &#34;Can only cast between related types&#34;
        return typed_ass

    def visit_If(self, node: If) -&gt; TypedIf:
        typed_if = copy(node)
        typed_if.test = self.visit(node.test)
        assert (
            typed_if.test.typ == BoolInstanceType
        ), &#34;Branching condition must have boolean type&#34;
        typchecks, inv_typchecks = TypeCheckVisitor(
            self.allow_isinstance_anything
        ).visit(typed_if.test)
        # for the time of the branch, these types are cast
        initial_scope = copy(self.scopes[-1])
        self.implement_typechecks(typchecks)
        typed_if.body = self.visit_sequence(node.body)
        # save resulting types
        final_scope_body = copy(self.scopes[-1])
        # reverse typechecks and remove typing of one branch
        self.scopes[-1] = initial_scope
        # for the time of the else branch, the inverse types hold
        self.implement_typechecks(inv_typchecks)
        typed_if.orelse = self.visit_sequence(node.orelse)
        final_scope_else = self.scopes[-1]
        # unify the resulting branch scopes
        self.scopes[-1] = merge_scope(final_scope_body, final_scope_else)
        return typed_if

    def visit_While(self, node: While) -&gt; TypedWhile:
        typed_while = copy(node)
        typed_while.test = self.visit(node.test)
        assert (
            typed_while.test.typ == BoolInstanceType
        ), &#34;Branching condition must have boolean type&#34;
        typchecks, inv_typchecks = TypeCheckVisitor(
            self.allow_isinstance_anything
        ).visit(typed_while.test)
        # for the time of the branch, these types are cast
        initial_scope = copy(self.scopes[-1])
        self.implement_typechecks(typchecks)
        typed_while.body = self.visit_sequence(node.body)
        final_scope_body = copy(self.scopes[-1])
        # revert changes
        self.scopes[-1] = initial_scope
        # for the time of the else branch, the inverse types hold
        self.implement_typechecks(inv_typchecks)
        typed_while.orelse = self.visit_sequence(node.orelse)
        final_scope_else = self.scopes[-1]
        self.scopes[-1] = merge_scope(final_scope_body, final_scope_else)
        return typed_while

    def visit_For(self, node: For) -&gt; TypedFor:
        typed_for = copy(node)
        typed_for.iter = self.visit(node.iter)
        if isinstance(node.target, Tuple):
            raise NotImplementedError(
                &#34;Tuple deconstruction in for loops is not supported yet&#34;
            )
        vartyp = None
        itertyp = typed_for.iter.typ
        assert isinstance(
            itertyp, InstanceType
        ), &#34;Can only iterate over instances, not classes&#34;
        if isinstance(itertyp.typ, TupleType):
            assert itertyp.typ.typs, &#34;Iterating over an empty tuple is not allowed&#34;
            vartyp = itertyp.typ.typs[0]
            assert all(
                itertyp.typ.typs[0] == t for t in typed_for.iter.typ.typs
            ), &#34;Iterating through a tuple requires the same type for each element&#34;
        elif isinstance(itertyp.typ, ListType):
            vartyp = itertyp.typ.typ
        else:
            raise NotImplementedError(
                &#34;Type inference for loops over non-list objects is not supported&#34;
            )
        self.set_variable_type(node.target.id, vartyp)
        typed_for.target = self.visit(node.target)
        typed_for.body = self.visit_sequence(node.body)
        typed_for.orelse = self.visit_sequence(node.orelse)
        return typed_for

    def visit_Name(self, node: Name) -&gt; TypedName:
        tn = copy(node)
        # Make sure that the rhs of an assign is evaluated first
        tn.typ = self.variable_type(node.id)
        return tn

    def visit_Compare(self, node: Compare) -&gt; TypedCompare:
        typed_cmp = copy(node)
        typed_cmp.left = self.visit(node.left)
        typed_cmp.comparators = [self.visit(s) for s in node.comparators]
        typed_cmp.typ = BoolInstanceType
        # the actual required types are being taken care of in the implementation
        return typed_cmp

    def visit_arg(self, node: arg) -&gt; typedarg:
        ta = copy(node)
        ta.typ = InstanceType(self.type_from_annotation(node.annotation))
        self.set_variable_type(ta.arg, ta.typ)
        return ta

    def visit_arguments(self, node: arguments) -&gt; typedarguments:
        if node.kw_defaults or node.kwarg or node.kwonlyargs or node.defaults:
            raise NotImplementedError(
                &#34;Keyword arguments and defaults not supported yet&#34;
            )
        ta = copy(node)
        ta.args = [self.visit(a) for a in node.args]
        return ta

    def visit_FunctionDef(self, node: FunctionDef) -&gt; TypedFunctionDef:
        tfd = copy(node)
        wraps_builtin = (
            all(
                isinstance(o, Name) and o.orig_id == &#34;wraps_builtin&#34;
                for o in node.decorator_list
            )
            and node.decorator_list
        )
        assert (
            not node.decorator_list or wraps_builtin
        ), &#34;Functions may not have decorators other than wraps_builtin&#34;
        self.enter_scope()
        tfd.args = self.visit(node.args)
        functyp = FunctionType(
            frozenlist([t.typ for t in tfd.args.args]),
            InstanceType(self.type_from_annotation(tfd.returns)),
            bound_vars={v: self.variable_type(v) for v in externally_bound_vars(node)},
            bind_self=node.name if node.name in read_vars(node) else None,
        )
        tfd.typ = InstanceType(functyp)
        if wraps_builtin:
            # the body of wrapping builtin functions is fully ignored
            pass
        else:
            # We need the function type inside for recursion
            self.set_variable_type(node.name, tfd.typ)
            tfd.body = self.visit_sequence(node.body)
            # Check that return type and annotated return type match
            rets_extractor = ReturnExtractor(functyp.rettyp)
            rets_extractor.check_fulfills(tfd)

        self.exit_scope()
        # We need the function type outside for usage
        self.set_variable_type(node.name, tfd.typ)
        return tfd

    def visit_Module(self, node: Module) -&gt; TypedModule:
        self.enter_scope()
        tm = copy(node)
        tm.body = self.visit_sequence(node.body)
        self.exit_scope()
        return tm

    def visit_Expr(self, node: Expr) -&gt; TypedExpr:
        tn = copy(node)
        tn.value = self.visit(node.value)
        return tn

    def visit_BinOp(self, node: BinOp) -&gt; TypedBinOp:
        tb = copy(node)
        tb.left = self.visit(node.left)
        tb.right = self.visit(node.right)
        binop_fun_typ: FunctionType = tb.left.typ.binop_type(tb.op, tb.right.typ)
        tb.typ = binop_fun_typ.rettyp
        return tb

    def visit_BoolOp(self, node: BoolOp) -&gt; TypedBoolOp:
        tt = copy(node)
        if isinstance(node.op, And):
            values = []
            prevtyps = {}
            for e in node.values:
                values.append(self.visit(e))
                typchecks, _ = TypeCheckVisitor(self.allow_isinstance_anything).visit(
                    values[-1]
                )
                # for the time after the shortcut and the variable type to the specialized type
                prevtyps.update(self.implement_typechecks(typchecks))
            self.implement_typechecks(prevtyps)
            tt.values = values
        elif isinstance(node.op, Or):
            values = []
            prevtyps = {}
            for e in node.values:
                values.append(self.visit(e))
                _, inv_typechecks = TypeCheckVisitor(
                    self.allow_isinstance_anything
                ).visit(values[-1])
                # for the time after the shortcut or the variable type is *not* the specialized type
                prevtyps.update(self.implement_typechecks(inv_typechecks))
            self.implement_typechecks(prevtyps)
            tt.values = values
        else:
            tt.values = [self.visit(e) for e in node.values]
        tt.typ = BoolInstanceType
        assert all(
            BoolInstanceType &gt;= e.typ for e in tt.values
        ), &#34;All values compared must be bools&#34;
        return tt

    def visit_UnaryOp(self, node: UnaryOp) -&gt; TypedUnaryOp:
        tu = copy(node)
        tu.operand = self.visit(node.operand)
        tu.typ = tu.operand.typ.typ.unop_type(node.op).rettyp
        return tu

    def visit_Subscript(self, node: Subscript) -&gt; TypedSubscript:
        ts = copy(node)
        # special case: Subscript of Union / Dict / List and atomic types
        if isinstance(ts.value, Name) and ts.value.orig_id in [
            &#34;Union&#34;,
            &#34;Dict&#34;,
            &#34;List&#34;,
        ]:
            ts.value = ts.typ = self.type_from_annotation(ts)
            return ts

        ts.value = self.visit(node.value)
        assert isinstance(ts.value.typ, InstanceType), &#34;Can only subscript instances&#34;
        if isinstance(ts.value.typ.typ, TupleType):
            assert (
                ts.value.typ.typ.typs
            ), &#34;Accessing elements from the empty tuple is not allowed&#34;
            if all(ts.value.typ.typ.typs[0] == t for t in ts.value.typ.typ.typs):
                ts.typ = ts.value.typ.typ.typs[0]
            elif isinstance(ts.slice, Constant) and isinstance(ts.slice.value, int):
                ts.typ = ts.value.typ.typ.typs[ts.slice.value]
            else:
                raise TypeInferenceError(
                    f&#34;Could not infer type of subscript of typ {ts.value.typ.typ.__class__}&#34;
                )
        elif isinstance(ts.value.typ.typ, PairType):
            if isinstance(ts.slice, Constant) and isinstance(ts.slice.value, int):
                ts.typ = (
                    ts.value.typ.typ.l_typ
                    if ts.slice.value == 0
                    else ts.value.typ.typ.r_typ
                )
            else:
                raise TypeInferenceError(
                    f&#34;Could not infer type of subscript of typ {ts.value.typ.typ.__class__}&#34;
                )
        elif isinstance(ts.value.typ.typ, ListType):
            if not isinstance(ts.slice, Slice):
                ts.typ = ts.value.typ.typ.typ
                ts.slice = self.visit(node.slice)
                assert (
                    ts.slice.typ == IntegerInstanceType
                ), &#34;List indices must be integers&#34;
            else:
                ts.typ = ts.value.typ
                if ts.slice.lower is None:
                    ts.slice.lower = Constant(0)
                ts.slice.lower = self.visit(node.slice.lower)
                assert (
                    ts.slice.lower.typ == IntegerInstanceType
                ), &#34;lower slice indices for lists must be integers&#34;
                if ts.slice.upper is None:
                    ts.slice.upper = Call(
                        func=Name(id=&#34;len&#34;, ctx=Load()), args=[ts.value], keywords=[]
                    )
                    ts.slice.upper.func.orig_id = &#34;len&#34;
                ts.slice.upper = self.visit(node.slice.upper)
                assert (
                    ts.slice.upper.typ == IntegerInstanceType
                ), &#34;upper slice indices for lists must be integers&#34;
        elif isinstance(ts.value.typ.typ, ByteStringType):
            if not isinstance(ts.slice, Slice):
                ts.typ = IntegerInstanceType
                ts.slice = self.visit(node.slice)
                assert (
                    ts.slice.typ == IntegerInstanceType
                ), &#34;bytes indices must be integers&#34;
            else:
                ts.typ = ByteStringInstanceType
                if ts.slice.lower is None:
                    ts.slice.lower = Constant(0)
                ts.slice.lower = self.visit(node.slice.lower)
                assert (
                    ts.slice.lower.typ == IntegerInstanceType
                ), &#34;lower slice indices for bytes must be integers&#34;
                if ts.slice.upper is None:
                    ts.slice.upper = Call(
                        func=Name(id=&#34;len&#34;, ctx=Load()), args=[ts.value], keywords=[]
                    )
                    ts.slice.upper.func.orig_id = &#34;len&#34;
                ts.slice.upper = self.visit(node.slice.upper)
                assert (
                    ts.slice.upper.typ == IntegerInstanceType
                ), &#34;upper slice indices for bytes must be integers&#34;
        elif isinstance(ts.value.typ.typ, DictType):
            if not isinstance(ts.slice, Slice):
                ts.slice = self.visit(node.slice)
                assert (
                    ts.slice.typ == ts.value.typ.typ.key_typ
                ), f&#34;Dict subscript must have dict key type {ts.value.typ.typ.key_typ} but has type {ts.slice.typ}&#34;
                ts.typ = ts.value.typ.typ.value_typ
            else:
                raise TypeInferenceError(
                    f&#34;Could not infer type of subscript of dict with a slice.&#34;
                )
        else:
            raise TypeInferenceError(
                f&#34;Could not infer type of subscript of typ {ts.value.typ.__class__}&#34;
            )
        return ts

    def visit_Call(self, node: Call) -&gt; TypedCall:
        assert not node.keywords, &#34;Keyword arguments are not supported yet&#34;
        tc = copy(node)
        tc.args = [self.visit(a) for a in node.args]
        # might be isinstance
        if isinstance(tc.func, Name) and tc.func.orig_id == &#34;isinstance&#34;:
            target_class = tc.args[1].typ
            if (
                isinstance(tc.args[0].typ, InstanceType)
                and isinstance(tc.args[0].typ.typ, AnyType)
                and not self.allow_isinstance_anything
            ):
                raise AssertionError(
                    &#34;OpShin does not permit checking the instance of raw Anything/Datum objects as this only checks the equality of the constructor id and nothing more. &#34;
                    &#34;If you are certain of what you are doing, please use the flag &#39;--allow-isinstance-anything&#39;.&#34;
                )
            ntc = Compare(
                left=Attribute(tc.args[0], &#34;CONSTR_ID&#34;),
                ops=[Eq()],
                comparators=[Constant(target_class.record.constructor)],
            )
            custom_fix_missing_locations(ntc, node)
            ntc = self.visit(ntc)
            ntc.typ = BoolInstanceType
            ntc.typechecks = TypeCheckVisitor(self.allow_isinstance_anything).visit(tc)
            return ntc
        tc.func = self.visit(node.func)
        # might be a class
        if isinstance(tc.func.typ, ClassType):
            tc.func.typ = tc.func.typ.constr_type()
        # type might only turn out after the initialization (note the constr could be polymorphic)
        if isinstance(tc.func.typ, InstanceType) and isinstance(
            tc.func.typ.typ, PolymorphicFunctionType
        ):
            tc.func.typ = PolymorphicFunctionInstanceType(
                tc.func.typ.typ.polymorphic_function.type_from_args(
                    [a.typ for a in tc.args]
                ),
                tc.func.typ.typ.polymorphic_function,
            )
        if isinstance(tc.func.typ, InstanceType) and isinstance(
            tc.func.typ.typ, FunctionType
        ):
            functyp = tc.func.typ.typ
            assert len(tc.args) == len(
                functyp.argtyps
            ), f&#34;Signature of function does not match number of arguments. Expected {len(functyp.argtyps)} arguments with these types: {functyp.argtyps} but got {len(tc.args)} arguments.&#34;
            # all arguments need to be subtypes of the parameter type
            for i, (a, ap) in enumerate(zip(tc.args, functyp.argtyps)):
                assert (
                    ap &gt;= a.typ
                ), f&#34;Signature of function does not match arguments in argument {i}. Expected this type: {ap} but got {a.typ}.&#34;
            tc.typ = functyp.rettyp
            return tc
        raise TypeInferenceError(&#34;Could not infer type of call&#34;)

    def visit_Pass(self, node: Pass) -&gt; TypedPass:
        tp = copy(node)
        return tp

    def visit_Return(self, node: Return) -&gt; TypedReturn:
        tp = copy(node)
        tp.value = self.visit(node.value)
        tp.typ = tp.value.typ
        return tp

    def visit_Attribute(self, node: Attribute) -&gt; TypedAttribute:
        tp = copy(node)
        tp.value = self.visit(node.value)
        owner = tp.value.typ
        # accesses to field
        tp.typ = owner.attribute_type(node.attr)
        return tp

    def visit_Assert(self, node: Assert) -&gt; TypedAssert:
        ta = copy(node)
        ta.test = self.visit(node.test)
        assert (
            ta.test.typ == BoolInstanceType
        ), &#34;Assertions must result in a boolean type&#34;
        if ta.msg is not None:
            ta.msg = self.visit(node.msg)
            assert (
                ta.msg.typ == StringInstanceType
            ), &#34;Assertions must has a string message (or None)&#34;
        return ta

    def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; RawPlutoExpr:
        assert node.typ is not None, &#34;Raw Pluto Expression is missing type annotation&#34;
        return node

    def visit_IfExp(self, node: IfExp) -&gt; TypedIfExp:
        node_cp = copy(node)
        node_cp.test = self.visit(node.test)
        assert node_cp.test.typ == BoolInstanceType, &#34;Comparison must have type boolean&#34;
        typchecks, inv_typchecks = TypeCheckVisitor(
            self.allow_isinstance_anything
        ).visit(node_cp.test)
        prevtyps = self.implement_typechecks(typchecks)
        node_cp.body = self.visit(node.body)
        self.implement_typechecks(prevtyps)
        prevtyps = self.implement_typechecks(inv_typchecks)
        node_cp.orelse = self.visit(node.orelse)
        self.implement_typechecks(prevtyps)
        if node_cp.body.typ &gt;= node_cp.orelse.typ:
            node_cp.typ = node_cp.body.typ
        elif node_cp.orelse.typ &gt;= node_cp.body.typ:
            node_cp.typ = node_cp.orelse.typ
        else:
            try:
                assert isinstance(node_cp.body.typ, InstanceType) and isinstance(
                    node_cp.orelse.typ, InstanceType
                )
                node_cp.typ = InstanceType(
                    union_types(node_cp.body.typ.typ, node_cp.orelse.typ.typ)
                )
            except AssertionError:
                raise TypeInferenceError(
                    &#34;Branches of if-expression must return compatible types.&#34;
                )
        return node_cp

    def visit_comprehension(self, g: comprehension) -&gt; typedcomprehension:
        new_g = copy(g)
        if isinstance(g.target, Tuple):
            raise NotImplementedError(
                &#34;Type deconstruction in for loops is not supported yet&#34;
            )
        new_g.iter = self.visit(g.iter)
        itertyp = new_g.iter.typ
        assert isinstance(
            itertyp, InstanceType
        ), &#34;Can only iterate over instances, not classes&#34;
        if isinstance(itertyp.typ, TupleType):
            assert itertyp.typ.typs, &#34;Iterating over an empty tuple is not allowed&#34;
            vartyp = itertyp.typ.typs[0]
            assert all(
                itertyp.typ.typs[0] == t for t in new_g.iter.typ.typs
            ), &#34;Iterating through a tuple requires the same type for each element&#34;
        elif isinstance(itertyp.typ, ListType):
            vartyp = itertyp.typ.typ
        else:
            raise NotImplementedError(
                &#34;Type inference for loops over non-list objects is not supported&#34;
            )
        self.set_variable_type(g.target.id, vartyp)
        new_g.target = self.visit(g.target)
        new_g.ifs = [self.visit(i) for i in g.ifs]
        return new_g

    def visit_ListComp(self, node: ListComp) -&gt; TypedListComp:
        typed_listcomp = copy(node)
        # inside the comprehension is a seperate scope
        self.enter_scope()
        # first evaluate generators for assigned variables
        typed_listcomp.generators = [self.visit(s) for s in node.generators]
        # then evaluate elements
        typed_listcomp.elt = self.visit(node.elt)
        self.exit_scope()
        typed_listcomp.typ = InstanceType(ListType(typed_listcomp.elt.typ))
        return typed_listcomp

    def visit_DictComp(self, node: DictComp) -&gt; TypedDictComp:
        typed_dictcomp = copy(node)
        # inside the comprehension is a seperate scope
        self.enter_scope()
        # first evaluate generators for assigned variables
        typed_dictcomp.generators = [self.visit(s) for s in node.generators]
        # then evaluate elements
        typed_dictcomp.key = self.visit(node.key)
        typed_dictcomp.value = self.visit(node.value)
        self.exit_scope()
        typed_dictcomp.typ = InstanceType(
            DictType(typed_dictcomp.key.typ, typed_dictcomp.value.typ)
        )
        return typed_dictcomp

    def visit_FormattedValue(self, node: FormattedValue) -&gt; TypedFormattedValue:
        typed_node = copy(node)
        typed_node.value = self.visit(node.value)
        assert node.conversion in (
            -1,
            115,
        ), &#34;Only string formatting is allowed but got repr or ascii formatting.&#34;
        assert (
            node.format_spec is None
        ), &#34;No format specification is allowed but got formatting specifiers (i.e. decimals).&#34;
        typed_node.typ = StringInstanceType
        return typed_node

    def visit_JoinedStr(self, node: JoinedStr) -&gt; TypedJoinedStr:
        typed_node = copy(node)
        typed_node.values = [self.visit(v) for v in node.values]
        typed_node.typ = StringInstanceType
        return typed_node

    def visit_ImportFrom(self, node: ImportFrom) -&gt; ImportFrom:
        assert node.module == &#34;opshin.bridge&#34;, &#34;Trying to import from invalid location&#34;
        return node

    def generic_visit(self, node: AST) -&gt; TypedAST:
        raise NotImplementedError(
            f&#34;Cannot infer type of non-implemented node {node.__class__}&#34;
        )


class RecordReader(NodeVisitor):
    name: str
    orig_name: str
    constructor: typing.Optional[int]
    attributes: typing.List[typing.Tuple[str, Type]]
    _type_inferencer: AggressiveTypeInferencer

    def __init__(self, type_inferencer: AggressiveTypeInferencer):
        self.constructor = None
        self.attributes = []
        self._type_inferencer = type_inferencer

    @classmethod
    def extract(cls, c: ClassDef, type_inferencer: AggressiveTypeInferencer) -&gt; Record:
        f = cls(type_inferencer)
        f.visit(c)
        if f.constructor is None:
            det_string = RecordType(
                Record(f.name, f.orig_name, 0, frozenlist(f.attributes))
            ).id_map(skip_constructor=True)
            det_hash = sha256(str(det_string).encode(&#34;utf8&#34;)).hexdigest()
            f.constructor = int(det_hash, 16) % 2**32
        return Record(f.name, f.orig_name, f.constructor, frozenlist(f.attributes))

    def visit_AnnAssign(self, node: AnnAssign) -&gt; None:
        assert isinstance(
            node.target, Name
        ), &#34;Record elements must have named attributes&#34;
        typ = self._type_inferencer.type_from_annotation(node.annotation)
        if node.target.id != &#34;CONSTR_ID&#34;:
            assert (
                node.value is None
            ), f&#34;PlutusData attribute {node.target.id} may not have a default value&#34;
            assert not isinstance(
                typ, TupleType
            ), &#34;Records can currently not hold tuples&#34;
            self.attributes.append(
                (
                    node.target.id,
                    InstanceType(typ),
                )
            )
            return
        assert typ == IntegerType, &#34;CONSTR_ID must be assigned an integer&#34;
        assert isinstance(
            node.value, Constant
        ), &#34;CONSTR_ID must be assigned a constant integer&#34;
        assert isinstance(
            node.value.value, int
        ), &#34;CONSTR_ID must be assigned an integer&#34;
        self.constructor = node.value.value

    def visit_ClassDef(self, node: ClassDef) -&gt; None:
        self.name = node.name
        self.orig_name = node.orig_name
        for s in node.body:
            self.visit(s)

    def visit_Pass(self, node: Pass) -&gt; None:
        pass

    def visit_Assign(self, node: Assign) -&gt; None:
        assert len(node.targets) == 1, &#34;Record elements must be assigned one by one&#34;
        target = node.targets[0]
        assert isinstance(target, Name), &#34;Record elements must have named attributes&#34;
        assert (
            target.id == &#34;CONSTR_ID&#34;
        ), &#34;Type annotations may only be omitted for CONSTR_ID&#34;
        assert isinstance(
            node.value, Constant
        ), &#34;CONSTR_ID must be assigned a constant integer&#34;
        assert isinstance(
            node.value.value, int
        ), &#34;CONSTR_ID must be assigned an integer&#34;
        self.constructor = node.value.value

    def visit_Expr(self, node: Expr) -&gt; None:
        assert isinstance(
            node.value, Constant
        ), &#34;Only comments are allowed inside classes&#34;
        return None

    def generic_visit(self, node: AST) -&gt; None:
        raise NotImplementedError(f&#34;Can not compile {ast.dump(node)} inside of a class&#34;)


def typed_ast(ast: AST):
    return AggressiveTypeInferencer().visit(ast)


def map_to_orig_name(name: str):
    return re.sub(r&#34;_\d+$&#34;, &#34;&#34;, name)


class ReturnExtractor(TypedNodeVisitor):
    &#34;&#34;&#34;
    Utility to check that all paths end in Return statements with the proper type

    Returns whether there is no remaining path
    &#34;&#34;&#34;

    def __init__(self, func_rettyp: Type):
        self.func_rettyp = func_rettyp

    def visit_sequence(self, nodes: typing.List[TypedAST]) -&gt; bool:
        all_paths_covered = False
        for node in nodes:
            all_paths_covered = self.visit(node)
            if all_paths_covered:
                break
        return all_paths_covered

    def visit_If(self, node: If) -&gt; bool:
        return self.visit_sequence(node.body) and self.visit_sequence(node.orelse)

    def visit_For(self, node: For) -&gt; bool:
        # The body simply has to be checked but has no influence on whether all paths are covered
        # because it might never be visited
        self.visit_sequence(node.body)
        # the else path is always visited
        return self.visit_sequence(node.orelse)

    def visit_While(self, node: For) -&gt; bool:
        # The body simply has to be checked but has no influence on whether all paths are covered
        # because it might never be visited
        self.visit_sequence(node.body)
        # the else path is always visited
        return self.visit_sequence(node.orelse)

    def visit_Return(self, node: Return) -&gt; bool:
        assert (
            self.func_rettyp &gt;= node.typ
        ), f&#34;Function annotated return type does not match actual return type&#34;
        return True

    def check_fulfills(self, node: FunctionDef):
        all_paths_covered = self.visit_sequence(node.body)
        if not all_paths_covered:
            assert (
                self.func_rettyp &gt;= NoneInstanceType
            ), f&#34;Function &#39;{node.name}&#39; has no return statement but is supposed to return not-None value&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opshin.type_inference.constant_type"><code class="name flex">
<span>def <span class="ident">constant_type</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constant_type(c):
    if isinstance(c, bool):
        return BoolInstanceType
    if isinstance(c, int):
        return IntegerInstanceType
    if isinstance(c, type(None)):
        return UnitInstanceType
    if isinstance(c, bytes):
        return ByteStringInstanceType
    if isinstance(c, str):
        return StringInstanceType
    if isinstance(c, list):
        assert len(c) &gt; 0, &#34;Lists must be non-empty&#34;
        first_typ = constant_type(c[0])
        assert all(
            constant_type(ce) == first_typ for ce in c[1:]
        ), &#34;Constant lists must contain elements of a single type only&#34;
        return InstanceType(ListType(first_typ))
    if isinstance(c, dict):
        assert len(c) &gt; 0, &#34;Dicts must be non-empty&#34;
        first_key_typ = constant_type(next(iter(c.keys())))
        first_value_typ = constant_type(next(iter(c.values())))
        assert all(
            constant_type(ce) == first_key_typ for ce in c.keys()
        ), &#34;Constant dicts must contain keys of a single type only&#34;
        assert all(
            constant_type(ce) == first_value_typ for ce in c.values()
        ), &#34;Constant dicts must contain values of a single type only&#34;
        return InstanceType(DictType(first_key_typ, first_value_typ))
    if isinstance(c, PlutusData):
        return InstanceType(RecordType(record=record_from_plutusdata(c)))
    raise NotImplementedError(f&#34;Type {type(c)} not supported&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.intersection_types"><code class="name flex">
<span>def <span class="ident">intersection_types</span></span>(<span>*ts:Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection_types(*ts: Type):
    ts = OrderedSet(ts)
    if len(ts) == 1:
        return ts[0]
    ts = [t if isinstance(t, UnionType) else UnionType(frozenlist([t])) for t in ts]
    assert ts, &#34;Must have at least one type to intersect&#34;
    intersection_set = OrderedSet(ts[0].typs)
    for t in ts[1:]:
        intersection_set.intersection_update(t.typs)
    return UnionType(frozenlist(intersection_set))</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.map_to_orig_name"><code class="name flex">
<span>def <span class="ident">map_to_orig_name</span></span>(<span>name:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_to_orig_name(name: str):
    return re.sub(r&#34;_\d+$&#34;, &#34;&#34;, name)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.merge_scope"><code class="name flex">
<span>def <span class="ident">merge_scope</span></span>(<span>s1:Â Dict[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>], s2:Â Dict[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_scope(s1: typing.Dict[str, Type], s2: typing.Dict[str, Type]):
    keys = OrderedSet(s1.keys()).union(s2.keys())
    merged = {}
    for k in keys:
        if k not in s1.keys():
            merged[k] = s2[k]
        elif k not in s2.keys():
            merged[k] = s1[k]
        else:
            try:
                assert isinstance(s1[k], InstanceType) and isinstance(
                    s2[k], InstanceType
                ), &#34;Can only merge instance types&#34;
                merged[k] = InstanceType(union_types(s1[k].typ, s2[k].typ))
            except AssertionError as e:
                raise AssertionError(
                    f&#34;Can not merge scopes after branching, conflicting types for {k}: {e}&#34;
                )
    return merged</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.record_from_plutusdata"><code class="name flex">
<span>def <span class="ident">record_from_plutusdata</span></span>(<span>c:Â pycardano.plutus.PlutusData)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record_from_plutusdata(c: PlutusData):
    return Record(
        name=c.__class__.__name__,
        orig_name=c.__class__.__name__,
        constructor=c.CONSTR_ID,
        fields=frozenlist([(k, constant_type(v)) for k, v in c.__dict__.items()]),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.typed_ast"><code class="name flex">
<span>def <span class="ident">typed_ast</span></span>(<span>ast:Â ast.AST)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def typed_ast(ast: AST):
    return AggressiveTypeInferencer().visit(ast)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.union_types"><code class="name flex">
<span>def <span class="ident">union_types</span></span>(<span>*ts:Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union_types(*ts: Type):
    ts = OrderedSet(ts)
    # If all types are the same, just return the type
    if len(ts) == 1:
        return ts[0]
    # If there is a type that is compatible with all other types, choose the maximum
    for t in ts:
        if all(t &gt;= tp for tp in ts):
            return t
    assert ts, &#34;Union must combine multiple classes&#34;
    ts = [t if isinstance(t, UnionType) else UnionType(frozenlist([t])) for t in ts]
    for e in ts:
        for e2 in e.typs:
            assert isinstance(
                e2, RecordType
            ), f&#34;Union must combine multiple PlutusData classes but found {e2.__class__.__name__}&#34;
    union_set = OrderedSet()
    for t in ts:
        union_set.update(t.typs)
    assert distinct(
        [e.record.constructor for e in union_set]
    ), &#34;Union must combine PlutusData classes with unique constructors&#34;
    return UnionType(frozenlist(union_set))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opshin.type_inference.AggressiveTypeInferencer"><code class="flex name class">
<span>class <span class="ident">AggressiveTypeInferencer</span></span>
<span>(</span><span>allow_isinstance_anything=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A :class:<code>NodeVisitor</code> subclass that walks the abstract syntax tree and
allows modification of nodes.</p>
<p>The <code>NodeTransformer</code> will walk the AST and use the return value of the
visitor methods to replace or remove the old node.
If the return value of
the visitor method is <code>None</code>, the node will be removed from its location,
otherwise it is replaced with the return value.
The return value may be the
original node in which case no replacement takes place.</p>
<p>Here is an example transformer that rewrites all occurrences of name lookups
(<code>foo</code>) to <code>data['foo']</code>::</p>
<p>class RewriteName(NodeTransformer):</p>
<pre><code>   def visit_Name(self, node):
       return Subscript(
           value=Name(id='data', ctx=Load()),
           slice=Constant(value=node.id),
           ctx=node.ctx
       )
</code></pre>
<p>Keep in mind that if the node you're operating on has child nodes you must
either transform the child nodes yourself or call the :meth:<code>generic_visit</code>
method for the node first.</p>
<p>For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.</p>
<p>Usually you use the transformer like this::</p>
<p>node = YourTransformer().visit(node)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AggressiveTypeInferencer(CompilingNodeTransformer):
    def __init__(self, allow_isinstance_anything=False):
        self.allow_isinstance_anything = allow_isinstance_anything

    step = &#34;Static Type Inference&#34;

    # A stack of dictionaries for storing scoped knowledge of variable types
    scopes = [INITIAL_SCOPE]

    # Obtain the type of a variable name in the current scope
    def variable_type(self, name: str) -&gt; Type:
        name = name
        for scope in reversed(self.scopes):
            if name in scope:
                return scope[name]
        raise TypeInferenceError(
            f&#34;Variable {map_to_orig_name(name)} not initialized at access&#34;
        )

    def enter_scope(self):
        self.scopes.append({})

    def exit_scope(self):
        self.scopes.pop()

    def set_variable_type(self, name: str, typ: Type, force=False):
        if not force and name in self.scopes[-1] and self.scopes[-1][name] != typ:
            if self.scopes[-1][name] &gt;= typ:
                # the specified type is broader, we pass on this
                return
            raise TypeInferenceError(
                f&#34;Type {self.scopes[-1][name]} of variable {map_to_orig_name(name)} in local scope does not match inferred type {typ}&#34;
            )
        self.scopes[-1][name] = typ

    def implement_typechecks(self, typchecks: TypeMap):
        prevtyps = {}
        for n, t in typchecks.items():
            prevtyps[n] = self.variable_type(n).typ
            self.set_variable_type(n, InstanceType(t), force=True)
        return prevtyps

    def type_from_annotation(self, ann: expr):
        if isinstance(ann, Constant):
            if ann.value is None:
                return UnitType()
        if isinstance(ann, Name):
            if ann.id in ATOMIC_TYPES:
                return ATOMIC_TYPES[ann.id]
            v_t = self.variable_type(ann.id)
            if isinstance(v_t, ClassType):
                return v_t
            raise TypeInferenceError(
                f&#34;Class name {ann.orig_id} not initialized before annotating variable&#34;
            )
        if isinstance(ann, Subscript):
            assert isinstance(
                ann.value, Name
            ), &#34;Only Union, Dict and List are allowed as Generic types&#34;
            if ann.value.orig_id == &#34;Union&#34;:
                ann_types = frozenlist(
                    [self.type_from_annotation(e) for e in ann.slice.elts]
                )
                return union_types(*ann_types)
            if ann.value.orig_id == &#34;List&#34;:
                ann_type = self.type_from_annotation(ann.slice)
                assert isinstance(
                    ann_type, ClassType
                ), &#34;List must have a single type as parameter&#34;
                assert not isinstance(
                    ann_type, TupleType
                ), &#34;List can currently not hold tuples&#34;
                return ListType(InstanceType(ann_type))
            if ann.value.orig_id == &#34;Dict&#34;:
                assert isinstance(ann.slice, Tuple), &#34;Dict must combine two classes&#34;
                assert len(ann.slice.elts) == 2, &#34;Dict must combine two classes&#34;
                ann_types = self.type_from_annotation(
                    ann.slice.elts[0]
                ), self.type_from_annotation(ann.slice.elts[1])
                assert all(
                    isinstance(e, ClassType) for e in ann_types
                ), &#34;Dict must combine two classes&#34;
                assert not any(
                    isinstance(e, TupleType) for e in ann_types
                ), &#34;Dict can currently not hold tuples&#34;
                return DictType(*(InstanceType(a) for a in ann_types))
            if ann.value.orig_id == &#34;Tuple&#34;:
                assert isinstance(
                    ann.slice, Tuple
                ), &#34;Tuple must combine several classes&#34;
                ann_types = [self.type_from_annotation(e) for e in ann.slice.elts]
                assert all(
                    isinstance(e, ClassType) for e in ann_types
                ), &#34;Tuple must combine classes&#34;
                return TupleType(frozenlist([InstanceType(a) for a in ann_types]))
            raise NotImplementedError(
                &#34;Only Union, Dict and List are allowed as Generic types&#34;
            )
        if ann is None:
            return AnyType()
        raise NotImplementedError(f&#34;Annotation type {ann.__class__} is not supported&#34;)

    def visit_sequence(self, node_seq: typing.List[stmt]) -&gt; plt.AST:
        stmts = []
        prevtyps = {}
        for n in node_seq:
            stmt = self.visit(n)
            stmts.append(stmt)
            # if an assert is amng the statements apply the isinstance cast
            if isinstance(stmt, Assert):
                typchecks, _ = TypeCheckVisitor(self.allow_isinstance_anything).visit(
                    stmt.test
                )
                # for the time after this assert, the variable has the specialized type
                prevtyps.update(self.implement_typechecks(typchecks))
        self.implement_typechecks(prevtyps)
        return stmts

    def visit_ClassDef(self, node: ClassDef) -&gt; TypedClassDef:
        class_record = RecordReader.extract(node, self)
        typ = RecordType(class_record)
        self.set_variable_type(node.name, typ)
        typed_node = copy(node)
        typed_node.class_typ = typ
        return typed_node

    def visit_Constant(self, node: Constant) -&gt; TypedConstant:
        tc = copy(node)
        assert type(node.value) not in [
            float,
            complex,
            type(...),
        ], &#34;Float, complex numbers and ellipsis currently not supported&#34;
        tc.typ = constant_type(node.value)
        return tc

    def visit_Tuple(self, node: Tuple) -&gt; TypedTuple:
        tt = copy(node)
        tt.elts = [self.visit(e) for e in node.elts]
        tt.typ = InstanceType(TupleType(frozenlist([e.typ for e in tt.elts])))
        return tt

    def visit_List(self, node: List) -&gt; TypedList:
        tt = copy(node)
        tt.elts = [self.visit(e) for e in node.elts]
        l_typ = tt.elts[0].typ
        assert all(
            l_typ &gt;= e.typ for e in tt.elts
        ), &#34;All elements of a list must have the same type&#34;
        tt.typ = InstanceType(ListType(l_typ))
        return tt

    def visit_Dict(self, node: Dict) -&gt; TypedDict:
        tt = copy(node)
        tt.keys = [self.visit(k) for k in node.keys]
        tt.values = [self.visit(v) for v in node.values]
        k_typ = tt.keys[0].typ
        assert all(k_typ &gt;= k.typ for k in tt.keys), &#34;All keys must have the same type&#34;
        v_typ = tt.values[0].typ
        assert all(
            v_typ &gt;= v.typ for v in tt.values
        ), &#34;All values must have the same type&#34;
        tt.typ = InstanceType(DictType(k_typ, v_typ))
        return tt

    def visit_Assign(self, node: Assign) -&gt; TypedAssign:
        typed_ass = copy(node)
        typed_ass.value: TypedExpression = self.visit(node.value)
        # Make sure to first set the type of each target name so we can load it when visiting it
        for t in node.targets:
            assert isinstance(
                t, Name
            ), &#34;Can only assign to variable names, no type deconstruction&#34;
            # Check compatability to previous types -&gt; variable can be bound in a function before and needs to maintain type
            self.set_variable_type(t.id, typed_ass.value.typ)
        typed_ass.targets = [self.visit(t) for t in node.targets]
        return typed_ass

    def visit_AnnAssign(self, node: AnnAssign) -&gt; TypedAnnAssign:
        typed_ass = copy(node)
        typed_ass.annotation = self.type_from_annotation(node.annotation)
        if isinstance(typed_ass.annotation, ListType) and (
            (isinstance(node.value, Constant) and node.value.value == [])
            or (isinstance(node.value, List) and node.value.elts == [])
        ):
            # Empty lists are only allowed in annotated assignments
            typed_ass.value: TypedExpression = copy(node.value)
            typed_ass.value.typ = InstanceType(typed_ass.annotation)
        elif isinstance(typed_ass.annotation, DictType) and (
            (isinstance(node.value, Constant) and node.value.value == {})
            or (
                isinstance(node.value, Dict)
                and node.value.keys == []
                and node.value.values == []
            )
        ):
            # Empty lists are only allowed in annotated assignments
            typed_ass.value: TypedExpression = copy(node.value)
            typed_ass.value.typ = InstanceType(typed_ass.annotation)
        else:
            typed_ass.value: TypedExpression = self.visit(node.value)
        assert isinstance(
            node.target, Name
        ), &#34;Can only assign to variable names, no type deconstruction&#34;
        # Check compatability to previous types -&gt; variable can be bound in a function before and needs to maintain type
        self.set_variable_type(node.target.id, InstanceType(typed_ass.annotation))
        typed_ass.target = self.visit(node.target)
        assert (
            typed_ass.value.typ &gt;= InstanceType(typed_ass.annotation)
            or InstanceType(typed_ass.annotation) &gt;= typed_ass.value.typ
        ), &#34;Can only cast between related types&#34;
        return typed_ass

    def visit_If(self, node: If) -&gt; TypedIf:
        typed_if = copy(node)
        typed_if.test = self.visit(node.test)
        assert (
            typed_if.test.typ == BoolInstanceType
        ), &#34;Branching condition must have boolean type&#34;
        typchecks, inv_typchecks = TypeCheckVisitor(
            self.allow_isinstance_anything
        ).visit(typed_if.test)
        # for the time of the branch, these types are cast
        initial_scope = copy(self.scopes[-1])
        self.implement_typechecks(typchecks)
        typed_if.body = self.visit_sequence(node.body)
        # save resulting types
        final_scope_body = copy(self.scopes[-1])
        # reverse typechecks and remove typing of one branch
        self.scopes[-1] = initial_scope
        # for the time of the else branch, the inverse types hold
        self.implement_typechecks(inv_typchecks)
        typed_if.orelse = self.visit_sequence(node.orelse)
        final_scope_else = self.scopes[-1]
        # unify the resulting branch scopes
        self.scopes[-1] = merge_scope(final_scope_body, final_scope_else)
        return typed_if

    def visit_While(self, node: While) -&gt; TypedWhile:
        typed_while = copy(node)
        typed_while.test = self.visit(node.test)
        assert (
            typed_while.test.typ == BoolInstanceType
        ), &#34;Branching condition must have boolean type&#34;
        typchecks, inv_typchecks = TypeCheckVisitor(
            self.allow_isinstance_anything
        ).visit(typed_while.test)
        # for the time of the branch, these types are cast
        initial_scope = copy(self.scopes[-1])
        self.implement_typechecks(typchecks)
        typed_while.body = self.visit_sequence(node.body)
        final_scope_body = copy(self.scopes[-1])
        # revert changes
        self.scopes[-1] = initial_scope
        # for the time of the else branch, the inverse types hold
        self.implement_typechecks(inv_typchecks)
        typed_while.orelse = self.visit_sequence(node.orelse)
        final_scope_else = self.scopes[-1]
        self.scopes[-1] = merge_scope(final_scope_body, final_scope_else)
        return typed_while

    def visit_For(self, node: For) -&gt; TypedFor:
        typed_for = copy(node)
        typed_for.iter = self.visit(node.iter)
        if isinstance(node.target, Tuple):
            raise NotImplementedError(
                &#34;Tuple deconstruction in for loops is not supported yet&#34;
            )
        vartyp = None
        itertyp = typed_for.iter.typ
        assert isinstance(
            itertyp, InstanceType
        ), &#34;Can only iterate over instances, not classes&#34;
        if isinstance(itertyp.typ, TupleType):
            assert itertyp.typ.typs, &#34;Iterating over an empty tuple is not allowed&#34;
            vartyp = itertyp.typ.typs[0]
            assert all(
                itertyp.typ.typs[0] == t for t in typed_for.iter.typ.typs
            ), &#34;Iterating through a tuple requires the same type for each element&#34;
        elif isinstance(itertyp.typ, ListType):
            vartyp = itertyp.typ.typ
        else:
            raise NotImplementedError(
                &#34;Type inference for loops over non-list objects is not supported&#34;
            )
        self.set_variable_type(node.target.id, vartyp)
        typed_for.target = self.visit(node.target)
        typed_for.body = self.visit_sequence(node.body)
        typed_for.orelse = self.visit_sequence(node.orelse)
        return typed_for

    def visit_Name(self, node: Name) -&gt; TypedName:
        tn = copy(node)
        # Make sure that the rhs of an assign is evaluated first
        tn.typ = self.variable_type(node.id)
        return tn

    def visit_Compare(self, node: Compare) -&gt; TypedCompare:
        typed_cmp = copy(node)
        typed_cmp.left = self.visit(node.left)
        typed_cmp.comparators = [self.visit(s) for s in node.comparators]
        typed_cmp.typ = BoolInstanceType
        # the actual required types are being taken care of in the implementation
        return typed_cmp

    def visit_arg(self, node: arg) -&gt; typedarg:
        ta = copy(node)
        ta.typ = InstanceType(self.type_from_annotation(node.annotation))
        self.set_variable_type(ta.arg, ta.typ)
        return ta

    def visit_arguments(self, node: arguments) -&gt; typedarguments:
        if node.kw_defaults or node.kwarg or node.kwonlyargs or node.defaults:
            raise NotImplementedError(
                &#34;Keyword arguments and defaults not supported yet&#34;
            )
        ta = copy(node)
        ta.args = [self.visit(a) for a in node.args]
        return ta

    def visit_FunctionDef(self, node: FunctionDef) -&gt; TypedFunctionDef:
        tfd = copy(node)
        wraps_builtin = (
            all(
                isinstance(o, Name) and o.orig_id == &#34;wraps_builtin&#34;
                for o in node.decorator_list
            )
            and node.decorator_list
        )
        assert (
            not node.decorator_list or wraps_builtin
        ), &#34;Functions may not have decorators other than wraps_builtin&#34;
        self.enter_scope()
        tfd.args = self.visit(node.args)
        functyp = FunctionType(
            frozenlist([t.typ for t in tfd.args.args]),
            InstanceType(self.type_from_annotation(tfd.returns)),
            bound_vars={v: self.variable_type(v) for v in externally_bound_vars(node)},
            bind_self=node.name if node.name in read_vars(node) else None,
        )
        tfd.typ = InstanceType(functyp)
        if wraps_builtin:
            # the body of wrapping builtin functions is fully ignored
            pass
        else:
            # We need the function type inside for recursion
            self.set_variable_type(node.name, tfd.typ)
            tfd.body = self.visit_sequence(node.body)
            # Check that return type and annotated return type match
            rets_extractor = ReturnExtractor(functyp.rettyp)
            rets_extractor.check_fulfills(tfd)

        self.exit_scope()
        # We need the function type outside for usage
        self.set_variable_type(node.name, tfd.typ)
        return tfd

    def visit_Module(self, node: Module) -&gt; TypedModule:
        self.enter_scope()
        tm = copy(node)
        tm.body = self.visit_sequence(node.body)
        self.exit_scope()
        return tm

    def visit_Expr(self, node: Expr) -&gt; TypedExpr:
        tn = copy(node)
        tn.value = self.visit(node.value)
        return tn

    def visit_BinOp(self, node: BinOp) -&gt; TypedBinOp:
        tb = copy(node)
        tb.left = self.visit(node.left)
        tb.right = self.visit(node.right)
        binop_fun_typ: FunctionType = tb.left.typ.binop_type(tb.op, tb.right.typ)
        tb.typ = binop_fun_typ.rettyp
        return tb

    def visit_BoolOp(self, node: BoolOp) -&gt; TypedBoolOp:
        tt = copy(node)
        if isinstance(node.op, And):
            values = []
            prevtyps = {}
            for e in node.values:
                values.append(self.visit(e))
                typchecks, _ = TypeCheckVisitor(self.allow_isinstance_anything).visit(
                    values[-1]
                )
                # for the time after the shortcut and the variable type to the specialized type
                prevtyps.update(self.implement_typechecks(typchecks))
            self.implement_typechecks(prevtyps)
            tt.values = values
        elif isinstance(node.op, Or):
            values = []
            prevtyps = {}
            for e in node.values:
                values.append(self.visit(e))
                _, inv_typechecks = TypeCheckVisitor(
                    self.allow_isinstance_anything
                ).visit(values[-1])
                # for the time after the shortcut or the variable type is *not* the specialized type
                prevtyps.update(self.implement_typechecks(inv_typechecks))
            self.implement_typechecks(prevtyps)
            tt.values = values
        else:
            tt.values = [self.visit(e) for e in node.values]
        tt.typ = BoolInstanceType
        assert all(
            BoolInstanceType &gt;= e.typ for e in tt.values
        ), &#34;All values compared must be bools&#34;
        return tt

    def visit_UnaryOp(self, node: UnaryOp) -&gt; TypedUnaryOp:
        tu = copy(node)
        tu.operand = self.visit(node.operand)
        tu.typ = tu.operand.typ.typ.unop_type(node.op).rettyp
        return tu

    def visit_Subscript(self, node: Subscript) -&gt; TypedSubscript:
        ts = copy(node)
        # special case: Subscript of Union / Dict / List and atomic types
        if isinstance(ts.value, Name) and ts.value.orig_id in [
            &#34;Union&#34;,
            &#34;Dict&#34;,
            &#34;List&#34;,
        ]:
            ts.value = ts.typ = self.type_from_annotation(ts)
            return ts

        ts.value = self.visit(node.value)
        assert isinstance(ts.value.typ, InstanceType), &#34;Can only subscript instances&#34;
        if isinstance(ts.value.typ.typ, TupleType):
            assert (
                ts.value.typ.typ.typs
            ), &#34;Accessing elements from the empty tuple is not allowed&#34;
            if all(ts.value.typ.typ.typs[0] == t for t in ts.value.typ.typ.typs):
                ts.typ = ts.value.typ.typ.typs[0]
            elif isinstance(ts.slice, Constant) and isinstance(ts.slice.value, int):
                ts.typ = ts.value.typ.typ.typs[ts.slice.value]
            else:
                raise TypeInferenceError(
                    f&#34;Could not infer type of subscript of typ {ts.value.typ.typ.__class__}&#34;
                )
        elif isinstance(ts.value.typ.typ, PairType):
            if isinstance(ts.slice, Constant) and isinstance(ts.slice.value, int):
                ts.typ = (
                    ts.value.typ.typ.l_typ
                    if ts.slice.value == 0
                    else ts.value.typ.typ.r_typ
                )
            else:
                raise TypeInferenceError(
                    f&#34;Could not infer type of subscript of typ {ts.value.typ.typ.__class__}&#34;
                )
        elif isinstance(ts.value.typ.typ, ListType):
            if not isinstance(ts.slice, Slice):
                ts.typ = ts.value.typ.typ.typ
                ts.slice = self.visit(node.slice)
                assert (
                    ts.slice.typ == IntegerInstanceType
                ), &#34;List indices must be integers&#34;
            else:
                ts.typ = ts.value.typ
                if ts.slice.lower is None:
                    ts.slice.lower = Constant(0)
                ts.slice.lower = self.visit(node.slice.lower)
                assert (
                    ts.slice.lower.typ == IntegerInstanceType
                ), &#34;lower slice indices for lists must be integers&#34;
                if ts.slice.upper is None:
                    ts.slice.upper = Call(
                        func=Name(id=&#34;len&#34;, ctx=Load()), args=[ts.value], keywords=[]
                    )
                    ts.slice.upper.func.orig_id = &#34;len&#34;
                ts.slice.upper = self.visit(node.slice.upper)
                assert (
                    ts.slice.upper.typ == IntegerInstanceType
                ), &#34;upper slice indices for lists must be integers&#34;
        elif isinstance(ts.value.typ.typ, ByteStringType):
            if not isinstance(ts.slice, Slice):
                ts.typ = IntegerInstanceType
                ts.slice = self.visit(node.slice)
                assert (
                    ts.slice.typ == IntegerInstanceType
                ), &#34;bytes indices must be integers&#34;
            else:
                ts.typ = ByteStringInstanceType
                if ts.slice.lower is None:
                    ts.slice.lower = Constant(0)
                ts.slice.lower = self.visit(node.slice.lower)
                assert (
                    ts.slice.lower.typ == IntegerInstanceType
                ), &#34;lower slice indices for bytes must be integers&#34;
                if ts.slice.upper is None:
                    ts.slice.upper = Call(
                        func=Name(id=&#34;len&#34;, ctx=Load()), args=[ts.value], keywords=[]
                    )
                    ts.slice.upper.func.orig_id = &#34;len&#34;
                ts.slice.upper = self.visit(node.slice.upper)
                assert (
                    ts.slice.upper.typ == IntegerInstanceType
                ), &#34;upper slice indices for bytes must be integers&#34;
        elif isinstance(ts.value.typ.typ, DictType):
            if not isinstance(ts.slice, Slice):
                ts.slice = self.visit(node.slice)
                assert (
                    ts.slice.typ == ts.value.typ.typ.key_typ
                ), f&#34;Dict subscript must have dict key type {ts.value.typ.typ.key_typ} but has type {ts.slice.typ}&#34;
                ts.typ = ts.value.typ.typ.value_typ
            else:
                raise TypeInferenceError(
                    f&#34;Could not infer type of subscript of dict with a slice.&#34;
                )
        else:
            raise TypeInferenceError(
                f&#34;Could not infer type of subscript of typ {ts.value.typ.__class__}&#34;
            )
        return ts

    def visit_Call(self, node: Call) -&gt; TypedCall:
        assert not node.keywords, &#34;Keyword arguments are not supported yet&#34;
        tc = copy(node)
        tc.args = [self.visit(a) for a in node.args]
        # might be isinstance
        if isinstance(tc.func, Name) and tc.func.orig_id == &#34;isinstance&#34;:
            target_class = tc.args[1].typ
            if (
                isinstance(tc.args[0].typ, InstanceType)
                and isinstance(tc.args[0].typ.typ, AnyType)
                and not self.allow_isinstance_anything
            ):
                raise AssertionError(
                    &#34;OpShin does not permit checking the instance of raw Anything/Datum objects as this only checks the equality of the constructor id and nothing more. &#34;
                    &#34;If you are certain of what you are doing, please use the flag &#39;--allow-isinstance-anything&#39;.&#34;
                )
            ntc = Compare(
                left=Attribute(tc.args[0], &#34;CONSTR_ID&#34;),
                ops=[Eq()],
                comparators=[Constant(target_class.record.constructor)],
            )
            custom_fix_missing_locations(ntc, node)
            ntc = self.visit(ntc)
            ntc.typ = BoolInstanceType
            ntc.typechecks = TypeCheckVisitor(self.allow_isinstance_anything).visit(tc)
            return ntc
        tc.func = self.visit(node.func)
        # might be a class
        if isinstance(tc.func.typ, ClassType):
            tc.func.typ = tc.func.typ.constr_type()
        # type might only turn out after the initialization (note the constr could be polymorphic)
        if isinstance(tc.func.typ, InstanceType) and isinstance(
            tc.func.typ.typ, PolymorphicFunctionType
        ):
            tc.func.typ = PolymorphicFunctionInstanceType(
                tc.func.typ.typ.polymorphic_function.type_from_args(
                    [a.typ for a in tc.args]
                ),
                tc.func.typ.typ.polymorphic_function,
            )
        if isinstance(tc.func.typ, InstanceType) and isinstance(
            tc.func.typ.typ, FunctionType
        ):
            functyp = tc.func.typ.typ
            assert len(tc.args) == len(
                functyp.argtyps
            ), f&#34;Signature of function does not match number of arguments. Expected {len(functyp.argtyps)} arguments with these types: {functyp.argtyps} but got {len(tc.args)} arguments.&#34;
            # all arguments need to be subtypes of the parameter type
            for i, (a, ap) in enumerate(zip(tc.args, functyp.argtyps)):
                assert (
                    ap &gt;= a.typ
                ), f&#34;Signature of function does not match arguments in argument {i}. Expected this type: {ap} but got {a.typ}.&#34;
            tc.typ = functyp.rettyp
            return tc
        raise TypeInferenceError(&#34;Could not infer type of call&#34;)

    def visit_Pass(self, node: Pass) -&gt; TypedPass:
        tp = copy(node)
        return tp

    def visit_Return(self, node: Return) -&gt; TypedReturn:
        tp = copy(node)
        tp.value = self.visit(node.value)
        tp.typ = tp.value.typ
        return tp

    def visit_Attribute(self, node: Attribute) -&gt; TypedAttribute:
        tp = copy(node)
        tp.value = self.visit(node.value)
        owner = tp.value.typ
        # accesses to field
        tp.typ = owner.attribute_type(node.attr)
        return tp

    def visit_Assert(self, node: Assert) -&gt; TypedAssert:
        ta = copy(node)
        ta.test = self.visit(node.test)
        assert (
            ta.test.typ == BoolInstanceType
        ), &#34;Assertions must result in a boolean type&#34;
        if ta.msg is not None:
            ta.msg = self.visit(node.msg)
            assert (
                ta.msg.typ == StringInstanceType
            ), &#34;Assertions must has a string message (or None)&#34;
        return ta

    def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; RawPlutoExpr:
        assert node.typ is not None, &#34;Raw Pluto Expression is missing type annotation&#34;
        return node

    def visit_IfExp(self, node: IfExp) -&gt; TypedIfExp:
        node_cp = copy(node)
        node_cp.test = self.visit(node.test)
        assert node_cp.test.typ == BoolInstanceType, &#34;Comparison must have type boolean&#34;
        typchecks, inv_typchecks = TypeCheckVisitor(
            self.allow_isinstance_anything
        ).visit(node_cp.test)
        prevtyps = self.implement_typechecks(typchecks)
        node_cp.body = self.visit(node.body)
        self.implement_typechecks(prevtyps)
        prevtyps = self.implement_typechecks(inv_typchecks)
        node_cp.orelse = self.visit(node.orelse)
        self.implement_typechecks(prevtyps)
        if node_cp.body.typ &gt;= node_cp.orelse.typ:
            node_cp.typ = node_cp.body.typ
        elif node_cp.orelse.typ &gt;= node_cp.body.typ:
            node_cp.typ = node_cp.orelse.typ
        else:
            try:
                assert isinstance(node_cp.body.typ, InstanceType) and isinstance(
                    node_cp.orelse.typ, InstanceType
                )
                node_cp.typ = InstanceType(
                    union_types(node_cp.body.typ.typ, node_cp.orelse.typ.typ)
                )
            except AssertionError:
                raise TypeInferenceError(
                    &#34;Branches of if-expression must return compatible types.&#34;
                )
        return node_cp

    def visit_comprehension(self, g: comprehension) -&gt; typedcomprehension:
        new_g = copy(g)
        if isinstance(g.target, Tuple):
            raise NotImplementedError(
                &#34;Type deconstruction in for loops is not supported yet&#34;
            )
        new_g.iter = self.visit(g.iter)
        itertyp = new_g.iter.typ
        assert isinstance(
            itertyp, InstanceType
        ), &#34;Can only iterate over instances, not classes&#34;
        if isinstance(itertyp.typ, TupleType):
            assert itertyp.typ.typs, &#34;Iterating over an empty tuple is not allowed&#34;
            vartyp = itertyp.typ.typs[0]
            assert all(
                itertyp.typ.typs[0] == t for t in new_g.iter.typ.typs
            ), &#34;Iterating through a tuple requires the same type for each element&#34;
        elif isinstance(itertyp.typ, ListType):
            vartyp = itertyp.typ.typ
        else:
            raise NotImplementedError(
                &#34;Type inference for loops over non-list objects is not supported&#34;
            )
        self.set_variable_type(g.target.id, vartyp)
        new_g.target = self.visit(g.target)
        new_g.ifs = [self.visit(i) for i in g.ifs]
        return new_g

    def visit_ListComp(self, node: ListComp) -&gt; TypedListComp:
        typed_listcomp = copy(node)
        # inside the comprehension is a seperate scope
        self.enter_scope()
        # first evaluate generators for assigned variables
        typed_listcomp.generators = [self.visit(s) for s in node.generators]
        # then evaluate elements
        typed_listcomp.elt = self.visit(node.elt)
        self.exit_scope()
        typed_listcomp.typ = InstanceType(ListType(typed_listcomp.elt.typ))
        return typed_listcomp

    def visit_DictComp(self, node: DictComp) -&gt; TypedDictComp:
        typed_dictcomp = copy(node)
        # inside the comprehension is a seperate scope
        self.enter_scope()
        # first evaluate generators for assigned variables
        typed_dictcomp.generators = [self.visit(s) for s in node.generators]
        # then evaluate elements
        typed_dictcomp.key = self.visit(node.key)
        typed_dictcomp.value = self.visit(node.value)
        self.exit_scope()
        typed_dictcomp.typ = InstanceType(
            DictType(typed_dictcomp.key.typ, typed_dictcomp.value.typ)
        )
        return typed_dictcomp

    def visit_FormattedValue(self, node: FormattedValue) -&gt; TypedFormattedValue:
        typed_node = copy(node)
        typed_node.value = self.visit(node.value)
        assert node.conversion in (
            -1,
            115,
        ), &#34;Only string formatting is allowed but got repr or ascii formatting.&#34;
        assert (
            node.format_spec is None
        ), &#34;No format specification is allowed but got formatting specifiers (i.e. decimals).&#34;
        typed_node.typ = StringInstanceType
        return typed_node

    def visit_JoinedStr(self, node: JoinedStr) -&gt; TypedJoinedStr:
        typed_node = copy(node)
        typed_node.values = [self.visit(v) for v in node.values]
        typed_node.typ = StringInstanceType
        return typed_node

    def visit_ImportFrom(self, node: ImportFrom) -&gt; ImportFrom:
        assert node.module == &#34;opshin.bridge&#34;, &#34;Trying to import from invalid location&#34;
        return node

    def generic_visit(self, node: AST) -&gt; TypedAST:
        raise NotImplementedError(
            f&#34;Cannot infer type of non-implemented node {node.__class__}&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.CompilingNodeTransformer" href="util.html#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></li>
<li><a title="opshin.util.TypedNodeTransformer" href="util.html#opshin.util.TypedNodeTransformer">TypedNodeTransformer</a></li>
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_inference.AggressiveTypeInferencer.scopes"><code class="name">var <span class="ident">scopes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_inference.AggressiveTypeInferencer.enter_scope"><code class="name flex">
<span>def <span class="ident">enter_scope</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enter_scope(self):
    self.scopes.append({})</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.exit_scope"><code class="name flex">
<span>def <span class="ident">exit_scope</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_scope(self):
    self.scopes.pop()</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node:Â ast.AST) â€‘>Â <a title="opshin.typed_ast.TypedAST" href="typed_ast.html#opshin.typed_ast.TypedAST">TypedAST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node: AST) -&gt; TypedAST:
    raise NotImplementedError(
        f&#34;Cannot infer type of non-implemented node {node.__class__}&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.implement_typechecks"><code class="name flex">
<span>def <span class="ident">implement_typechecks</span></span>(<span>self, typchecks:Â Dict[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def implement_typechecks(self, typchecks: TypeMap):
    prevtyps = {}
    for n, t in typchecks.items():
        prevtyps[n] = self.variable_type(n).typ
        self.set_variable_type(n, InstanceType(t), force=True)
    return prevtyps</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.set_variable_type"><code class="name flex">
<span>def <span class="ident">set_variable_type</span></span>(<span>self, name:Â str, typ:Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>, force=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variable_type(self, name: str, typ: Type, force=False):
    if not force and name in self.scopes[-1] and self.scopes[-1][name] != typ:
        if self.scopes[-1][name] &gt;= typ:
            # the specified type is broader, we pass on this
            return
        raise TypeInferenceError(
            f&#34;Type {self.scopes[-1][name]} of variable {map_to_orig_name(name)} in local scope does not match inferred type {typ}&#34;
        )
    self.scopes[-1][name] = typ</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.type_from_annotation"><code class="name flex">
<span>def <span class="ident">type_from_annotation</span></span>(<span>self, ann:Â ast.expr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_annotation(self, ann: expr):
    if isinstance(ann, Constant):
        if ann.value is None:
            return UnitType()
    if isinstance(ann, Name):
        if ann.id in ATOMIC_TYPES:
            return ATOMIC_TYPES[ann.id]
        v_t = self.variable_type(ann.id)
        if isinstance(v_t, ClassType):
            return v_t
        raise TypeInferenceError(
            f&#34;Class name {ann.orig_id} not initialized before annotating variable&#34;
        )
    if isinstance(ann, Subscript):
        assert isinstance(
            ann.value, Name
        ), &#34;Only Union, Dict and List are allowed as Generic types&#34;
        if ann.value.orig_id == &#34;Union&#34;:
            ann_types = frozenlist(
                [self.type_from_annotation(e) for e in ann.slice.elts]
            )
            return union_types(*ann_types)
        if ann.value.orig_id == &#34;List&#34;:
            ann_type = self.type_from_annotation(ann.slice)
            assert isinstance(
                ann_type, ClassType
            ), &#34;List must have a single type as parameter&#34;
            assert not isinstance(
                ann_type, TupleType
            ), &#34;List can currently not hold tuples&#34;
            return ListType(InstanceType(ann_type))
        if ann.value.orig_id == &#34;Dict&#34;:
            assert isinstance(ann.slice, Tuple), &#34;Dict must combine two classes&#34;
            assert len(ann.slice.elts) == 2, &#34;Dict must combine two classes&#34;
            ann_types = self.type_from_annotation(
                ann.slice.elts[0]
            ), self.type_from_annotation(ann.slice.elts[1])
            assert all(
                isinstance(e, ClassType) for e in ann_types
            ), &#34;Dict must combine two classes&#34;
            assert not any(
                isinstance(e, TupleType) for e in ann_types
            ), &#34;Dict can currently not hold tuples&#34;
            return DictType(*(InstanceType(a) for a in ann_types))
        if ann.value.orig_id == &#34;Tuple&#34;:
            assert isinstance(
                ann.slice, Tuple
            ), &#34;Tuple must combine several classes&#34;
            ann_types = [self.type_from_annotation(e) for e in ann.slice.elts]
            assert all(
                isinstance(e, ClassType) for e in ann_types
            ), &#34;Tuple must combine classes&#34;
            return TupleType(frozenlist([InstanceType(a) for a in ann_types]))
        raise NotImplementedError(
            &#34;Only Union, Dict and List are allowed as Generic types&#34;
        )
    if ann is None:
        return AnyType()
    raise NotImplementedError(f&#34;Annotation type {ann.__class__} is not supported&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.variable_type"><code class="name flex">
<span>def <span class="ident">variable_type</span></span>(<span>self, name:Â str) â€‘>Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variable_type(self, name: str) -&gt; Type:
    name = name
    for scope in reversed(self.scopes):
        if name in scope:
            return scope[name]
    raise TypeInferenceError(
        f&#34;Variable {map_to_orig_name(name)} not initialized at access&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.CompilingNodeTransformer" href="util.html#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></code>.<code><a title="opshin.util.CompilingNodeTransformer.visit" href="util.html#opshin.util.CompilingNodeTransformer.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_AnnAssign"><code class="name flex">
<span>def <span class="ident">visit_AnnAssign</span></span>(<span>self, node:Â ast.AnnAssign) â€‘>Â <a title="opshin.typed_ast.TypedAnnAssign" href="typed_ast.html#opshin.typed_ast.TypedAnnAssign">TypedAnnAssign</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_AnnAssign(self, node: AnnAssign) -&gt; TypedAnnAssign:
    typed_ass = copy(node)
    typed_ass.annotation = self.type_from_annotation(node.annotation)
    if isinstance(typed_ass.annotation, ListType) and (
        (isinstance(node.value, Constant) and node.value.value == [])
        or (isinstance(node.value, List) and node.value.elts == [])
    ):
        # Empty lists are only allowed in annotated assignments
        typed_ass.value: TypedExpression = copy(node.value)
        typed_ass.value.typ = InstanceType(typed_ass.annotation)
    elif isinstance(typed_ass.annotation, DictType) and (
        (isinstance(node.value, Constant) and node.value.value == {})
        or (
            isinstance(node.value, Dict)
            and node.value.keys == []
            and node.value.values == []
        )
    ):
        # Empty lists are only allowed in annotated assignments
        typed_ass.value: TypedExpression = copy(node.value)
        typed_ass.value.typ = InstanceType(typed_ass.annotation)
    else:
        typed_ass.value: TypedExpression = self.visit(node.value)
    assert isinstance(
        node.target, Name
    ), &#34;Can only assign to variable names, no type deconstruction&#34;
    # Check compatability to previous types -&gt; variable can be bound in a function before and needs to maintain type
    self.set_variable_type(node.target.id, InstanceType(typed_ass.annotation))
    typed_ass.target = self.visit(node.target)
    assert (
        typed_ass.value.typ &gt;= InstanceType(typed_ass.annotation)
        or InstanceType(typed_ass.annotation) &gt;= typed_ass.value.typ
    ), &#34;Can only cast between related types&#34;
    return typed_ass</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Assert"><code class="name flex">
<span>def <span class="ident">visit_Assert</span></span>(<span>self, node:Â ast.Assert) â€‘>Â <a title="opshin.typed_ast.TypedAssert" href="typed_ast.html#opshin.typed_ast.TypedAssert">TypedAssert</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Assert(self, node: Assert) -&gt; TypedAssert:
    ta = copy(node)
    ta.test = self.visit(node.test)
    assert (
        ta.test.typ == BoolInstanceType
    ), &#34;Assertions must result in a boolean type&#34;
    if ta.msg is not None:
        ta.msg = self.visit(node.msg)
        assert (
            ta.msg.typ == StringInstanceType
        ), &#34;Assertions must has a string message (or None)&#34;
    return ta</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Assign"><code class="name flex">
<span>def <span class="ident">visit_Assign</span></span>(<span>self, node:Â ast.Assign) â€‘>Â <a title="opshin.typed_ast.TypedAssign" href="typed_ast.html#opshin.typed_ast.TypedAssign">TypedAssign</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Assign(self, node: Assign) -&gt; TypedAssign:
    typed_ass = copy(node)
    typed_ass.value: TypedExpression = self.visit(node.value)
    # Make sure to first set the type of each target name so we can load it when visiting it
    for t in node.targets:
        assert isinstance(
            t, Name
        ), &#34;Can only assign to variable names, no type deconstruction&#34;
        # Check compatability to previous types -&gt; variable can be bound in a function before and needs to maintain type
        self.set_variable_type(t.id, typed_ass.value.typ)
    typed_ass.targets = [self.visit(t) for t in node.targets]
    return typed_ass</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Attribute"><code class="name flex">
<span>def <span class="ident">visit_Attribute</span></span>(<span>self, node:Â ast.Attribute) â€‘>Â <a title="opshin.typed_ast.TypedAttribute" href="typed_ast.html#opshin.typed_ast.TypedAttribute">TypedAttribute</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Attribute(self, node: Attribute) -&gt; TypedAttribute:
    tp = copy(node)
    tp.value = self.visit(node.value)
    owner = tp.value.typ
    # accesses to field
    tp.typ = owner.attribute_type(node.attr)
    return tp</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node:Â ast.BinOp) â€‘>Â <a title="opshin.typed_ast.TypedBinOp" href="typed_ast.html#opshin.typed_ast.TypedBinOp">TypedBinOp</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BinOp(self, node: BinOp) -&gt; TypedBinOp:
    tb = copy(node)
    tb.left = self.visit(node.left)
    tb.right = self.visit(node.right)
    binop_fun_typ: FunctionType = tb.left.typ.binop_type(tb.op, tb.right.typ)
    tb.typ = binop_fun_typ.rettyp
    return tb</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_BoolOp"><code class="name flex">
<span>def <span class="ident">visit_BoolOp</span></span>(<span>self, node:Â ast.BoolOp) â€‘>Â <a title="opshin.typed_ast.TypedBoolOp" href="typed_ast.html#opshin.typed_ast.TypedBoolOp">TypedBoolOp</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BoolOp(self, node: BoolOp) -&gt; TypedBoolOp:
    tt = copy(node)
    if isinstance(node.op, And):
        values = []
        prevtyps = {}
        for e in node.values:
            values.append(self.visit(e))
            typchecks, _ = TypeCheckVisitor(self.allow_isinstance_anything).visit(
                values[-1]
            )
            # for the time after the shortcut and the variable type to the specialized type
            prevtyps.update(self.implement_typechecks(typchecks))
        self.implement_typechecks(prevtyps)
        tt.values = values
    elif isinstance(node.op, Or):
        values = []
        prevtyps = {}
        for e in node.values:
            values.append(self.visit(e))
            _, inv_typechecks = TypeCheckVisitor(
                self.allow_isinstance_anything
            ).visit(values[-1])
            # for the time after the shortcut or the variable type is *not* the specialized type
            prevtyps.update(self.implement_typechecks(inv_typechecks))
        self.implement_typechecks(prevtyps)
        tt.values = values
    else:
        tt.values = [self.visit(e) for e in node.values]
    tt.typ = BoolInstanceType
    assert all(
        BoolInstanceType &gt;= e.typ for e in tt.values
    ), &#34;All values compared must be bools&#34;
    return tt</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node:Â ast.Call) â€‘>Â <a title="opshin.typed_ast.TypedCall" href="typed_ast.html#opshin.typed_ast.TypedCall">TypedCall</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Call(self, node: Call) -&gt; TypedCall:
    assert not node.keywords, &#34;Keyword arguments are not supported yet&#34;
    tc = copy(node)
    tc.args = [self.visit(a) for a in node.args]
    # might be isinstance
    if isinstance(tc.func, Name) and tc.func.orig_id == &#34;isinstance&#34;:
        target_class = tc.args[1].typ
        if (
            isinstance(tc.args[0].typ, InstanceType)
            and isinstance(tc.args[0].typ.typ, AnyType)
            and not self.allow_isinstance_anything
        ):
            raise AssertionError(
                &#34;OpShin does not permit checking the instance of raw Anything/Datum objects as this only checks the equality of the constructor id and nothing more. &#34;
                &#34;If you are certain of what you are doing, please use the flag &#39;--allow-isinstance-anything&#39;.&#34;
            )
        ntc = Compare(
            left=Attribute(tc.args[0], &#34;CONSTR_ID&#34;),
            ops=[Eq()],
            comparators=[Constant(target_class.record.constructor)],
        )
        custom_fix_missing_locations(ntc, node)
        ntc = self.visit(ntc)
        ntc.typ = BoolInstanceType
        ntc.typechecks = TypeCheckVisitor(self.allow_isinstance_anything).visit(tc)
        return ntc
    tc.func = self.visit(node.func)
    # might be a class
    if isinstance(tc.func.typ, ClassType):
        tc.func.typ = tc.func.typ.constr_type()
    # type might only turn out after the initialization (note the constr could be polymorphic)
    if isinstance(tc.func.typ, InstanceType) and isinstance(
        tc.func.typ.typ, PolymorphicFunctionType
    ):
        tc.func.typ = PolymorphicFunctionInstanceType(
            tc.func.typ.typ.polymorphic_function.type_from_args(
                [a.typ for a in tc.args]
            ),
            tc.func.typ.typ.polymorphic_function,
        )
    if isinstance(tc.func.typ, InstanceType) and isinstance(
        tc.func.typ.typ, FunctionType
    ):
        functyp = tc.func.typ.typ
        assert len(tc.args) == len(
            functyp.argtyps
        ), f&#34;Signature of function does not match number of arguments. Expected {len(functyp.argtyps)} arguments with these types: {functyp.argtyps} but got {len(tc.args)} arguments.&#34;
        # all arguments need to be subtypes of the parameter type
        for i, (a, ap) in enumerate(zip(tc.args, functyp.argtyps)):
            assert (
                ap &gt;= a.typ
            ), f&#34;Signature of function does not match arguments in argument {i}. Expected this type: {ap} but got {a.typ}.&#34;
        tc.typ = functyp.rettyp
        return tc
    raise TypeInferenceError(&#34;Could not infer type of call&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node:Â ast.ClassDef) â€‘>Â <a title="opshin.typed_ast.TypedClassDef" href="typed_ast.html#opshin.typed_ast.TypedClassDef">TypedClassDef</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ClassDef(self, node: ClassDef) -&gt; TypedClassDef:
    class_record = RecordReader.extract(node, self)
    typ = RecordType(class_record)
    self.set_variable_type(node.name, typ)
    typed_node = copy(node)
    typed_node.class_typ = typ
    return typed_node</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Compare"><code class="name flex">
<span>def <span class="ident">visit_Compare</span></span>(<span>self, node:Â ast.Compare) â€‘>Â <a title="opshin.typed_ast.TypedCompare" href="typed_ast.html#opshin.typed_ast.TypedCompare">TypedCompare</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Compare(self, node: Compare) -&gt; TypedCompare:
    typed_cmp = copy(node)
    typed_cmp.left = self.visit(node.left)
    typed_cmp.comparators = [self.visit(s) for s in node.comparators]
    typed_cmp.typ = BoolInstanceType
    # the actual required types are being taken care of in the implementation
    return typed_cmp</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node:Â ast.Constant) â€‘>Â <a title="opshin.typed_ast.TypedConstant" href="typed_ast.html#opshin.typed_ast.TypedConstant">TypedConstant</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Constant(self, node: Constant) -&gt; TypedConstant:
    tc = copy(node)
    assert type(node.value) not in [
        float,
        complex,
        type(...),
    ], &#34;Float, complex numbers and ellipsis currently not supported&#34;
    tc.typ = constant_type(node.value)
    return tc</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Dict"><code class="name flex">
<span>def <span class="ident">visit_Dict</span></span>(<span>self, node:Â ast.Dict) â€‘>Â <a title="opshin.typed_ast.TypedDict" href="typed_ast.html#opshin.typed_ast.TypedDict">TypedDict</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Dict(self, node: Dict) -&gt; TypedDict:
    tt = copy(node)
    tt.keys = [self.visit(k) for k in node.keys]
    tt.values = [self.visit(v) for v in node.values]
    k_typ = tt.keys[0].typ
    assert all(k_typ &gt;= k.typ for k in tt.keys), &#34;All keys must have the same type&#34;
    v_typ = tt.values[0].typ
    assert all(
        v_typ &gt;= v.typ for v in tt.values
    ), &#34;All values must have the same type&#34;
    tt.typ = InstanceType(DictType(k_typ, v_typ))
    return tt</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_DictComp"><code class="name flex">
<span>def <span class="ident">visit_DictComp</span></span>(<span>self, node:Â ast.DictComp) â€‘>Â <a title="opshin.typed_ast.TypedDictComp" href="typed_ast.html#opshin.typed_ast.TypedDictComp">TypedDictComp</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_DictComp(self, node: DictComp) -&gt; TypedDictComp:
    typed_dictcomp = copy(node)
    # inside the comprehension is a seperate scope
    self.enter_scope()
    # first evaluate generators for assigned variables
    typed_dictcomp.generators = [self.visit(s) for s in node.generators]
    # then evaluate elements
    typed_dictcomp.key = self.visit(node.key)
    typed_dictcomp.value = self.visit(node.value)
    self.exit_scope()
    typed_dictcomp.typ = InstanceType(
        DictType(typed_dictcomp.key.typ, typed_dictcomp.value.typ)
    )
    return typed_dictcomp</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Expr"><code class="name flex">
<span>def <span class="ident">visit_Expr</span></span>(<span>self, node:Â ast.Expr) â€‘>Â <a title="opshin.typed_ast.TypedExpr" href="typed_ast.html#opshin.typed_ast.TypedExpr">TypedExpr</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Expr(self, node: Expr) -&gt; TypedExpr:
    tn = copy(node)
    tn.value = self.visit(node.value)
    return tn</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_For"><code class="name flex">
<span>def <span class="ident">visit_For</span></span>(<span>self, node:Â ast.For) â€‘>Â <a title="opshin.typed_ast.TypedFor" href="typed_ast.html#opshin.typed_ast.TypedFor">TypedFor</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_For(self, node: For) -&gt; TypedFor:
    typed_for = copy(node)
    typed_for.iter = self.visit(node.iter)
    if isinstance(node.target, Tuple):
        raise NotImplementedError(
            &#34;Tuple deconstruction in for loops is not supported yet&#34;
        )
    vartyp = None
    itertyp = typed_for.iter.typ
    assert isinstance(
        itertyp, InstanceType
    ), &#34;Can only iterate over instances, not classes&#34;
    if isinstance(itertyp.typ, TupleType):
        assert itertyp.typ.typs, &#34;Iterating over an empty tuple is not allowed&#34;
        vartyp = itertyp.typ.typs[0]
        assert all(
            itertyp.typ.typs[0] == t for t in typed_for.iter.typ.typs
        ), &#34;Iterating through a tuple requires the same type for each element&#34;
    elif isinstance(itertyp.typ, ListType):
        vartyp = itertyp.typ.typ
    else:
        raise NotImplementedError(
            &#34;Type inference for loops over non-list objects is not supported&#34;
        )
    self.set_variable_type(node.target.id, vartyp)
    typed_for.target = self.visit(node.target)
    typed_for.body = self.visit_sequence(node.body)
    typed_for.orelse = self.visit_sequence(node.orelse)
    return typed_for</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_FormattedValue"><code class="name flex">
<span>def <span class="ident">visit_FormattedValue</span></span>(<span>self, node:Â ast.FormattedValue) â€‘>Â <a title="opshin.typed_ast.TypedFormattedValue" href="typed_ast.html#opshin.typed_ast.TypedFormattedValue">TypedFormattedValue</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_FormattedValue(self, node: FormattedValue) -&gt; TypedFormattedValue:
    typed_node = copy(node)
    typed_node.value = self.visit(node.value)
    assert node.conversion in (
        -1,
        115,
    ), &#34;Only string formatting is allowed but got repr or ascii formatting.&#34;
    assert (
        node.format_spec is None
    ), &#34;No format specification is allowed but got formatting specifiers (i.e. decimals).&#34;
    typed_node.typ = StringInstanceType
    return typed_node</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node:Â ast.FunctionDef) â€‘>Â <a title="opshin.typed_ast.TypedFunctionDef" href="typed_ast.html#opshin.typed_ast.TypedFunctionDef">TypedFunctionDef</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_FunctionDef(self, node: FunctionDef) -&gt; TypedFunctionDef:
    tfd = copy(node)
    wraps_builtin = (
        all(
            isinstance(o, Name) and o.orig_id == &#34;wraps_builtin&#34;
            for o in node.decorator_list
        )
        and node.decorator_list
    )
    assert (
        not node.decorator_list or wraps_builtin
    ), &#34;Functions may not have decorators other than wraps_builtin&#34;
    self.enter_scope()
    tfd.args = self.visit(node.args)
    functyp = FunctionType(
        frozenlist([t.typ for t in tfd.args.args]),
        InstanceType(self.type_from_annotation(tfd.returns)),
        bound_vars={v: self.variable_type(v) for v in externally_bound_vars(node)},
        bind_self=node.name if node.name in read_vars(node) else None,
    )
    tfd.typ = InstanceType(functyp)
    if wraps_builtin:
        # the body of wrapping builtin functions is fully ignored
        pass
    else:
        # We need the function type inside for recursion
        self.set_variable_type(node.name, tfd.typ)
        tfd.body = self.visit_sequence(node.body)
        # Check that return type and annotated return type match
        rets_extractor = ReturnExtractor(functyp.rettyp)
        rets_extractor.check_fulfills(tfd)

    self.exit_scope()
    # We need the function type outside for usage
    self.set_variable_type(node.name, tfd.typ)
    return tfd</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_If"><code class="name flex">
<span>def <span class="ident">visit_If</span></span>(<span>self, node:Â ast.If) â€‘>Â <a title="opshin.typed_ast.TypedIf" href="typed_ast.html#opshin.typed_ast.TypedIf">TypedIf</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_If(self, node: If) -&gt; TypedIf:
    typed_if = copy(node)
    typed_if.test = self.visit(node.test)
    assert (
        typed_if.test.typ == BoolInstanceType
    ), &#34;Branching condition must have boolean type&#34;
    typchecks, inv_typchecks = TypeCheckVisitor(
        self.allow_isinstance_anything
    ).visit(typed_if.test)
    # for the time of the branch, these types are cast
    initial_scope = copy(self.scopes[-1])
    self.implement_typechecks(typchecks)
    typed_if.body = self.visit_sequence(node.body)
    # save resulting types
    final_scope_body = copy(self.scopes[-1])
    # reverse typechecks and remove typing of one branch
    self.scopes[-1] = initial_scope
    # for the time of the else branch, the inverse types hold
    self.implement_typechecks(inv_typchecks)
    typed_if.orelse = self.visit_sequence(node.orelse)
    final_scope_else = self.scopes[-1]
    # unify the resulting branch scopes
    self.scopes[-1] = merge_scope(final_scope_body, final_scope_else)
    return typed_if</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_IfExp"><code class="name flex">
<span>def <span class="ident">visit_IfExp</span></span>(<span>self, node:Â ast.IfExp) â€‘>Â <a title="opshin.typed_ast.TypedIfExp" href="typed_ast.html#opshin.typed_ast.TypedIfExp">TypedIfExp</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_IfExp(self, node: IfExp) -&gt; TypedIfExp:
    node_cp = copy(node)
    node_cp.test = self.visit(node.test)
    assert node_cp.test.typ == BoolInstanceType, &#34;Comparison must have type boolean&#34;
    typchecks, inv_typchecks = TypeCheckVisitor(
        self.allow_isinstance_anything
    ).visit(node_cp.test)
    prevtyps = self.implement_typechecks(typchecks)
    node_cp.body = self.visit(node.body)
    self.implement_typechecks(prevtyps)
    prevtyps = self.implement_typechecks(inv_typchecks)
    node_cp.orelse = self.visit(node.orelse)
    self.implement_typechecks(prevtyps)
    if node_cp.body.typ &gt;= node_cp.orelse.typ:
        node_cp.typ = node_cp.body.typ
    elif node_cp.orelse.typ &gt;= node_cp.body.typ:
        node_cp.typ = node_cp.orelse.typ
    else:
        try:
            assert isinstance(node_cp.body.typ, InstanceType) and isinstance(
                node_cp.orelse.typ, InstanceType
            )
            node_cp.typ = InstanceType(
                union_types(node_cp.body.typ.typ, node_cp.orelse.typ.typ)
            )
        except AssertionError:
            raise TypeInferenceError(
                &#34;Branches of if-expression must return compatible types.&#34;
            )
    return node_cp</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_ImportFrom"><code class="name flex">
<span>def <span class="ident">visit_ImportFrom</span></span>(<span>self, node:Â ast.ImportFrom) â€‘>Â ast.ImportFrom</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ImportFrom(self, node: ImportFrom) -&gt; ImportFrom:
    assert node.module == &#34;opshin.bridge&#34;, &#34;Trying to import from invalid location&#34;
    return node</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_JoinedStr"><code class="name flex">
<span>def <span class="ident">visit_JoinedStr</span></span>(<span>self, node:Â ast.JoinedStr) â€‘>Â <a title="opshin.typed_ast.TypedJoinedStr" href="typed_ast.html#opshin.typed_ast.TypedJoinedStr">TypedJoinedStr</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_JoinedStr(self, node: JoinedStr) -&gt; TypedJoinedStr:
    typed_node = copy(node)
    typed_node.values = [self.visit(v) for v in node.values]
    typed_node.typ = StringInstanceType
    return typed_node</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_List"><code class="name flex">
<span>def <span class="ident">visit_List</span></span>(<span>self, node:Â ast.List) â€‘>Â <a title="opshin.typed_ast.TypedList" href="typed_ast.html#opshin.typed_ast.TypedList">TypedList</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_List(self, node: List) -&gt; TypedList:
    tt = copy(node)
    tt.elts = [self.visit(e) for e in node.elts]
    l_typ = tt.elts[0].typ
    assert all(
        l_typ &gt;= e.typ for e in tt.elts
    ), &#34;All elements of a list must have the same type&#34;
    tt.typ = InstanceType(ListType(l_typ))
    return tt</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_ListComp"><code class="name flex">
<span>def <span class="ident">visit_ListComp</span></span>(<span>self, node:Â ast.ListComp) â€‘>Â <a title="opshin.typed_ast.TypedListComp" href="typed_ast.html#opshin.typed_ast.TypedListComp">TypedListComp</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ListComp(self, node: ListComp) -&gt; TypedListComp:
    typed_listcomp = copy(node)
    # inside the comprehension is a seperate scope
    self.enter_scope()
    # first evaluate generators for assigned variables
    typed_listcomp.generators = [self.visit(s) for s in node.generators]
    # then evaluate elements
    typed_listcomp.elt = self.visit(node.elt)
    self.exit_scope()
    typed_listcomp.typ = InstanceType(ListType(typed_listcomp.elt.typ))
    return typed_listcomp</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Module"><code class="name flex">
<span>def <span class="ident">visit_Module</span></span>(<span>self, node:Â ast.Module) â€‘>Â <a title="opshin.typed_ast.TypedModule" href="typed_ast.html#opshin.typed_ast.TypedModule">TypedModule</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Module(self, node: Module) -&gt; TypedModule:
    self.enter_scope()
    tm = copy(node)
    tm.body = self.visit_sequence(node.body)
    self.exit_scope()
    return tm</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node:Â ast.Name) â€‘>Â <a title="opshin.typed_ast.TypedName" href="typed_ast.html#opshin.typed_ast.TypedName">TypedName</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node: Name) -&gt; TypedName:
    tn = copy(node)
    # Make sure that the rhs of an assign is evaluated first
    tn.typ = self.variable_type(node.id)
    return tn</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Pass"><code class="name flex">
<span>def <span class="ident">visit_Pass</span></span>(<span>self, node:Â ast.Pass) â€‘>Â <a title="opshin.typed_ast.TypedPass" href="typed_ast.html#opshin.typed_ast.TypedPass">TypedPass</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Pass(self, node: Pass) -&gt; TypedPass:
    tp = copy(node)
    return tp</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_RawPlutoExpr"><code class="name flex">
<span>def <span class="ident">visit_RawPlutoExpr</span></span>(<span>self, node:Â <a title="opshin.typed_ast.RawPlutoExpr" href="typed_ast.html#opshin.typed_ast.RawPlutoExpr">RawPlutoExpr</a>) â€‘>Â <a title="opshin.typed_ast.RawPlutoExpr" href="typed_ast.html#opshin.typed_ast.RawPlutoExpr">RawPlutoExpr</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; RawPlutoExpr:
    assert node.typ is not None, &#34;Raw Pluto Expression is missing type annotation&#34;
    return node</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Return"><code class="name flex">
<span>def <span class="ident">visit_Return</span></span>(<span>self, node:Â ast.Return) â€‘>Â <a title="opshin.typed_ast.TypedReturn" href="typed_ast.html#opshin.typed_ast.TypedReturn">TypedReturn</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Return(self, node: Return) -&gt; TypedReturn:
    tp = copy(node)
    tp.value = self.visit(node.value)
    tp.typ = tp.value.typ
    return tp</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Subscript"><code class="name flex">
<span>def <span class="ident">visit_Subscript</span></span>(<span>self, node:Â ast.Subscript) â€‘>Â <a title="opshin.typed_ast.TypedSubscript" href="typed_ast.html#opshin.typed_ast.TypedSubscript">TypedSubscript</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Subscript(self, node: Subscript) -&gt; TypedSubscript:
    ts = copy(node)
    # special case: Subscript of Union / Dict / List and atomic types
    if isinstance(ts.value, Name) and ts.value.orig_id in [
        &#34;Union&#34;,
        &#34;Dict&#34;,
        &#34;List&#34;,
    ]:
        ts.value = ts.typ = self.type_from_annotation(ts)
        return ts

    ts.value = self.visit(node.value)
    assert isinstance(ts.value.typ, InstanceType), &#34;Can only subscript instances&#34;
    if isinstance(ts.value.typ.typ, TupleType):
        assert (
            ts.value.typ.typ.typs
        ), &#34;Accessing elements from the empty tuple is not allowed&#34;
        if all(ts.value.typ.typ.typs[0] == t for t in ts.value.typ.typ.typs):
            ts.typ = ts.value.typ.typ.typs[0]
        elif isinstance(ts.slice, Constant) and isinstance(ts.slice.value, int):
            ts.typ = ts.value.typ.typ.typs[ts.slice.value]
        else:
            raise TypeInferenceError(
                f&#34;Could not infer type of subscript of typ {ts.value.typ.typ.__class__}&#34;
            )
    elif isinstance(ts.value.typ.typ, PairType):
        if isinstance(ts.slice, Constant) and isinstance(ts.slice.value, int):
            ts.typ = (
                ts.value.typ.typ.l_typ
                if ts.slice.value == 0
                else ts.value.typ.typ.r_typ
            )
        else:
            raise TypeInferenceError(
                f&#34;Could not infer type of subscript of typ {ts.value.typ.typ.__class__}&#34;
            )
    elif isinstance(ts.value.typ.typ, ListType):
        if not isinstance(ts.slice, Slice):
            ts.typ = ts.value.typ.typ.typ
            ts.slice = self.visit(node.slice)
            assert (
                ts.slice.typ == IntegerInstanceType
            ), &#34;List indices must be integers&#34;
        else:
            ts.typ = ts.value.typ
            if ts.slice.lower is None:
                ts.slice.lower = Constant(0)
            ts.slice.lower = self.visit(node.slice.lower)
            assert (
                ts.slice.lower.typ == IntegerInstanceType
            ), &#34;lower slice indices for lists must be integers&#34;
            if ts.slice.upper is None:
                ts.slice.upper = Call(
                    func=Name(id=&#34;len&#34;, ctx=Load()), args=[ts.value], keywords=[]
                )
                ts.slice.upper.func.orig_id = &#34;len&#34;
            ts.slice.upper = self.visit(node.slice.upper)
            assert (
                ts.slice.upper.typ == IntegerInstanceType
            ), &#34;upper slice indices for lists must be integers&#34;
    elif isinstance(ts.value.typ.typ, ByteStringType):
        if not isinstance(ts.slice, Slice):
            ts.typ = IntegerInstanceType
            ts.slice = self.visit(node.slice)
            assert (
                ts.slice.typ == IntegerInstanceType
            ), &#34;bytes indices must be integers&#34;
        else:
            ts.typ = ByteStringInstanceType
            if ts.slice.lower is None:
                ts.slice.lower = Constant(0)
            ts.slice.lower = self.visit(node.slice.lower)
            assert (
                ts.slice.lower.typ == IntegerInstanceType
            ), &#34;lower slice indices for bytes must be integers&#34;
            if ts.slice.upper is None:
                ts.slice.upper = Call(
                    func=Name(id=&#34;len&#34;, ctx=Load()), args=[ts.value], keywords=[]
                )
                ts.slice.upper.func.orig_id = &#34;len&#34;
            ts.slice.upper = self.visit(node.slice.upper)
            assert (
                ts.slice.upper.typ == IntegerInstanceType
            ), &#34;upper slice indices for bytes must be integers&#34;
    elif isinstance(ts.value.typ.typ, DictType):
        if not isinstance(ts.slice, Slice):
            ts.slice = self.visit(node.slice)
            assert (
                ts.slice.typ == ts.value.typ.typ.key_typ
            ), f&#34;Dict subscript must have dict key type {ts.value.typ.typ.key_typ} but has type {ts.slice.typ}&#34;
            ts.typ = ts.value.typ.typ.value_typ
        else:
            raise TypeInferenceError(
                f&#34;Could not infer type of subscript of dict with a slice.&#34;
            )
    else:
        raise TypeInferenceError(
            f&#34;Could not infer type of subscript of typ {ts.value.typ.__class__}&#34;
        )
    return ts</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_Tuple"><code class="name flex">
<span>def <span class="ident">visit_Tuple</span></span>(<span>self, node:Â ast.Tuple) â€‘>Â <a title="opshin.typed_ast.TypedTuple" href="typed_ast.html#opshin.typed_ast.TypedTuple">TypedTuple</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Tuple(self, node: Tuple) -&gt; TypedTuple:
    tt = copy(node)
    tt.elts = [self.visit(e) for e in node.elts]
    tt.typ = InstanceType(TupleType(frozenlist([e.typ for e in tt.elts])))
    return tt</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node:Â ast.UnaryOp) â€‘>Â <a title="opshin.typed_ast.TypedUnaryOp" href="typed_ast.html#opshin.typed_ast.TypedUnaryOp">TypedUnaryOp</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_UnaryOp(self, node: UnaryOp) -&gt; TypedUnaryOp:
    tu = copy(node)
    tu.operand = self.visit(node.operand)
    tu.typ = tu.operand.typ.typ.unop_type(node.op).rettyp
    return tu</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_While"><code class="name flex">
<span>def <span class="ident">visit_While</span></span>(<span>self, node:Â ast.While) â€‘>Â <a title="opshin.typed_ast.TypedWhile" href="typed_ast.html#opshin.typed_ast.TypedWhile">TypedWhile</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_While(self, node: While) -&gt; TypedWhile:
    typed_while = copy(node)
    typed_while.test = self.visit(node.test)
    assert (
        typed_while.test.typ == BoolInstanceType
    ), &#34;Branching condition must have boolean type&#34;
    typchecks, inv_typchecks = TypeCheckVisitor(
        self.allow_isinstance_anything
    ).visit(typed_while.test)
    # for the time of the branch, these types are cast
    initial_scope = copy(self.scopes[-1])
    self.implement_typechecks(typchecks)
    typed_while.body = self.visit_sequence(node.body)
    final_scope_body = copy(self.scopes[-1])
    # revert changes
    self.scopes[-1] = initial_scope
    # for the time of the else branch, the inverse types hold
    self.implement_typechecks(inv_typchecks)
    typed_while.orelse = self.visit_sequence(node.orelse)
    final_scope_else = self.scopes[-1]
    self.scopes[-1] = merge_scope(final_scope_body, final_scope_else)
    return typed_while</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_arg"><code class="name flex">
<span>def <span class="ident">visit_arg</span></span>(<span>self, node:Â ast.arg) â€‘>Â <a title="opshin.typed_ast.typedarg" href="typed_ast.html#opshin.typed_ast.typedarg">typedarg</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_arg(self, node: arg) -&gt; typedarg:
    ta = copy(node)
    ta.typ = InstanceType(self.type_from_annotation(node.annotation))
    self.set_variable_type(ta.arg, ta.typ)
    return ta</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_arguments"><code class="name flex">
<span>def <span class="ident">visit_arguments</span></span>(<span>self, node:Â ast.arguments) â€‘>Â <a title="opshin.typed_ast.typedarguments" href="typed_ast.html#opshin.typed_ast.typedarguments">typedarguments</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_arguments(self, node: arguments) -&gt; typedarguments:
    if node.kw_defaults or node.kwarg or node.kwonlyargs or node.defaults:
        raise NotImplementedError(
            &#34;Keyword arguments and defaults not supported yet&#34;
        )
    ta = copy(node)
    ta.args = [self.visit(a) for a in node.args]
    return ta</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_comprehension"><code class="name flex">
<span>def <span class="ident">visit_comprehension</span></span>(<span>self, g:Â ast.comprehension) â€‘>Â <a title="opshin.typed_ast.typedcomprehension" href="typed_ast.html#opshin.typed_ast.typedcomprehension">typedcomprehension</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_comprehension(self, g: comprehension) -&gt; typedcomprehension:
    new_g = copy(g)
    if isinstance(g.target, Tuple):
        raise NotImplementedError(
            &#34;Type deconstruction in for loops is not supported yet&#34;
        )
    new_g.iter = self.visit(g.iter)
    itertyp = new_g.iter.typ
    assert isinstance(
        itertyp, InstanceType
    ), &#34;Can only iterate over instances, not classes&#34;
    if isinstance(itertyp.typ, TupleType):
        assert itertyp.typ.typs, &#34;Iterating over an empty tuple is not allowed&#34;
        vartyp = itertyp.typ.typs[0]
        assert all(
            itertyp.typ.typs[0] == t for t in new_g.iter.typ.typs
        ), &#34;Iterating through a tuple requires the same type for each element&#34;
    elif isinstance(itertyp.typ, ListType):
        vartyp = itertyp.typ.typ
    else:
        raise NotImplementedError(
            &#34;Type inference for loops over non-list objects is not supported&#34;
        )
    self.set_variable_type(g.target.id, vartyp)
    new_g.target = self.visit(g.target)
    new_g.ifs = [self.visit(i) for i in g.ifs]
    return new_g</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.AggressiveTypeInferencer.visit_sequence"><code class="name flex">
<span>def <span class="ident">visit_sequence</span></span>(<span>self, node_seq:Â List[ast.stmt]) â€‘>Â pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_sequence(self, node_seq: typing.List[stmt]) -&gt; plt.AST:
    stmts = []
    prevtyps = {}
    for n in node_seq:
        stmt = self.visit(n)
        stmts.append(stmt)
        # if an assert is amng the statements apply the isinstance cast
        if isinstance(stmt, Assert):
            typchecks, _ = TypeCheckVisitor(self.allow_isinstance_anything).visit(
                stmt.test
            )
            # for the time after this assert, the variable has the specialized type
            prevtyps.update(self.implement_typechecks(typchecks))
    self.implement_typechecks(prevtyps)
    return stmts</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_inference.RecordReader"><code class="flex name class">
<span>class <span class="ident">RecordReader</span></span>
<span>(</span><span>type_inferencer:Â <a title="opshin.type_inference.AggressiveTypeInferencer" href="#opshin.type_inference.AggressiveTypeInferencer">AggressiveTypeInferencer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordReader(NodeVisitor):
    name: str
    orig_name: str
    constructor: typing.Optional[int]
    attributes: typing.List[typing.Tuple[str, Type]]
    _type_inferencer: AggressiveTypeInferencer

    def __init__(self, type_inferencer: AggressiveTypeInferencer):
        self.constructor = None
        self.attributes = []
        self._type_inferencer = type_inferencer

    @classmethod
    def extract(cls, c: ClassDef, type_inferencer: AggressiveTypeInferencer) -&gt; Record:
        f = cls(type_inferencer)
        f.visit(c)
        if f.constructor is None:
            det_string = RecordType(
                Record(f.name, f.orig_name, 0, frozenlist(f.attributes))
            ).id_map(skip_constructor=True)
            det_hash = sha256(str(det_string).encode(&#34;utf8&#34;)).hexdigest()
            f.constructor = int(det_hash, 16) % 2**32
        return Record(f.name, f.orig_name, f.constructor, frozenlist(f.attributes))

    def visit_AnnAssign(self, node: AnnAssign) -&gt; None:
        assert isinstance(
            node.target, Name
        ), &#34;Record elements must have named attributes&#34;
        typ = self._type_inferencer.type_from_annotation(node.annotation)
        if node.target.id != &#34;CONSTR_ID&#34;:
            assert (
                node.value is None
            ), f&#34;PlutusData attribute {node.target.id} may not have a default value&#34;
            assert not isinstance(
                typ, TupleType
            ), &#34;Records can currently not hold tuples&#34;
            self.attributes.append(
                (
                    node.target.id,
                    InstanceType(typ),
                )
            )
            return
        assert typ == IntegerType, &#34;CONSTR_ID must be assigned an integer&#34;
        assert isinstance(
            node.value, Constant
        ), &#34;CONSTR_ID must be assigned a constant integer&#34;
        assert isinstance(
            node.value.value, int
        ), &#34;CONSTR_ID must be assigned an integer&#34;
        self.constructor = node.value.value

    def visit_ClassDef(self, node: ClassDef) -&gt; None:
        self.name = node.name
        self.orig_name = node.orig_name
        for s in node.body:
            self.visit(s)

    def visit_Pass(self, node: Pass) -&gt; None:
        pass

    def visit_Assign(self, node: Assign) -&gt; None:
        assert len(node.targets) == 1, &#34;Record elements must be assigned one by one&#34;
        target = node.targets[0]
        assert isinstance(target, Name), &#34;Record elements must have named attributes&#34;
        assert (
            target.id == &#34;CONSTR_ID&#34;
        ), &#34;Type annotations may only be omitted for CONSTR_ID&#34;
        assert isinstance(
            node.value, Constant
        ), &#34;CONSTR_ID must be assigned a constant integer&#34;
        assert isinstance(
            node.value.value, int
        ), &#34;CONSTR_ID must be assigned an integer&#34;
        self.constructor = node.value.value

    def visit_Expr(self, node: Expr) -&gt; None:
        assert isinstance(
            node.value, Constant
        ), &#34;Only comments are allowed inside classes&#34;
        return None

    def generic_visit(self, node: AST) -&gt; None:
        raise NotImplementedError(f&#34;Can not compile {ast.dump(node)} inside of a class&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_inference.RecordReader.attributes"><code class="name">var <span class="ident">attributes</span> :Â List[Tuple[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_inference.RecordReader.constructor"><code class="name">var <span class="ident">constructor</span> :Â Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_inference.RecordReader.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_inference.RecordReader.orig_name"><code class="name">var <span class="ident">orig_name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="opshin.type_inference.RecordReader.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>c:Â ast.ClassDef, type_inferencer:Â <a title="opshin.type_inference.AggressiveTypeInferencer" href="#opshin.type_inference.AggressiveTypeInferencer">AggressiveTypeInferencer</a>) â€‘>Â <a title="opshin.types.Record" href="types.html#opshin.types.Record">Record</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def extract(cls, c: ClassDef, type_inferencer: AggressiveTypeInferencer) -&gt; Record:
    f = cls(type_inferencer)
    f.visit(c)
    if f.constructor is None:
        det_string = RecordType(
            Record(f.name, f.orig_name, 0, frozenlist(f.attributes))
        ).id_map(skip_constructor=True)
        det_hash = sha256(str(det_string).encode(&#34;utf8&#34;)).hexdigest()
        f.constructor = int(det_hash, 16) % 2**32
    return Record(f.name, f.orig_name, f.constructor, frozenlist(f.attributes))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_inference.RecordReader.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node:Â ast.AST) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node: AST) -&gt; None:
    raise NotImplementedError(f&#34;Can not compile {ast.dump(node)} inside of a class&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.RecordReader.visit_AnnAssign"><code class="name flex">
<span>def <span class="ident">visit_AnnAssign</span></span>(<span>self, node:Â ast.AnnAssign) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_AnnAssign(self, node: AnnAssign) -&gt; None:
    assert isinstance(
        node.target, Name
    ), &#34;Record elements must have named attributes&#34;
    typ = self._type_inferencer.type_from_annotation(node.annotation)
    if node.target.id != &#34;CONSTR_ID&#34;:
        assert (
            node.value is None
        ), f&#34;PlutusData attribute {node.target.id} may not have a default value&#34;
        assert not isinstance(
            typ, TupleType
        ), &#34;Records can currently not hold tuples&#34;
        self.attributes.append(
            (
                node.target.id,
                InstanceType(typ),
            )
        )
        return
    assert typ == IntegerType, &#34;CONSTR_ID must be assigned an integer&#34;
    assert isinstance(
        node.value, Constant
    ), &#34;CONSTR_ID must be assigned a constant integer&#34;
    assert isinstance(
        node.value.value, int
    ), &#34;CONSTR_ID must be assigned an integer&#34;
    self.constructor = node.value.value</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.RecordReader.visit_Assign"><code class="name flex">
<span>def <span class="ident">visit_Assign</span></span>(<span>self, node:Â ast.Assign) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Assign(self, node: Assign) -&gt; None:
    assert len(node.targets) == 1, &#34;Record elements must be assigned one by one&#34;
    target = node.targets[0]
    assert isinstance(target, Name), &#34;Record elements must have named attributes&#34;
    assert (
        target.id == &#34;CONSTR_ID&#34;
    ), &#34;Type annotations may only be omitted for CONSTR_ID&#34;
    assert isinstance(
        node.value, Constant
    ), &#34;CONSTR_ID must be assigned a constant integer&#34;
    assert isinstance(
        node.value.value, int
    ), &#34;CONSTR_ID must be assigned an integer&#34;
    self.constructor = node.value.value</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.RecordReader.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node:Â ast.ClassDef) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ClassDef(self, node: ClassDef) -&gt; None:
    self.name = node.name
    self.orig_name = node.orig_name
    for s in node.body:
        self.visit(s)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.RecordReader.visit_Expr"><code class="name flex">
<span>def <span class="ident">visit_Expr</span></span>(<span>self, node:Â ast.Expr) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Expr(self, node: Expr) -&gt; None:
    assert isinstance(
        node.value, Constant
    ), &#34;Only comments are allowed inside classes&#34;
    return None</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.RecordReader.visit_Pass"><code class="name flex">
<span>def <span class="ident">visit_Pass</span></span>(<span>self, node:Â ast.Pass) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Pass(self, node: Pass) -&gt; None:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_inference.ReturnExtractor"><code class="flex name class">
<span>class <span class="ident">ReturnExtractor</span></span>
<span>(</span><span>func_rettyp:Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility to check that all paths end in Return statements with the proper type</p>
<p>Returns whether there is no remaining path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReturnExtractor(TypedNodeVisitor):
    &#34;&#34;&#34;
    Utility to check that all paths end in Return statements with the proper type

    Returns whether there is no remaining path
    &#34;&#34;&#34;

    def __init__(self, func_rettyp: Type):
        self.func_rettyp = func_rettyp

    def visit_sequence(self, nodes: typing.List[TypedAST]) -&gt; bool:
        all_paths_covered = False
        for node in nodes:
            all_paths_covered = self.visit(node)
            if all_paths_covered:
                break
        return all_paths_covered

    def visit_If(self, node: If) -&gt; bool:
        return self.visit_sequence(node.body) and self.visit_sequence(node.orelse)

    def visit_For(self, node: For) -&gt; bool:
        # The body simply has to be checked but has no influence on whether all paths are covered
        # because it might never be visited
        self.visit_sequence(node.body)
        # the else path is always visited
        return self.visit_sequence(node.orelse)

    def visit_While(self, node: For) -&gt; bool:
        # The body simply has to be checked but has no influence on whether all paths are covered
        # because it might never be visited
        self.visit_sequence(node.body)
        # the else path is always visited
        return self.visit_sequence(node.orelse)

    def visit_Return(self, node: Return) -&gt; bool:
        assert (
            self.func_rettyp &gt;= node.typ
        ), f&#34;Function annotated return type does not match actual return type&#34;
        return True

    def check_fulfills(self, node: FunctionDef):
        all_paths_covered = self.visit_sequence(node.body)
        if not all_paths_covered:
            assert (
                self.func_rettyp &gt;= NoneInstanceType
            ), f&#34;Function &#39;{node.name}&#39; has no return statement but is supposed to return not-None value&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.TypedNodeVisitor" href="util.html#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_inference.ReturnExtractor.check_fulfills"><code class="name flex">
<span>def <span class="ident">check_fulfills</span></span>(<span>self, node:Â ast.FunctionDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_fulfills(self, node: FunctionDef):
    all_paths_covered = self.visit_sequence(node.body)
    if not all_paths_covered:
        assert (
            self.func_rettyp &gt;= NoneInstanceType
        ), f&#34;Function &#39;{node.name}&#39; has no return statement but is supposed to return not-None value&#34;</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.ReturnExtractor.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.TypedNodeVisitor" href="util.html#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></code>.<code><a title="opshin.util.TypedNodeVisitor.visit" href="util.html#opshin.util.TypedNodeVisitor.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
<dt id="opshin.type_inference.ReturnExtractor.visit_For"><code class="name flex">
<span>def <span class="ident">visit_For</span></span>(<span>self, node:Â ast.For) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_For(self, node: For) -&gt; bool:
    # The body simply has to be checked but has no influence on whether all paths are covered
    # because it might never be visited
    self.visit_sequence(node.body)
    # the else path is always visited
    return self.visit_sequence(node.orelse)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.ReturnExtractor.visit_If"><code class="name flex">
<span>def <span class="ident">visit_If</span></span>(<span>self, node:Â ast.If) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_If(self, node: If) -&gt; bool:
    return self.visit_sequence(node.body) and self.visit_sequence(node.orelse)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.ReturnExtractor.visit_Return"><code class="name flex">
<span>def <span class="ident">visit_Return</span></span>(<span>self, node:Â ast.Return) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Return(self, node: Return) -&gt; bool:
    assert (
        self.func_rettyp &gt;= node.typ
    ), f&#34;Function annotated return type does not match actual return type&#34;
    return True</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.ReturnExtractor.visit_While"><code class="name flex">
<span>def <span class="ident">visit_While</span></span>(<span>self, node:Â ast.For) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_While(self, node: For) -&gt; bool:
    # The body simply has to be checked but has no influence on whether all paths are covered
    # because it might never be visited
    self.visit_sequence(node.body)
    # the else path is always visited
    return self.visit_sequence(node.orelse)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.ReturnExtractor.visit_sequence"><code class="name flex">
<span>def <span class="ident">visit_sequence</span></span>(<span>self, nodes:Â List[<a title="opshin.typed_ast.TypedAST" href="typed_ast.html#opshin.typed_ast.TypedAST">TypedAST</a>]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_sequence(self, nodes: typing.List[TypedAST]) -&gt; bool:
    all_paths_covered = False
    for node in nodes:
        all_paths_covered = self.visit(node)
        if all_paths_covered:
            break
    return all_paths_covered</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_inference.TypeCheckVisitor"><code class="flex name class">
<span>class <span class="ident">TypeCheckVisitor</span></span>
<span>(</span><span>allow_isinstance_anything=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the types to which objects are cast due to a boolean expression
It returns a tuple of dictionaries which are a name -&gt; type mapping
for variable names that are assured to have a specific type if this expression
is True/False respectively</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeCheckVisitor(TypedNodeVisitor):
    &#34;&#34;&#34;
    Generates the types to which objects are cast due to a boolean expression
    It returns a tuple of dictionaries which are a name -&gt; type mapping
    for variable names that are assured to have a specific type if this expression
    is True/False respectively
    &#34;&#34;&#34;

    def __init__(self, allow_isinstance_anything=False):
        self.allow_isinstance_anything = allow_isinstance_anything

    def generic_visit(self, node: AST) -&gt; TypeMapPair:
        return getattr(node, &#34;typechecks&#34;, ({}, {}))

    def visit_Call(self, node: Call) -&gt; TypeMapPair:
        if isinstance(node.func, Name) and node.func.orig_id == SPECIAL_BOOL:
            return self.visit(node.args[0])
        if not (isinstance(node.func, Name) and node.func.orig_id == &#34;isinstance&#34;):
            return ({}, {})
        # special case for Union
        assert isinstance(
            node.args[0], Name
        ), &#34;Target 0 of an isinstance cast must be a variable name&#34;
        assert isinstance(
            node.args[1], Name
        ), &#34;Target 1 of an isinstance cast must be a class name&#34;
        target_class: RecordType = node.args[1].typ
        inst = node.args[0]
        inst_class = inst.typ
        assert isinstance(
            inst_class, InstanceType
        ), &#34;Can only cast instances, not classes&#34;
        assert isinstance(target_class, RecordType), &#34;Can only cast to PlutusData&#34;
        if isinstance(inst_class.typ, UnionType):
            assert (
                target_class in inst_class.typ.typs
            ), f&#34;Trying to cast an instance of Union type to non-instance of union type&#34;
            union_without_target_class = union_types(
                *(x for x in inst_class.typ.typs if x != target_class)
            )
        elif isinstance(inst_class.typ, AnyType) and self.allow_isinstance_anything:
            union_without_target_class = AnyType()
        else:
            assert (
                inst_class.typ == target_class
            ), &#34;Can only cast instances of Union types of PlutusData or cast the same class. If you know what you are doing, enable the flag &#39;--allow-isinstance-anything&#39;&#34;
            union_without_target_class = target_class
        varname = node.args[0].id
        return ({varname: target_class}, {varname: union_without_target_class})

    def visit_BoolOp(self, node: BoolOp) -&gt; PairType:
        res = {}
        inv_res = {}
        checks = [self.visit(v) for v in node.values]
        checked_types = defaultdict(list)
        inv_checked_types = defaultdict(list)
        for c, inv_c in checks:
            for v, t in c.items():
                checked_types[v].append(t)
            for v, t in inv_c.items():
                inv_checked_types[v].append(t)
        if isinstance(node.op, And):
            # a conjunction is just the intersection
            for v, ts in checked_types.items():
                res[v] = intersection_types(*ts)
            # if the conjunction fails, its any of the respective reverses, but only if the type is checked in every conjunction
            for v, ts in inv_checked_types.items():
                if len(ts) &lt; len(checks):
                    continue
                inv_res[v] = union_types(*ts)
        if isinstance(node.op, Or):
            # a disjunction is just the union, but some type must be checked in every disjunction
            for v, ts in checked_types.items():
                if len(ts) &lt; len(checks):
                    continue
                res[v] = union_types(*ts)
            # if the disjunction fails, then it must be in the intersection of the inverses
            for v, ts in inv_checked_types.items():
                inv_res[v] = intersection_types(*ts)
        return (res, inv_res)

    def visit_UnaryOp(self, node: UnaryOp) -&gt; PairType:
        (res, inv_res) = self.visit(node.operand)
        if isinstance(node.op, Not):
            return (inv_res, res)
        return (res, inv_res)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.TypedNodeVisitor" href="util.html#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_inference.TypeCheckVisitor.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node:Â ast.AST) â€‘>Â Tuple[Dict[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>],Â Dict[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node: AST) -&gt; TypeMapPair:
    return getattr(node, &#34;typechecks&#34;, ({}, {}))</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.TypeCheckVisitor.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.TypedNodeVisitor" href="util.html#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></code>.<code><a title="opshin.util.TypedNodeVisitor.visit" href="util.html#opshin.util.TypedNodeVisitor.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
<dt id="opshin.type_inference.TypeCheckVisitor.visit_BoolOp"><code class="name flex">
<span>def <span class="ident">visit_BoolOp</span></span>(<span>self, node:Â ast.BoolOp) â€‘>Â <a title="opshin.types.PairType" href="types.html#opshin.types.PairType">PairType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BoolOp(self, node: BoolOp) -&gt; PairType:
    res = {}
    inv_res = {}
    checks = [self.visit(v) for v in node.values]
    checked_types = defaultdict(list)
    inv_checked_types = defaultdict(list)
    for c, inv_c in checks:
        for v, t in c.items():
            checked_types[v].append(t)
        for v, t in inv_c.items():
            inv_checked_types[v].append(t)
    if isinstance(node.op, And):
        # a conjunction is just the intersection
        for v, ts in checked_types.items():
            res[v] = intersection_types(*ts)
        # if the conjunction fails, its any of the respective reverses, but only if the type is checked in every conjunction
        for v, ts in inv_checked_types.items():
            if len(ts) &lt; len(checks):
                continue
            inv_res[v] = union_types(*ts)
    if isinstance(node.op, Or):
        # a disjunction is just the union, but some type must be checked in every disjunction
        for v, ts in checked_types.items():
            if len(ts) &lt; len(checks):
                continue
            res[v] = union_types(*ts)
        # if the disjunction fails, then it must be in the intersection of the inverses
        for v, ts in inv_checked_types.items():
            inv_res[v] = intersection_types(*ts)
    return (res, inv_res)</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.TypeCheckVisitor.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node:Â ast.Call) â€‘>Â Tuple[Dict[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>],Â Dict[str,Â <a title="opshin.types.Type" href="types.html#opshin.types.Type">Type</a>]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Call(self, node: Call) -&gt; TypeMapPair:
    if isinstance(node.func, Name) and node.func.orig_id == SPECIAL_BOOL:
        return self.visit(node.args[0])
    if not (isinstance(node.func, Name) and node.func.orig_id == &#34;isinstance&#34;):
        return ({}, {})
    # special case for Union
    assert isinstance(
        node.args[0], Name
    ), &#34;Target 0 of an isinstance cast must be a variable name&#34;
    assert isinstance(
        node.args[1], Name
    ), &#34;Target 1 of an isinstance cast must be a class name&#34;
    target_class: RecordType = node.args[1].typ
    inst = node.args[0]
    inst_class = inst.typ
    assert isinstance(
        inst_class, InstanceType
    ), &#34;Can only cast instances, not classes&#34;
    assert isinstance(target_class, RecordType), &#34;Can only cast to PlutusData&#34;
    if isinstance(inst_class.typ, UnionType):
        assert (
            target_class in inst_class.typ.typs
        ), f&#34;Trying to cast an instance of Union type to non-instance of union type&#34;
        union_without_target_class = union_types(
            *(x for x in inst_class.typ.typs if x != target_class)
        )
    elif isinstance(inst_class.typ, AnyType) and self.allow_isinstance_anything:
        union_without_target_class = AnyType()
    else:
        assert (
            inst_class.typ == target_class
        ), &#34;Can only cast instances of Union types of PlutusData or cast the same class. If you know what you are doing, enable the flag &#39;--allow-isinstance-anything&#39;&#34;
        union_without_target_class = target_class
    varname = node.args[0].id
    return ({varname: target_class}, {varname: union_without_target_class})</code></pre>
</details>
</dd>
<dt id="opshin.type_inference.TypeCheckVisitor.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node:Â ast.UnaryOp) â€‘>Â <a title="opshin.types.PairType" href="types.html#opshin.types.PairType">PairType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_UnaryOp(self, node: UnaryOp) -&gt; PairType:
    (res, inv_res) = self.visit(node.operand)
    if isinstance(node.op, Not):
        return (inv_res, res)
    return (res, inv_res)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="opshin Home" href="https://opshin.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/opshin/master/opshin.png" alt="opshin logo"> &nbsp; opshin
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opshin" href="index.html">opshin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opshin.type_inference.constant_type" href="#opshin.type_inference.constant_type">constant_type</a></code></li>
<li><code><a title="opshin.type_inference.intersection_types" href="#opshin.type_inference.intersection_types">intersection_types</a></code></li>
<li><code><a title="opshin.type_inference.map_to_orig_name" href="#opshin.type_inference.map_to_orig_name">map_to_orig_name</a></code></li>
<li><code><a title="opshin.type_inference.merge_scope" href="#opshin.type_inference.merge_scope">merge_scope</a></code></li>
<li><code><a title="opshin.type_inference.record_from_plutusdata" href="#opshin.type_inference.record_from_plutusdata">record_from_plutusdata</a></code></li>
<li><code><a title="opshin.type_inference.typed_ast" href="#opshin.type_inference.typed_ast">typed_ast</a></code></li>
<li><code><a title="opshin.type_inference.union_types" href="#opshin.type_inference.union_types">union_types</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opshin.type_inference.AggressiveTypeInferencer" href="#opshin.type_inference.AggressiveTypeInferencer">AggressiveTypeInferencer</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.enter_scope" href="#opshin.type_inference.AggressiveTypeInferencer.enter_scope">enter_scope</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.exit_scope" href="#opshin.type_inference.AggressiveTypeInferencer.exit_scope">exit_scope</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.generic_visit" href="#opshin.type_inference.AggressiveTypeInferencer.generic_visit">generic_visit</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.implement_typechecks" href="#opshin.type_inference.AggressiveTypeInferencer.implement_typechecks">implement_typechecks</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.scopes" href="#opshin.type_inference.AggressiveTypeInferencer.scopes">scopes</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.set_variable_type" href="#opshin.type_inference.AggressiveTypeInferencer.set_variable_type">set_variable_type</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.step" href="#opshin.type_inference.AggressiveTypeInferencer.step">step</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.type_from_annotation" href="#opshin.type_inference.AggressiveTypeInferencer.type_from_annotation">type_from_annotation</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.variable_type" href="#opshin.type_inference.AggressiveTypeInferencer.variable_type">variable_type</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit" href="util.html#opshin.type_inference.AggressiveTypeInferencer.visit">visit</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_AnnAssign" href="#opshin.type_inference.AggressiveTypeInferencer.visit_AnnAssign">visit_AnnAssign</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Assert" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Assert">visit_Assert</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Assign" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Assign">visit_Assign</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Attribute" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Attribute">visit_Attribute</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_BinOp" href="#opshin.type_inference.AggressiveTypeInferencer.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_BoolOp" href="#opshin.type_inference.AggressiveTypeInferencer.visit_BoolOp">visit_BoolOp</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Call" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Call">visit_Call</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_ClassDef" href="#opshin.type_inference.AggressiveTypeInferencer.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Compare" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Compare">visit_Compare</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Constant" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Dict" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Dict">visit_Dict</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_DictComp" href="#opshin.type_inference.AggressiveTypeInferencer.visit_DictComp">visit_DictComp</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Expr" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Expr">visit_Expr</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_For" href="#opshin.type_inference.AggressiveTypeInferencer.visit_For">visit_For</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_FormattedValue" href="#opshin.type_inference.AggressiveTypeInferencer.visit_FormattedValue">visit_FormattedValue</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_FunctionDef" href="#opshin.type_inference.AggressiveTypeInferencer.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_If" href="#opshin.type_inference.AggressiveTypeInferencer.visit_If">visit_If</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_IfExp" href="#opshin.type_inference.AggressiveTypeInferencer.visit_IfExp">visit_IfExp</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_ImportFrom" href="#opshin.type_inference.AggressiveTypeInferencer.visit_ImportFrom">visit_ImportFrom</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_JoinedStr" href="#opshin.type_inference.AggressiveTypeInferencer.visit_JoinedStr">visit_JoinedStr</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_List" href="#opshin.type_inference.AggressiveTypeInferencer.visit_List">visit_List</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_ListComp" href="#opshin.type_inference.AggressiveTypeInferencer.visit_ListComp">visit_ListComp</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Module" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Module">visit_Module</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Name" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Name">visit_Name</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Pass" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Pass">visit_Pass</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_RawPlutoExpr" href="#opshin.type_inference.AggressiveTypeInferencer.visit_RawPlutoExpr">visit_RawPlutoExpr</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Return" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Return">visit_Return</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Subscript" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Subscript">visit_Subscript</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_Tuple" href="#opshin.type_inference.AggressiveTypeInferencer.visit_Tuple">visit_Tuple</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_UnaryOp" href="#opshin.type_inference.AggressiveTypeInferencer.visit_UnaryOp">visit_UnaryOp</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_While" href="#opshin.type_inference.AggressiveTypeInferencer.visit_While">visit_While</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_arg" href="#opshin.type_inference.AggressiveTypeInferencer.visit_arg">visit_arg</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_arguments" href="#opshin.type_inference.AggressiveTypeInferencer.visit_arguments">visit_arguments</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_comprehension" href="#opshin.type_inference.AggressiveTypeInferencer.visit_comprehension">visit_comprehension</a></code></li>
<li><code><a title="opshin.type_inference.AggressiveTypeInferencer.visit_sequence" href="#opshin.type_inference.AggressiveTypeInferencer.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_inference.RecordReader" href="#opshin.type_inference.RecordReader">RecordReader</a></code></h4>
<ul class="two-column">
<li><code><a title="opshin.type_inference.RecordReader.attributes" href="#opshin.type_inference.RecordReader.attributes">attributes</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.constructor" href="#opshin.type_inference.RecordReader.constructor">constructor</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.extract" href="#opshin.type_inference.RecordReader.extract">extract</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.generic_visit" href="#opshin.type_inference.RecordReader.generic_visit">generic_visit</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.name" href="#opshin.type_inference.RecordReader.name">name</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.orig_name" href="#opshin.type_inference.RecordReader.orig_name">orig_name</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.visit_AnnAssign" href="#opshin.type_inference.RecordReader.visit_AnnAssign">visit_AnnAssign</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.visit_Assign" href="#opshin.type_inference.RecordReader.visit_Assign">visit_Assign</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.visit_ClassDef" href="#opshin.type_inference.RecordReader.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.visit_Expr" href="#opshin.type_inference.RecordReader.visit_Expr">visit_Expr</a></code></li>
<li><code><a title="opshin.type_inference.RecordReader.visit_Pass" href="#opshin.type_inference.RecordReader.visit_Pass">visit_Pass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_inference.ReturnExtractor" href="#opshin.type_inference.ReturnExtractor">ReturnExtractor</a></code></h4>
<ul class="two-column">
<li><code><a title="opshin.type_inference.ReturnExtractor.check_fulfills" href="#opshin.type_inference.ReturnExtractor.check_fulfills">check_fulfills</a></code></li>
<li><code><a title="opshin.type_inference.ReturnExtractor.visit" href="util.html#opshin.type_inference.ReturnExtractor.visit">visit</a></code></li>
<li><code><a title="opshin.type_inference.ReturnExtractor.visit_For" href="#opshin.type_inference.ReturnExtractor.visit_For">visit_For</a></code></li>
<li><code><a title="opshin.type_inference.ReturnExtractor.visit_If" href="#opshin.type_inference.ReturnExtractor.visit_If">visit_If</a></code></li>
<li><code><a title="opshin.type_inference.ReturnExtractor.visit_Return" href="#opshin.type_inference.ReturnExtractor.visit_Return">visit_Return</a></code></li>
<li><code><a title="opshin.type_inference.ReturnExtractor.visit_While" href="#opshin.type_inference.ReturnExtractor.visit_While">visit_While</a></code></li>
<li><code><a title="opshin.type_inference.ReturnExtractor.visit_sequence" href="#opshin.type_inference.ReturnExtractor.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_inference.TypeCheckVisitor" href="#opshin.type_inference.TypeCheckVisitor">TypeCheckVisitor</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_inference.TypeCheckVisitor.generic_visit" href="#opshin.type_inference.TypeCheckVisitor.generic_visit">generic_visit</a></code></li>
<li><code><a title="opshin.type_inference.TypeCheckVisitor.visit" href="util.html#opshin.type_inference.TypeCheckVisitor.visit">visit</a></code></li>
<li><code><a title="opshin.type_inference.TypeCheckVisitor.visit_BoolOp" href="#opshin.type_inference.TypeCheckVisitor.visit_BoolOp">visit_BoolOp</a></code></li>
<li><code><a title="opshin.type_inference.TypeCheckVisitor.visit_Call" href="#opshin.type_inference.TypeCheckVisitor.visit_Call">visit_Call</a></code></li>
<li><code><a title="opshin.type_inference.TypeCheckVisitor.visit_UnaryOp" href="#opshin.type_inference.TypeCheckVisitor.visit_UnaryOp">visit_UnaryOp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>