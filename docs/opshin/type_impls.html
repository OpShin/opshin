<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/opshin/dev/docs/opshin_32.png" sizes="32x32" type="image/png">
<title>opshin.type_impls API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/opshin" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>opshin.type_impls</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import dataclasses
from typing import Callable

import logging
from ast import *

import itertools
from ordered_set import OrderedSet

import uplc.ast

from .util import *


class TypeInferenceError(AssertionError):
    pass


class Type:
    def __new__(meta, *args, **kwargs):
        klass = super().__new__(meta)

        for key in [&#34;constr&#34;, &#34;attribute&#34;, &#34;cmp&#34;, &#34;stringify&#34;, &#34;copy_only_attributes&#34;]:
            value = getattr(klass, key)
            wrapped = patternize(value)
            object.__setattr__(klass, key, wrapped)

        return klass

    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        &#34;&#34;&#34;The type of the constructor for this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {self.__class__} does not have a constructor&#34;
        )

    def constr(self) -&gt; plt.AST:
        &#34;&#34;&#34;The constructor for this class&#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Constructor of {type(self).__name__} not implemented&#34;
        )

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {type(self).__name__} does not have attribute {attr}&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Needs to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Comparison {type(op).__name__} for {self.__class__.__name__} and {o.__class__.__name__} is not implemented. This is likely intended because it would always evaluate to False.&#34;
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        &#34;&#34;&#34;
        Returns a stringified version of the object

        The recursive parameter informs the method whether it was invoked recursively from another invokation
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;{type(self).__name__} can not be stringified&#34;)

    def copy_only_attributes(self) -&gt; plt.AST:
        &#34;&#34;&#34;
        Pluthon function that returns a copy of only the attributes of the object
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;{type(self).__name__} can not be copied&#34;)

    def binop_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Type of a binary operation between self and other.
        &#34;&#34;&#34;
        return FunctionType(
            [InstanceType(self), InstanceType(other)],
            InstanceType(self._binop_return_type(binop, other)),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Return the type of a binary operation between self and other
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} does not implement {binop.__class__.__name__}&#34;
        )

    def binop(self, binop: operator, other: AST) -&gt; plt.AST:
        &#34;&#34;&#34;
        Implements a binary operation between self and other
        &#34;&#34;&#34;
        return OLambda(
            [&#34;self&#34;, &#34;other&#34;],
            self._binop_bin_fun(binop, other)(OVar(&#34;self&#34;), OVar(&#34;other&#34;)),
        )

    def _binop_bin_fun(
        self, binop: operator, other: AST
    ) -&gt; Callable[[plt.AST, plt.AST], plt.AST]:
        &#34;&#34;&#34;
        Returns a binary function that implements the binary operation between self and other.
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} can not be used with operation {binop.__class__.__name__}&#34;
        )

    def unop_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Type of a unary operation on self.
        &#34;&#34;&#34;
        return FunctionType(
            [InstanceType(self)],
            InstanceType(self._unop_return_type(unop)),
        )

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Return the type of a binary operation between self and other
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} does not implement {unop.__class__.__name__}&#34;
        )

    def unop(self, unop: unaryop) -&gt; plt.AST:
        &#34;&#34;&#34;
        Implements a unary operation on self
        &#34;&#34;&#34;
        return OLambda(
            [&#34;self&#34;],
            self._unop_fun(unop)(OVar(&#34;self&#34;)),
        )

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        &#34;&#34;&#34;
        Returns a unary function that implements the unary operation on self.
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} can not be used with operation {unop.__class__.__name__}&#34;
        )

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        &#34;&#34;&#34;
        Returns a map from the constructor id to a descriptive typestring
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;Type {type(self).__name__} does not have a id map&#34;)


@dataclass(frozen=True, unsafe_hash=True)
class Record:
    name: str
    orig_name: str
    constructor: int
    fields: typing.Union[typing.List[typing.Tuple[str, Type]], frozenlist]

    def __post_init__(self):
        object.__setattr__(self, &#34;fields&#34;, frozenlist(self.fields))

    def __ge__(self, other):
        if not isinstance(other, Record):
            return False
        return (
            self.constructor == other.constructor
            and len(self.fields) == len(other.fields)
            and all(a &gt;= b for a, b in zip(self.fields, other.fields))
        )


@dataclass(frozen=True, unsafe_hash=True)
class ClassType(Type):
    def __ge__(self, other):
        &#34;&#34;&#34;
        Returns whether other can be substituted for this type.
        In other words this returns whether the interface of this type is a subset of the interface of other.
        Note that this is usually &lt;= and not &gt;=, but this needs to be fixed later.
        Produces a partial order on types.
        The top element is the most generic type and can not substitute for anything.
        The bottom element is the most specific type and can be substituted for anything.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Comparison between raw classtypes impossible&#34;)

    def copy_only_attributes(self) -&gt; plt.AST:
        &#34;&#34;&#34;
        Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
        For anything but record types and union types, this is the identity function.
        &#34;&#34;&#34;
        return OLambda([&#34;self&#34;], OVar(&#34;self&#34;))


@dataclass(frozen=True, unsafe_hash=True)
class AnyType(ClassType):
    &#34;&#34;&#34;The top element in the partial order on types (excluding FunctionTypes, which do not compare to anything)&#34;&#34;&#34;

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;any&#34;

    def attribute_type(self, attr: str) -&gt; Type:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        return super().attribute_type(attr)

    def attribute(self, attr: str) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return OLambda(
                [&#34;self&#34;],
                plt.Constructor(OVar(&#34;self&#34;)),
            )
        return super().attribute(attr)

    def __ge__(self, other):
        return (
            isinstance(other, ClassType)
            and not isinstance(other, FunctionType)
            and not isinstance(other, PolymorphicFunctionType)
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        if (
            (isinstance(o, RecordType))
            or isinstance(o, UnionType)
            or isinstance(o, AnyType)
        ):
            # Note that comparison with Record and UnionType is actually fine because both are Data
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                            OVar(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and (o.typ.typ &gt;= self or self &gt;= o.typ.typ)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        OPSHIN_LOGGER.warning(
            &#34;Serializing AnyType will result in RawPlutusData (CBOR representation) to be printed without additional type information. Annotate types where possible to avoid this warning.&#34;
        )
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [
                    (
                        &#34;joinMapList&#34;,
                        OLambda(
                            [&#34;m&#34;, &#34;l&#34;, &#34;start&#34;, &#34;end&#34;],
                            OLet(
                                [
                                    (
                                        &#34;g&#34;,
                                        plt.RecFun(
                                            OLambda(
                                                [&#34;f&#34;, &#34;l&#34;],
                                                plt.AppendString(
                                                    plt.Apply(
                                                        OVar(&#34;m&#34;),
                                                        plt.HeadList(OVar(&#34;l&#34;)),
                                                    ),
                                                    OLet(
                                                        [
                                                            (
                                                                &#34;t&#34;,
                                                                plt.TailList(OVar(&#34;l&#34;)),
                                                            )
                                                        ],
                                                        plt.IteNullList(
                                                            OVar(&#34;t&#34;),
                                                            OVar(&#34;end&#34;),
                                                            plt.AppendString(
                                                                plt.Text(&#34;, &#34;),
                                                                plt.Apply(
                                                                    OVar(&#34;f&#34;),
                                                                    OVar(&#34;f&#34;),
                                                                    OVar(&#34;t&#34;),
                                                                ),
                                                            ),
                                                        ),
                                                    ),
                                                ),
                                            )
                                        ),
                                    )
                                ],
                                plt.AppendString(
                                    OVar(&#34;start&#34;),
                                    plt.IteNullList(
                                        OVar(&#34;l&#34;),
                                        OVar(&#34;end&#34;),
                                        plt.Apply(
                                            OVar(&#34;g&#34;),
                                            OVar(&#34;l&#34;),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;stringifyPlutusData&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;d&#34;],
                                plt.DelayedChooseData(
                                    OVar(&#34;d&#34;),
                                    OLet(
                                        [
                                            (
                                                &#34;constructor&#34;,
                                                plt.FstPair(
                                                    plt.UnConstrData(OVar(&#34;d&#34;))
                                                ),
                                            )
                                        ],
                                        plt.Ite(
                                            plt.LessThanInteger(
                                                OVar(&#34;constructor&#34;),
                                                plt.Integer(128),
                                            ),
                                            plt.ConcatString(
                                                plt.Text(&#34;CBORTag(&#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.IData(
                                                        plt.AddInteger(
                                                            OVar(&#34;constructor&#34;),
                                                            plt.Ite(
                                                                plt.LessThanInteger(
                                                                    OVar(&#34;constructor&#34;),
                                                                    plt.Integer(7),
                                                                ),
                                                                plt.Integer(121),
                                                                plt.Integer(1280 - 7),
                                                            ),
                                                        )
                                                    ),
                                                ),
                                                plt.Text(&#34;, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.ListData(
                                                        plt.SndPair(
                                                            plt.UnConstrData(OVar(&#34;d&#34;))
                                                        )
                                                    ),
                                                ),
                                                plt.Text(&#34;)&#34;),
                                            ),
                                            plt.ConcatString(
                                                plt.Text(&#34;CBORTag(102, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.ListData(
                                                        plt.MkCons(
                                                            plt.IData(
                                                                OVar(&#34;constructor&#34;)
                                                            ),
                                                            plt.MkCons(
                                                                plt.ListData(
                                                                    plt.SndPair(
                                                                        plt.UnConstrData(
                                                                            OVar(&#34;d&#34;)
                                                                        )
                                                                    )
                                                                ),
                                                                plt.EmptyDataList(),
                                                            ),
                                                        )
                                                    ),
                                                ),
                                                plt.Text(&#34;)&#34;),
                                            ),
                                        ),
                                    ),
                                    plt.Apply(
                                        OVar(&#34;joinMapList&#34;),
                                        OLambda(
                                            [&#34;x&#34;],
                                            plt.ConcatString(
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.FstPair(OVar(&#34;x&#34;)),
                                                ),
                                                plt.Text(&#34;: &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.SndPair(OVar(&#34;x&#34;)),
                                                ),
                                            ),
                                        ),
                                        plt.UnMapData(OVar(&#34;d&#34;)),
                                        plt.Text(&#34;{&#34;),
                                        plt.Text(&#34;}&#34;),
                                    ),
                                    plt.Apply(
                                        OVar(&#34;joinMapList&#34;),
                                        OLambda(
                                            [&#34;x&#34;],
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;x&#34;),
                                            ),
                                        ),
                                        plt.UnListData(OVar(&#34;d&#34;)),
                                        plt.Text(&#34;[&#34;),
                                        plt.Text(&#34;]&#34;),
                                    ),
                                    plt.Apply(
                                        IntegerInstanceType.stringify(recursive=True),
                                        plt.UnIData(OVar(&#34;d&#34;)),
                                    ),
                                    plt.Apply(
                                        ByteStringInstanceType.stringify(
                                            recursive=True
                                        ),
                                        plt.UnBData(OVar(&#34;d&#34;)),
                                    ),
                                ),
                            )
                        ),
                    ),
                ],
                plt.ConcatString(
                    plt.Text(&#34;RawPlutusData(data=&#34;),
                    plt.Apply(OVar(&#34;stringifyPlutusData&#34;), OVar(&#34;self&#34;)),
                    plt.Text(&#34;)&#34;),
                ),
            ),
        )


@dataclass(frozen=True, unsafe_hash=True)
class AtomicType(ClassType):
    def __ge__(self, other):
        # Can only substitute for its own type (also subtypes)
        return isinstance(other, self.__class__)


@dataclass(frozen=True, unsafe_hash=True)
class RecordType(ClassType):
    record: Record

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return (
            &#34;cons[&#34;
            + self.record.orig_name
            + &#34;](&#34;
            + (str(self.record.constructor) if not skip_constructor else &#34;_&#34;)
            + &#34;;&#34;
            + &#34;,&#34;.join(name + &#34;:&#34; + type.id_map() for name, type in self.record.fields)
            + &#34;)&#34;
        )

    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(
            FunctionType(
                frozenlist([f[1] for f in self.record.fields]), InstanceType(self)
            )
        )

    def constr(self) -&gt; plt.AST:
        # wrap all constructor values to PlutusData
        build_constr_params = plt.EmptyDataList()
        for n, t in reversed(self.record.fields):
            build_constr_params = plt.MkCons(
                transform_output_map(t)(plt.Force(OVar(n))), build_constr_params
            )
        # then build a constr type with this PlutusData
        return SafeOLambda(
            [n for n, _ in self.record.fields],
            plt.ConstrData(plt.Integer(self.record.constructor), build_constr_params),
        )

    def attribute_type(self, attr: str) -&gt; Type:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        for n, t in self.record.fields:
            if n == attr:
                return t
        if attr == &#34;to_cbor&#34;:
            return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
        raise TypeInferenceError(
            f&#34;Type {self.record.name} does not have attribute {attr}&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return OLambda(
                [&#34;self&#34;],
                plt.Constructor(OVar(&#34;self&#34;)),
            )
        if attr in (n for n, t in self.record.fields):
            attr_typ = self.attribute_type(attr)
            pos = next(i for i, (n, _) in enumerate(self.record.fields) if n == attr)
            # access to normal fields
            return OLambda(
                [&#34;self&#34;],
                transform_ext_params_map(attr_typ)(
                    plt.ConstantNthField(
                        OVar(&#34;self&#34;),
                        pos,
                    ),
                ),
            )
        if attr == &#34;to_cbor&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.SerialiseData(
                    OVar(&#34;self&#34;),
                ),
            )
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        if (
            (
                isinstance(o, RecordType)
                and (self.record &gt;= o.record or o.record &gt;= self.record)
            )
            or (
                isinstance(o, UnionType) and any(self &gt;= o or self &gt;= o for o in o.typs)
            )
            or isinstance(o, AnyType)
        ):
            # Note that comparison with AnyType is actually fine because both are Data
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                            OVar(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and (o.typ.typ &gt;= self or self &gt;= o.typ.typ)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def __ge__(self, other):
        # Can only substitute for its own type, records need to be equal
        # if someone wants to be funny, they can implement &lt;= to be true if all fields match up to some point
        return isinstance(other, self.__class__) and self.record &gt;= other.record

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        &#34;&#34;&#34;Returns a stringified version of the object&#34;&#34;&#34;
        map_fields = plt.Text(&#34;)&#34;)
        if self.record.fields:
            # TODO access to fields is a bit inefficient but this is debugging stuff only anyways
            pos = len(self.record.fields) - 1
            for field_name, field_type in reversed(self.record.fields[1:]):
                map_fields = plt.ConcatString(
                    plt.Text(f&#34;, {field_name}=&#34;),
                    plt.Apply(
                        field_type.stringify(recursive=True),
                        transform_ext_params_map(field_type)(
                            plt.ConstantNthField(OVar(&#34;self&#34;), pos)
                        ),
                    ),
                    map_fields,
                )
                pos -= 1
            map_fields = plt.ConcatString(
                plt.Text(f&#34;{self.record.fields[0][0]}=&#34;),
                plt.Apply(
                    self.record.fields[0][1].stringify(recursive=True),
                    transform_ext_params_map(self.record.fields[0][1])(
                        plt.ConstantNthField(OVar(&#34;self&#34;), pos)
                    ),
                ),
                map_fields,
            )
        return OLambda(
            [&#34;self&#34;],
            plt.AppendString(plt.Text(f&#34;{self.record.orig_name}(&#34;), map_fields),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        copied_attributes = plt.EmptyDataList()
        for attr_name, attr_type in reversed(self.record.fields):
            copied_attributes = OLet(
                [
                    (&#34;f&#34;, plt.HeadList(OVar(&#34;fs&#34;))),
                    (&#34;fs&#34;, plt.TailList(OVar(&#34;fs&#34;))),
                ],
                plt.MkCons(
                    transform_output_map(attr_type)(
                        plt.Apply(
                            attr_type.copy_only_attributes(),
                            transform_ext_params_map(attr_type)(
                                OVar(&#34;f&#34;),
                            ),
                        )
                    ),
                    copied_attributes,
                ),
            )
        copied_attributes = OLet(
            [(&#34;fs&#34;, plt.Fields(OVar(&#34;self&#34;)))],
            copied_attributes,
        )
        return OLambda(
            [&#34;self&#34;],
            plt.ConstrData(
                plt.Integer(self.record.constructor),
                copied_attributes,
            ),
        )


@dataclass(frozen=True, unsafe_hash=True)
class UnionType(ClassType):
    typs: typing.List[RecordType]

    def __post_init__(self):
        object.__setattr__(self, &#34;typs&#34;, frozenlist(self.typs))

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;union&lt;&#34; + &#34;,&#34;.join(t.id_map() for t in self.typs) + &#34;&gt;&#34;

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        # need to have a common field with the same name
        if all(attr in (n for n, t in x.record.fields) for x in self.typs):
            attr_types = OrderedSet(
                t for x in self.typs for n, t in x.record.fields if n == attr
            )
            for at in attr_types:
                # return the maximum element if there is one
                if all(at &gt;= at2 for at2 in attr_types):
                    return at
            # return the union type of all possible instantiations if all possible values are record types
            if all(
                isinstance(at, InstanceType) and isinstance(at.typ, RecordType)
                for at in attr_types
            ) and distinct([at.typ.record.constructor for at in attr_types]):
                return InstanceType(
                    UnionType(frozenlist([at.typ for at in attr_types]))
                )
            # return Anytype
            return InstanceType(AnyType())
        if attr == &#34;to_cbor&#34;:
            return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
        raise TypeInferenceError(
            f&#34;Can not access attribute {attr} of Union type. Cast to desired type with an &#39;if isinstance(_, _):&#39; branch.&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return OLambda(
                [&#34;self&#34;],
                plt.Constructor(OVar(&#34;self&#34;)),
            )
        # iterate through all names/types of the unioned records by position
        if any(attr in (n for n, t in r.record.fields) for r in self.typs):
            attr_typ = self.attribute_type(attr)
            pos_constrs = [
                (i, x.record.constructor)
                for x in self.typs
                for i, (n, t) in enumerate(x.record.fields)
                if n == attr
            ]
            pos_constrs = sorted(pos_constrs, key=lambda x: x[0])
            pos_constrs = [
                (pos, [c[1] for c in constrs])
                for (pos, constrs) in itertools.groupby(pos_constrs, key=lambda x: x[0])
            ]
            # largest group last so we save the comparisons for that
            pos_constrs = sorted(pos_constrs, key=lambda x: len(x[1]))
            # access to normal fields
            if not pos_constrs:
                pos_decisor = plt.TraceError(&#34;Invalid constructor&#34;)
            else:
                pos_decisor = plt.Integer(pos_constrs[-1][0])
                pos_constrs = pos_constrs[:-1]
            for pos, constrs in pos_constrs:
                assert constrs, &#34;Found empty constructors for a position&#34;
                constr_check = plt.EqualsInteger(
                    OVar(&#34;constr&#34;), plt.Integer(constrs[0])
                )
                for constr in constrs[1:]:
                    constr_check = plt.Or(
                        plt.EqualsInteger(OVar(&#34;constr&#34;), plt.Integer(constr)),
                        constr_check,
                    )
                pos_decisor = plt.Ite(
                    constr_check,
                    plt.Integer(pos),
                    pos_decisor,
                )
            return OLambda(
                [&#34;self&#34;],
                transform_ext_params_map(attr_typ)(
                    plt.NthField(
                        OVar(&#34;self&#34;),
                        OLet(
                            [(&#34;constr&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
                            pos_decisor,
                        ),
                    ),
                ),
            )
        if attr == &#34;to_cbor&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.SerialiseData(
                    OVar(&#34;self&#34;),
                ),
            )
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def __ge__(self, other):
        if isinstance(other, UnionType):
            return all(self &gt;= ot for ot in other.typs)
        return any(t &gt;= other for t in self.typs)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        # note we require that there is an overlapt between the possible types for unions
        if (isinstance(o, RecordType) and any(t &gt;= o or o &gt;= t for t in self.typs)) or (
            isinstance(o, UnionType)
            and any(t &gt;= ot or t &gt;= ot for t in self.typs for ot in o.typs)
        ):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                            OVar(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and any(o.typ.typ &gt;= t or t &gt;= o.typ.typ for t in self.typs)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        raise NotImplementedError(
            f&#34;Can not compare {o} and {self} with operation {op.__class__}. Note that comparisons that always return false are also rejected.&#34;
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        decide_string_func = plt.TraceError(&#34;Invalid constructor id in Union&#34;)
        for t in self.typs:
            decide_string_func = plt.Ite(
                plt.EqualsInteger(OVar(&#34;c&#34;), plt.Integer(t.record.constructor)),
                t.stringify(recursive=True),
                decide_string_func,
            )
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [(&#34;c&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
                plt.Apply(decide_string_func, OVar(&#34;self&#34;)),
            ),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        copied_attributes = plt.TraceError(
            f&#34;Invalid CONSTR_ID for instance of Union[{&#39;, &#39;.join(type(typ).__name__ for typ in self.typs)}]&#34;
        )
        for typ in self.typs:
            copied_attributes = plt.Ite(
                plt.EqualsInteger(OVar(&#34;constr&#34;), plt.Integer(typ.record.constructor)),
                plt.Apply(typ.copy_only_attributes(), OVar(&#34;self&#34;)),
                copied_attributes,
            )
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [(&#34;constr&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
                copied_attributes,
            ),
        )


@dataclass(frozen=True, unsafe_hash=True)
class TupleType(ClassType):
    typs: typing.List[Type]

    def __ge__(self, other):
        return isinstance(other, TupleType) and all(
            t &gt;= ot for t, ot in zip(self.typs, other.typs)
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        if not self.typs:
            return OLambda(
                [&#34;self&#34;],
                plt.Text(&#34;()&#34;),
            )
        elif len(self.typs) == 1:
            tuple_content = plt.ConcatString(
                plt.Apply(
                    self.typs[0].stringify(recursive=True),
                    plt.FunctionalTupleAccess(OVar(&#34;self&#34;), 0, len(self.typs)),
                ),
                plt.Text(&#34;,&#34;),
            )
        else:
            tuple_content = plt.ConcatString(
                plt.Apply(
                    self.typs[0].stringify(recursive=True),
                    plt.FunctionalTupleAccess(OVar(&#34;self&#34;), 0, len(self.typs)),
                ),
            )
            for i, t in enumerate(self.typs[1:], start=1):
                tuple_content = plt.ConcatString(
                    tuple_content,
                    plt.Text(&#34;, &#34;),
                    plt.Apply(
                        t.stringify(recursive=True),
                        plt.FunctionalTupleAccess(OVar(&#34;self&#34;), i, len(self.typs)),
                    ),
                )
        return OLambda(
            [&#34;self&#34;],
            plt.ConcatString(plt.Text(&#34;(&#34;), tuple_content, plt.Text(&#34;)&#34;)),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if isinstance(other, TupleType):
                return TupleType(self.typs + other.typs)
        return super()._binop_return_type(binop, other)


@dataclass(frozen=True, unsafe_hash=True)
class PairType(ClassType):
    &#34;&#34;&#34;An internal type representing built-in PlutusData pairs&#34;&#34;&#34;

    l_typ: Type
    r_typ: Type

    def __ge__(self, other):
        return isinstance(other, PairType) and all(
            t &gt;= ot
            for t, ot in zip((self.l_typ, self.r_typ), (other.l_typ, other.r_typ))
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        tuple_content = plt.ConcatString(
            plt.Apply(
                self.l_typ.stringify(recursive=True),
                transform_ext_params_map(self.l_typ)(plt.FstPair(OVar(&#34;self&#34;))),
            ),
            plt.Text(&#34;, &#34;),
            plt.Apply(
                self.r_typ.stringify(recursive=True),
                transform_ext_params_map(self.r_typ)(plt.SndPair(OVar(&#34;self&#34;))),
            ),
        )
        return OLambda(
            [&#34;self&#34;],
            plt.ConcatString(plt.Text(&#34;(&#34;), tuple_content, plt.Text(&#34;)&#34;)),
        )


@dataclass(frozen=True, unsafe_hash=True)
class ListType(ClassType):
    typ: Type

    def __ge__(self, other):
        return isinstance(other, ListType) and self.typ &gt;= other.typ

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;list&lt;&#34; + self.typ.id_map() + &#34;&gt;&#34;

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;index&#34;:
            return InstanceType(
                FunctionType(frozenlist([self.typ]), IntegerInstanceType)
            )
        super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;index&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;x&#34;],
                OLet(
                    [(&#34;x&#34;, plt.Force(OVar(&#34;x&#34;)))],
                    plt.Apply(
                        plt.RecFun(
                            OLambda(
                                [&#34;index&#34;, &#34;xs&#34;, &#34;a&#34;],
                                plt.IteNullList(
                                    OVar(&#34;xs&#34;),
                                    plt.TraceError(&#34;Did not find element in list&#34;),
                                    plt.Ite(
                                        plt.EqualsInteger(
                                            OVar(&#34;x&#34;), plt.HeadList(OVar(&#34;xs&#34;))
                                        ),
                                        OVar(&#34;a&#34;),
                                        plt.Apply(
                                            OVar(&#34;index&#34;),
                                            OVar(&#34;index&#34;),
                                            plt.TailList(OVar(&#34;xs&#34;)),
                                            plt.AddInteger(OVar(&#34;a&#34;), plt.Integer(1)),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        OVar(&#34;self&#34;),
                        plt.Integer(0),
                    ),
                ),
            )
        super().attribute(attr)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [
                    (
                        &#34;g&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;l&#34;],
                                plt.AppendString(
                                    plt.Apply(
                                        self.typ.stringify(recursive=True),
                                        plt.HeadList(OVar(&#34;l&#34;)),
                                    ),
                                    OLet(
                                        [(&#34;t&#34;, plt.TailList(OVar(&#34;l&#34;)))],
                                        plt.IteNullList(
                                            OVar(&#34;t&#34;),
                                            plt.Text(&#34;]&#34;),
                                            plt.AppendString(
                                                plt.Text(&#34;, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;t&#34;),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            )
                        ),
                    )
                ],
                plt.AppendString(
                    plt.Text(&#34;[&#34;),
                    plt.IteNullList(
                        OVar(&#34;self&#34;),
                        plt.Text(&#34;]&#34;),
                        plt.Apply(
                            OVar(&#34;g&#34;),
                            OVar(&#34;self&#34;),
                        ),
                    ),
                ),
            ),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        mapped_attrs = plt.MapList(
            OVar(&#34;self&#34;),
            OLambda(
                [&#34;v&#34;],
                transform_output_map(self.typ)(
                    plt.Apply(
                        self.typ.copy_only_attributes(),
                        transform_ext_params_map(self.typ)(OVar(&#34;v&#34;)),
                    )
                ),
            ),
            plt.EmptyDataList(),
        )
        return OLambda([&#34;self&#34;], mapped_attrs)

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if isinstance(other, InstanceType) and isinstance(other.typ, ListType):
                other_typ = other.typ
                assert (
                    self.typ &gt;= other_typ.typ or other_typ.typ &gt;= self.typ
                ), f&#34;Types of lists {self.typ} and {other_typ.typ} are not compatible&#34;
                return ListType(
                    self.typ if self.typ &gt;= other_typ.typ else other_typ.typ
                )
        return super()._binop_return_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if isinstance(binop, Add):
            if isinstance(other.typ, InstanceType) and isinstance(
                other.typ.typ, ListType
            ):
                return plt.AppendList

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.IteNullList(x, plt.Bool(True), plt.Bool(False))
        return super()._unop_fun(unop)


@dataclass(frozen=True, unsafe_hash=True)
class DictType(ClassType):
    key_typ: Type
    value_typ: Type

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;map&lt;&#34; + self.key_typ.id_map() + &#34;,&#34; + self.value_typ.id_map() + &#34;&gt;&#34;

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;get&#34;:
            return InstanceType(
                FunctionType(frozenlist([self.key_typ, self.value_typ]), self.value_typ)
            )
        if attr == &#34;keys&#34;:
            return InstanceType(
                FunctionType(frozenlist([]), InstanceType(ListType(self.key_typ)))
            )
        if attr == &#34;values&#34;:
            return InstanceType(
                FunctionType(frozenlist([]), InstanceType(ListType(self.value_typ)))
            )
        if attr == &#34;items&#34;:
            return InstanceType(
                FunctionType(
                    frozenlist([]),
                    InstanceType(
                        ListType(InstanceType(PairType(self.key_typ, self.value_typ)))
                    ),
                )
            )
        raise TypeInferenceError(
            f&#34;Type of attribute &#39;{attr}&#39; is unknown for type Dict.&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;get&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;key&#34;, &#34;default&#34;],
                transform_ext_params_map(self.value_typ)(
                    OLet(
                        [
                            (
                                &#34;key_mapped&#34;,
                                transform_output_map(self.key_typ)(
                                    plt.Force(OVar(&#34;key&#34;))
                                ),
                            )
                        ],
                        plt.SndPair(
                            plt.FindList(
                                OVar(&#34;self&#34;),
                                OLambda(
                                    [&#34;x&#34;],
                                    plt.EqualsData(
                                        OVar(&#34;key_mapped&#34;),
                                        plt.FstPair(OVar(&#34;x&#34;)),
                                    ),
                                ),
                                # this is a bit ugly... we wrap - only to later unwrap again
                                plt.MkPairData(
                                    OVar(&#34;key_mapped&#34;),
                                    transform_output_map(self.value_typ)(
                                        plt.Force(OVar(&#34;default&#34;))
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            )
        if attr == &#34;keys&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    OVar(&#34;self&#34;),
                    OLambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.key_typ)(plt.FstPair(OVar(&#34;x&#34;))),
                    ),
                    empty_list(self.key_typ),
                ),
            )
        if attr == &#34;values&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    OVar(&#34;self&#34;),
                    OLambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.value_typ)(
                            plt.SndPair(OVar(&#34;x&#34;))
                        ),
                    ),
                    empty_list(self.value_typ),
                ),
            )
        if attr == &#34;items&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                OVar(&#34;self&#34;),
            )
        raise NotImplementedError(f&#34;Attribute &#39;{attr}&#39; of Dict is unknown.&#34;)

    def __ge__(self, other):
        return (
            isinstance(other, DictType)
            and self.key_typ &gt;= other.key_typ
            and self.value_typ &gt;= other.value_typ
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [
                    (
                        &#34;g&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;l&#34;],
                                OLet(
                                    [
                                        (&#34;h&#34;, plt.HeadList(OVar(&#34;l&#34;))),
                                        (&#34;t&#34;, plt.TailList(OVar(&#34;l&#34;))),
                                    ],
                                    plt.ConcatString(
                                        plt.Apply(
                                            self.key_typ.stringify(recursive=True),
                                            transform_ext_params_map(self.key_typ)(
                                                plt.FstPair(OVar(&#34;h&#34;))
                                            ),
                                        ),
                                        plt.Text(&#34;: &#34;),
                                        plt.Apply(
                                            self.value_typ.stringify(recursive=True),
                                            transform_ext_params_map(self.value_typ)(
                                                plt.SndPair(OVar(&#34;h&#34;))
                                            ),
                                        ),
                                        plt.IteNullList(
                                            OVar(&#34;t&#34;),
                                            plt.Text(&#34;}&#34;),
                                            plt.AppendString(
                                                plt.Text(&#34;, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;t&#34;),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            )
                        ),
                    )
                ],
                plt.AppendString(
                    plt.Text(&#34;{&#34;),
                    plt.IteNullList(
                        OVar(&#34;self&#34;),
                        plt.Text(&#34;}&#34;),
                        plt.Apply(
                            OVar(&#34;g&#34;),
                            OVar(&#34;self&#34;),
                        ),
                    ),
                ),
            ),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        def CustomMapFilterList(
            l: plt.AST,
            filter_op: plt.AST,
            map_op: plt.AST,
            empty_list=plt.EmptyDataList(),
        ):
            from pluthon import (
                Apply,
                Lambda as PLambda,
                RecFun,
                IteNullList,
                Var as PVar,
                HeadList,
                Ite,
                TailList,
                PrependList,
                Let as PLet,
            )

            &#34;&#34;&#34;
            Apply a filter and a map function on each element in a list (throws out all that evaluate to false)
            Performs only a single pass and is hence much more efficient than filter + map
            &#34;&#34;&#34;
            return Apply(
                PLambda(
                    [&#34;filter&#34;, &#34;map&#34;],
                    RecFun(
                        PLambda(
                            [&#34;filtermap&#34;, &#34;xs&#34;],
                            IteNullList(
                                PVar(&#34;xs&#34;),
                                empty_list,
                                PLet(
                                    [
                                        (&#34;head&#34;, HeadList(PVar(&#34;xs&#34;))),
                                        (&#34;tail&#34;, TailList(PVar(&#34;xs&#34;))),
                                    ],
                                    Ite(
                                        Apply(
                                            PVar(&#34;filter&#34;), PVar(&#34;head&#34;), PVar(&#34;tail&#34;)
                                        ),
                                        PrependList(
                                            Apply(PVar(&#34;map&#34;), PVar(&#34;head&#34;)),
                                            Apply(
                                                PVar(&#34;filtermap&#34;),
                                                PVar(&#34;filtermap&#34;),
                                                PVar(&#34;tail&#34;),
                                            ),
                                        ),
                                        Apply(
                                            PVar(&#34;filtermap&#34;),
                                            PVar(&#34;filtermap&#34;),
                                            PVar(&#34;tail&#34;),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
                filter_op,
                map_op,
                l,
            )

        mapped_attrs = CustomMapFilterList(
            OVar(&#34;self&#34;),
            OLambda(
                [&#34;h&#34;, &#34;t&#34;],
                OLet(
                    [
                        (&#34;hfst&#34;, plt.FstPair(OVar(&#34;h&#34;))),
                    ],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;t&#34;),
                            OLambda(
                                [&#34;e&#34;],
                                plt.EqualsData(OVar(&#34;hfst&#34;), plt.FstPair(OVar(&#34;e&#34;))),
                            ),
                        )
                    ),
                ),
            ),
            OLambda(
                [&#34;v&#34;],
                plt.MkPairData(
                    transform_output_map(self.key_typ)(
                        plt.Apply(
                            self.key_typ.copy_only_attributes(),
                            transform_ext_params_map(self.key_typ)(
                                plt.FstPair(OVar(&#34;v&#34;))
                            ),
                        )
                    ),
                    transform_output_map(self.value_typ)(
                        plt.Apply(
                            self.value_typ.copy_only_attributes(),
                            transform_ext_params_map(self.value_typ)(
                                plt.SndPair(OVar(&#34;v&#34;))
                            ),
                        )
                    ),
                ),
            ),
            plt.EmptyDataPairList(),
        )
        return OLambda([&#34;self&#34;], mapped_attrs)

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.IteNullList(x, plt.Bool(True), plt.Bool(False))
        return super()._unop_fun(unop)


@dataclass(frozen=True, unsafe_hash=True)
class FunctionType(ClassType):
    argtyps: typing.List[Type]
    rettyp: Type
    # A map from external variable names to their types when the function is defined
    bound_vars: typing.Dict[str, Type] = dataclasses.field(default_factory=frozendict)
    # Whether and under which name the function binds itself
    # The type of this variable is &#34;self&#34;
    bind_self: typing.Optional[str] = None

    def __post_init__(self):
        object.__setattr__(self, &#34;argtyps&#34;, frozenlist(self.argtyps))
        object.__setattr__(self, &#34;bound_vars&#34;, frozendict(self.bound_vars))

    def __ge__(self, other):
        return (
            isinstance(other, FunctionType)
            and len(self.argtyps) == len(other.argtyps)
            and all(a &gt;= oa for a, oa in zip(self.argtyps, other.argtyps))
            and self.bound_vars.keys() == other.bound_vars.keys()
            and all(sbv &gt;= other.bound_vars[k] for k, sbv in self.bound_vars.items())
            and self.bind_self == other.bind_self
            and other.rettyp &gt;= self.rettyp
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda([&#34;x&#34;], plt.Text(&#34;&lt;function&gt;&#34;))


@dataclass(frozen=True, unsafe_hash=True)
class InstanceType(Type):
    typ: ClassType

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return self.typ.id_map(skip_constructor=skip_constructor)

    def constr_type(self) -&gt; FunctionType:
        raise TypeInferenceError(f&#34;Can not construct an instance {self}&#34;)

    def constr(self) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not construct an instance {self}&#34;)

    def attribute_type(self, attr) -&gt; Type:
        return self.typ.attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        return self.typ.attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, InstanceType):
            return self.typ.cmp(op, o.typ)
        return super().cmp(op, o)

    def __ge__(self, other):
        return isinstance(other, InstanceType) and self.typ &gt;= other.typ

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return self.typ.stringify(recursive=recursive)

    def copy_only_attributes(self) -&gt; plt.AST:
        return self.typ.copy_only_attributes()

    def binop_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        return self.typ.binop_type(binop, other)

    def binop(self, binop: operator, other: AST) -&gt; plt.AST:
        return self.typ.binop(binop, other)

    def unop_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        return self.typ.unop_type(unop)

    def unop(self, unop: unaryop) -&gt; plt.AST:
        return self.typ.unop(unop)


@dataclass(frozen=True, unsafe_hash=True)
class IntegerType(AtomicType):
    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;int&#34;

    def constr_type(self) -&gt; InstanceType:
        return InstanceType(PolymorphicFunctionType(IntImpl()))

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Ite(
                        OVar(&#34;y&#34;),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsInteger)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger),
                            OVar(&#34;y&#34;),
                            OVar(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger)
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanInteger)
            if isinstance(op, Gt):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanInteger),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, IntegerType)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), OVar(&#34;x&#34;)
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), OVar(&#34;x&#34;)
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;x&#34;],
            plt.DecodeUtf8(
                OLet(
                    [
                        (
                            &#34;strlist&#34;,
                            plt.RecFun(
                                OLambda(
                                    [&#34;f&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        plt.LessThanEqualsInteger(
                                            OVar(&#34;i&#34;), plt.Integer(0)
                                        ),
                                        plt.EmptyIntegerList(),
                                        plt.MkCons(
                                            plt.AddInteger(
                                                plt.ModInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(10)
                                                ),
                                                plt.Integer(ord(&#34;0&#34;)),
                                            ),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.DivideInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(10)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;mkstr&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.FoldList(
                                    plt.Apply(OVar(&#34;strlist&#34;), OVar(&#34;i&#34;)),
                                    OLambda(
                                        [&#34;b&#34;, &#34;i&#34;],
                                        plt.ConsByteString(OVar(&#34;i&#34;), OVar(&#34;b&#34;)),
                                    ),
                                    plt.ByteString(b&#34;&#34;),
                                ),
                            ),
                        ),
                    ],
                    plt.Ite(
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                        plt.ByteString(b&#34;0&#34;),
                        plt.Ite(
                            plt.LessThanInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                            plt.ConsByteString(
                                plt.Integer(ord(&#34;-&#34;)),
                                plt.Apply(OVar(&#34;mkstr&#34;), plt.Negate(OVar(&#34;x&#34;))),
                            ),
                            plt.Apply(OVar(&#34;mkstr&#34;), OVar(&#34;x&#34;)),
                        ),
                    ),
                )
            ),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if (
            isinstance(binop, Add)
            or isinstance(binop, Sub)
            or isinstance(binop, FloorDiv)
            or isinstance(binop, Mod)
            or isinstance(binop, Div)
            or isinstance(binop, Pow)
        ):
            if other == IntegerInstanceType:
                return IntegerType()
        if isinstance(binop, Mult):
            if other == IntegerInstanceType:
                return IntegerType()
            elif other == ByteStringInstanceType:
                return ByteStringType()
            elif other == StringInstanceType:
                return StringType()
        return super().binop_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if other.typ == IntegerInstanceType:
            if isinstance(binop, Add):
                return plt.AddInteger
            elif isinstance(binop, Sub):
                return plt.SubtractInteger
            elif isinstance(binop, FloorDiv):
                return plt.DivideInteger
            elif isinstance(binop, Mod):
                return plt.ModInteger
            elif isinstance(binop, Pow):
                return lambda x, y: OLet(
                    [(&#34;y&#34;, y)],
                    plt.Ite(
                        plt.LessThanInteger(OVar(&#34;y&#34;), plt.Integer(0)),
                        plt.TraceError(&#34;Negative exponentiation is not supported&#34;),
                        PowImpl(x, OVar(&#34;y&#34;)),
                    ),
                )

        if isinstance(binop, Mult):
            if other.typ == IntegerInstanceType:
                return plt.MultiplyInteger
            elif other.typ == ByteStringInstanceType:
                return lambda x, y: ByteStrIntMulImpl(y, x)
            elif other.typ == StringInstanceType:
                return lambda x, y: StrIntMulImpl(y, x)

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, USub):
            return IntegerType()
        elif isinstance(unop, UAdd):
            return IntegerType()
        elif isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, USub):
            return lambda x: plt.SubtractInteger(plt.Integer(0), x)
        if isinstance(unop, UAdd):
            return lambda x: x
        if isinstance(unop, Not):
            return lambda x: plt.EqualsInteger(x, plt.Integer(0))
        return super()._unop_fun(unop)


@dataclass(frozen=True, unsafe_hash=True)
class StringType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(PolymorphicFunctionType(StrImpl()))

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;encode&#34;:
            return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;encode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return OLambda([&#34;x&#34;, &#34;_&#34;], plt.EncodeUtf8(OVar(&#34;x&#34;)))
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, StringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsString)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;], plt.Not(plt.EqualsString(OVar(&#34;x&#34;), OVar(&#34;y&#34;)))
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        if recursive:
            # TODO this is not correct, as the string is not properly escaped
            return OLambda(
                [&#34;self&#34;],
                plt.ConcatString(plt.Text(&#34;&#39;&#34;), OVar(&#34;self&#34;), plt.Text(&#34;&#39;&#34;)),
            )
        else:
            return OLambda([&#34;self&#34;], OVar(&#34;self&#34;))

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if other == StringInstanceType:
                return StringType()
        if isinstance(binop, Mult):
            if other == IntegerInstanceType:
                return StringType()
        return super().binop_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if isinstance(binop, Add):
            if other.typ == StringInstanceType:
                return plt.AppendString
        if isinstance(binop, Mult):
            if other.typ == IntegerInstanceType:
                return StrIntMulImpl

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.EqualsInteger(
                plt.LengthOfByteString(plt.EncodeUtf8(x)), plt.Integer(0)
            )
        return super()._unop_fun(unop)


@dataclass(frozen=True, unsafe_hash=True)
class ByteStringType(AtomicType):
    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;bytes&#34;

    def constr_type(self) -&gt; InstanceType:
        return InstanceType(PolymorphicFunctionType(BytesImpl()))

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;decode&#34;:
            return InstanceType(FunctionType(frozenlist([]), StringInstanceType))
        if attr == &#34;hex&#34;:
            return InstanceType(FunctionType(frozenlist([]), StringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;decode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return OLambda([&#34;x&#34;, &#34;_&#34;], plt.DecodeUtf8(OVar(&#34;x&#34;)))
        if attr == &#34;hex&#34;:
            return OLambda(
                [&#34;x&#34;, &#34;_&#34;],
                plt.DecodeUtf8(
                    OLet(
                        [
                            (
                                &#34;hexlist&#34;,
                                plt.RecFun(
                                    OLambda(
                                        [&#34;f&#34;, &#34;i&#34;],
                                        plt.Ite(
                                            plt.LessThanInteger(
                                                OVar(&#34;i&#34;), plt.Integer(0)
                                            ),
                                            plt.EmptyIntegerList(),
                                            plt.MkCons(
                                                plt.IndexByteString(
                                                    OVar(&#34;x&#34;), OVar(&#34;i&#34;)
                                                ),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.SubtractInteger(
                                                        OVar(&#34;i&#34;), plt.Integer(1)
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                            (
                                &#34;map_str&#34;,
                                OLambda(
                                    [&#34;i&#34;],
                                    plt.AddInteger(
                                        OVar(&#34;i&#34;),
                                        plt.IfThenElse(
                                            plt.LessThanInteger(
                                                OVar(&#34;i&#34;), plt.Integer(10)
                                            ),
                                            plt.Integer(ord(&#34;0&#34;)),
                                            plt.Integer(ord(&#34;a&#34;) - 10),
                                        ),
                                    ),
                                ),
                            ),
                            (
                                &#34;mkstr&#34;,
                                OLambda(
                                    [&#34;i&#34;],
                                    plt.FoldList(
                                        plt.Apply(OVar(&#34;hexlist&#34;), OVar(&#34;i&#34;)),
                                        OLambda(
                                            [&#34;b&#34;, &#34;i&#34;],
                                            plt.ConsByteString(
                                                plt.Apply(
                                                    OVar(&#34;map_str&#34;),
                                                    plt.DivideInteger(
                                                        OVar(&#34;i&#34;), plt.Integer(16)
                                                    ),
                                                ),
                                                plt.ConsByteString(
                                                    plt.Apply(
                                                        OVar(&#34;map_str&#34;),
                                                        plt.ModInteger(
                                                            OVar(&#34;i&#34;),
                                                            plt.Integer(16),
                                                        ),
                                                    ),
                                                    OVar(&#34;b&#34;),
                                                ),
                                            ),
                                        ),
                                        plt.ByteString(b&#34;&#34;),
                                    ),
                                ),
                            ),
                        ],
                        plt.Apply(
                            OVar(&#34;mkstr&#34;),
                            plt.SubtractInteger(
                                plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(1)
                            ),
                        ),
                    ),
                ),
            )
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, ByteStringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsByteString)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            OVar(&#34;y&#34;),
                            OVar(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanByteString)
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString)
            if isinstance(op, Gt):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanByteString),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, ByteStringType)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;x&#34;],
            plt.DecodeUtf8(
                OLet(
                    [
                        (
                            &#34;hexlist&#34;,
                            plt.RecFun(
                                OLambda(
                                    [&#34;f&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        plt.LessThanInteger(OVar(&#34;i&#34;), plt.Integer(0)),
                                        plt.EmptyIntegerList(),
                                        plt.MkCons(
                                            plt.IndexByteString(OVar(&#34;x&#34;), OVar(&#34;i&#34;)),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.SubtractInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(1)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;map_str&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.AddInteger(
                                    OVar(&#34;i&#34;),
                                    plt.IfThenElse(
                                        plt.LessThanInteger(OVar(&#34;i&#34;), plt.Integer(10)),
                                        plt.Integer(ord(&#34;0&#34;)),
                                        plt.Integer(ord(&#34;a&#34;) - 10),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;mkstr&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.FoldList(
                                    plt.Apply(OVar(&#34;hexlist&#34;), OVar(&#34;i&#34;)),
                                    OLambda(
                                        [&#34;b&#34;, &#34;i&#34;],
                                        plt.Ite(
                                            # ascii printable characters are kept unmodified
                                            plt.And(
                                                plt.LessThanEqualsInteger(
                                                    plt.Integer(0x20), OVar(&#34;i&#34;)
                                                ),
                                                plt.LessThanEqualsInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(0x7E)
                                                ),
                                            ),
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;i&#34;),
                                                    plt.Integer(ord(&#34;\\&#34;)),
                                                ),
                                                plt.AppendByteString(
                                                    plt.ByteString(b&#34;\\\\&#34;),
                                                    OVar(&#34;b&#34;),
                                                ),
                                                plt.Ite(
                                                    plt.EqualsInteger(
                                                        OVar(&#34;i&#34;),
                                                        plt.Integer(ord(&#34;&#39;&#34;)),
                                                    ),
                                                    plt.AppendByteString(
                                                        plt.ByteString(b&#34;\\&#39;&#34;),
                                                        OVar(&#34;b&#34;),
                                                    ),
                                                    plt.ConsByteString(
                                                        OVar(&#34;i&#34;), OVar(&#34;b&#34;)
                                                    ),
                                                ),
                                            ),
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(ord(&#34;\t&#34;))
                                                ),
                                                plt.AppendByteString(
                                                    plt.ByteString(b&#34;\\t&#34;), OVar(&#34;b&#34;)
                                                ),
                                                plt.Ite(
                                                    plt.EqualsInteger(
                                                        OVar(&#34;i&#34;),
                                                        plt.Integer(ord(&#34;\n&#34;)),
                                                    ),
                                                    plt.AppendByteString(
                                                        plt.ByteString(b&#34;\\n&#34;),
                                                        OVar(&#34;b&#34;),
                                                    ),
                                                    plt.Ite(
                                                        plt.EqualsInteger(
                                                            OVar(&#34;i&#34;),
                                                            plt.Integer(ord(&#34;\r&#34;)),
                                                        ),
                                                        plt.AppendByteString(
                                                            plt.ByteString(b&#34;\\r&#34;),
                                                            OVar(&#34;b&#34;),
                                                        ),
                                                        plt.AppendByteString(
                                                            plt.ByteString(b&#34;\\x&#34;),
                                                            plt.ConsByteString(
                                                                plt.Apply(
                                                                    OVar(&#34;map_str&#34;),
                                                                    plt.DivideInteger(
                                                                        OVar(&#34;i&#34;),
                                                                        plt.Integer(16),
                                                                    ),
                                                                ),
                                                                plt.ConsByteString(
                                                                    plt.Apply(
                                                                        OVar(&#34;map_str&#34;),
                                                                        plt.ModInteger(
                                                                            OVar(&#34;i&#34;),
                                                                            plt.Integer(
                                                                                16
                                                                            ),
                                                                        ),
                                                                    ),
                                                                    OVar(&#34;b&#34;),
                                                                ),
                                                            ),
                                                        ),
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                    plt.ByteString(b&#34;&#34;),
                                ),
                            ),
                        ),
                    ],
                    plt.ConcatByteString(
                        plt.ByteString(b&#34;b&#39;&#34;),
                        plt.Apply(
                            OVar(&#34;mkstr&#34;),
                            plt.SubtractInteger(
                                plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(1)
                            ),
                        ),
                        plt.ByteString(b&#34;&#39;&#34;),
                    ),
                ),
            ),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if other == ByteStringInstanceType:
                return ByteStringType()
        if isinstance(binop, Mult):
            if other == IntegerInstanceType:
                return ByteStringType()
        return super().binop_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if isinstance(binop, Add):
            if other.typ == ByteStringInstanceType:
                return plt.AppendByteString
        if isinstance(binop, Mult):
            if other.typ == IntegerInstanceType:
                return ByteStrIntMulImpl

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.EqualsInteger(
                plt.LengthOfByteString(x), plt.Integer(0)
            )
        return super()._unop_fun(unop)


@dataclass(frozen=True, unsafe_hash=True)
class BoolType(AtomicType):
    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(PolymorphicFunctionType(BoolImpl()))

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return OLambda(
                    [&#34;y&#34;, &#34;x&#34;],
                    plt.Ite(
                        OVar(&#34;y&#34;),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;y&#34;, &#34;x&#34;],
                    plt.Ite(
                        OVar(&#34;y&#34;),
                        plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                        plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Iff(OVar(&#34;x&#34;), OVar(&#34;y&#34;)))
            if isinstance(op, NotEq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Not(plt.Iff(OVar(&#34;x&#34;), OVar(&#34;y&#34;))))
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;self&#34;],
            plt.Ite(
                OVar(&#34;self&#34;),
                plt.Text(&#34;True&#34;),
                plt.Text(&#34;False&#34;),
            ),
        )

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return plt.Not
        return super()._unop_fun(unop)


@dataclass(frozen=True, unsafe_hash=True)
class UnitType(AtomicType):
    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, UnitType):
            if isinstance(op, Eq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(True))
            if isinstance(op, NotEq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(False))
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda([&#34;self&#34;], plt.Text(&#34;None&#34;))

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.Bool(True)
        return super()._unop_fun(unop)


IntegerInstanceType = InstanceType(IntegerType())
StringInstanceType = InstanceType(StringType())
ByteStringInstanceType = InstanceType(ByteStringType())
BoolInstanceType = InstanceType(BoolType())
UnitInstanceType = InstanceType(UnitType())

ATOMIC_TYPES = {
    int.__name__: IntegerType(),
    str.__name__: StringType(),
    bytes.__name__: ByteStringType(),
    bytearray.__name__: ByteStringType(),
    type(None).__name__: UnitType(),
    bool.__name__: BoolType(),
}


NoneInstanceType = UnitInstanceType


class InaccessibleType(ClassType):
    &#34;&#34;&#34;A type that blocks overwriting of a function&#34;&#34;&#34;

    pass


def repeated_addition(zero, add):
    # this is optimized for logarithmic complexity by exponentiation by squaring
    # it follows the implementation described here: https://en.wikipedia.org/wiki/Exponentiation_by_squaring#With_constant_auxiliary_memory
    def RepeatedAdd(x: plt.AST, y: plt.AST):
        return plt.Apply(
            plt.RecFun(
                OLambda(
                    [&#34;f&#34;, &#34;y&#34;, &#34;x&#34;, &#34;n&#34;],
                    plt.Ite(
                        plt.LessThanEqualsInteger(OVar(&#34;n&#34;), plt.Integer(0)),
                        OVar(&#34;y&#34;),
                        OLet(
                            [
                                (
                                    &#34;n_half&#34;,
                                    plt.DivideInteger(OVar(&#34;n&#34;), plt.Integer(2)),
                                )
                            ],
                            plt.Ite(
                                # tests whether (x//2)*2 == x which is True iff x is even
                                plt.EqualsInteger(
                                    plt.AddInteger(OVar(&#34;n_half&#34;), OVar(&#34;n_half&#34;)),
                                    OVar(&#34;n&#34;),
                                ),
                                plt.Apply(
                                    OVar(&#34;f&#34;),
                                    OVar(&#34;f&#34;),
                                    OVar(&#34;y&#34;),
                                    add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                    OVar(&#34;n_half&#34;),
                                ),
                                plt.Apply(
                                    OVar(&#34;f&#34;),
                                    OVar(&#34;f&#34;),
                                    add(OVar(&#34;y&#34;), OVar(&#34;x&#34;)),
                                    add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                    OVar(&#34;n_half&#34;),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
            zero,
            x,
            y,
        )

    return RepeatedAdd


PowImpl = repeated_addition(plt.Integer(1), plt.MultiplyInteger)
ByteStrIntMulImpl = repeated_addition(plt.ByteString(b&#34;&#34;), plt.AppendByteString)
StrIntMulImpl = repeated_addition(plt.Text(&#34;&#34;), plt.AppendString)


class PolymorphicFunction:
    def __new__(meta, *args, **kwargs):
        klass = super().__new__(meta)

        for key in [&#34;impl_from_args&#34;]:
            value = getattr(klass, key)
            wrapped = patternize(value)
            object.__setattr__(klass, key, wrapped)

        return klass

    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        raise NotImplementedError()

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        raise NotImplementedError()


class StrImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;str&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only stringify instances&#34;
        return FunctionType(args, StringInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only stringify instances&#34;
        return arg.typ.stringify()


class IntImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;int&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only create ints from instances&#34;
        assert any(
            isinstance(typ.typ, t) for t in (IntegerType, StringType, BoolType)
        ), &#34;Can only create integers from int, str or bool&#34;
        return FunctionType(args, IntegerInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only create ints from instances&#34;
        if isinstance(arg.typ, IntegerType):
            return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
        elif isinstance(arg.typ, BoolType):
            return OLambda(
                [&#34;x&#34;], plt.IfThenElse(OVar(&#34;x&#34;), plt.Integer(1), plt.Integer(0))
            )
        elif isinstance(arg.typ, StringType):
            return OLambda(
                [&#34;x&#34;],
                OLet(
                    [
                        (&#34;e&#34;, plt.EncodeUtf8(OVar(&#34;x&#34;))),
                        (&#34;len&#34;, plt.LengthOfByteString(OVar(&#34;e&#34;))),
                        (
                            &#34;first_int&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Integer(0), OVar(&#34;len&#34;)),
                                plt.IndexByteString(OVar(&#34;e&#34;), plt.Integer(0)),
                                plt.Integer(ord(&#34;_&#34;)),
                            ),
                        ),
                        (
                            &#34;last_int&#34;,
                            plt.IndexByteString(
                                OVar(&#34;e&#34;),
                                plt.SubtractInteger(OVar(&#34;len&#34;), plt.Integer(1)),
                            ),
                        ),
                        (
                            &#34;fold_start&#34;,
                            OLambda(
                                [&#34;start&#34;],
                                plt.FoldList(
                                    plt.Range(OVar(&#34;len&#34;), OVar(&#34;start&#34;)),
                                    OLambda(
                                        [&#34;s&#34;, &#34;i&#34;],
                                        OLet(
                                            [
                                                (
                                                    &#34;b&#34;,
                                                    plt.IndexByteString(
                                                        OVar(&#34;e&#34;), OVar(&#34;i&#34;)
                                                    ),
                                                )
                                            ],
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;b&#34;), plt.Integer(ord(&#34;_&#34;))
                                                ),
                                                OVar(&#34;s&#34;),
                                                plt.Ite(
                                                    plt.Or(
                                                        plt.LessThanInteger(
                                                            OVar(&#34;b&#34;),
                                                            plt.Integer(ord(&#34;0&#34;)),
                                                        ),
                                                        plt.LessThanInteger(
                                                            plt.Integer(ord(&#34;9&#34;)),
                                                            OVar(&#34;b&#34;),
                                                        ),
                                                    ),
                                                    plt.TraceError(
                                                        &#34;ValueError: invalid literal for int() with base 10&#34;
                                                    ),
                                                    plt.AddInteger(
                                                        plt.SubtractInteger(
                                                            OVar(&#34;b&#34;),
                                                            plt.Integer(ord(&#34;0&#34;)),
                                                        ),
                                                        plt.MultiplyInteger(
                                                            OVar(&#34;s&#34;),
                                                            plt.Integer(10),
                                                        ),
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                    plt.Integer(0),
                                ),
                            ),
                        ),
                    ],
                    plt.Ite(
                        plt.Or(
                            plt.Or(
                                plt.EqualsInteger(
                                    OVar(&#34;first_int&#34;),
                                    plt.Integer(ord(&#34;_&#34;)),
                                ),
                                plt.EqualsInteger(
                                    OVar(&#34;last_int&#34;),
                                    plt.Integer(ord(&#34;_&#34;)),
                                ),
                            ),
                            plt.And(
                                plt.EqualsInteger(OVar(&#34;len&#34;), plt.Integer(1)),
                                plt.Or(
                                    plt.EqualsInteger(
                                        OVar(&#34;first_int&#34;),
                                        plt.Integer(ord(&#34;-&#34;)),
                                    ),
                                    plt.EqualsInteger(
                                        OVar(&#34;first_int&#34;),
                                        plt.Integer(ord(&#34;+&#34;)),
                                    ),
                                ),
                            ),
                        ),
                        plt.TraceError(
                            &#34;ValueError: invalid literal for int() with base 10&#34;
                        ),
                        plt.Ite(
                            plt.EqualsInteger(
                                OVar(&#34;first_int&#34;),
                                plt.Integer(ord(&#34;-&#34;)),
                            ),
                            plt.Negate(
                                plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(1)),
                            ),
                            plt.Ite(
                                plt.EqualsInteger(
                                    OVar(&#34;first_int&#34;),
                                    plt.Integer(ord(&#34;+&#34;)),
                                ),
                                plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(1)),
                                plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(0)),
                            ),
                        ),
                    ),
                ),
            )
        else:
            raise NotImplementedError(
                f&#34;Can not derive integer from type {arg.typ.__name__}&#34;
            )


class BoolImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;bool&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only create bools from instances&#34;
        assert any(
            isinstance(typ.typ, t)
            for t in (
                IntegerType,
                StringType,
                ByteStringType,
                BoolType,
                UnitType,
                ListType,
                DictType,
            )
        ), &#34;Can only create bools from int, str, bool, bytes, None, list or dict&#34;
        return FunctionType(args, BoolInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only create bools from instances&#34;
        if isinstance(arg.typ, BoolType):
            return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
        elif isinstance(arg.typ, IntegerType):
            return OLambda([&#34;x&#34;], plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)))
        elif isinstance(arg.typ, StringType):
            return OLambda(
                [&#34;x&#34;],
                plt.NotEqualsInteger(
                    plt.LengthOfByteString(plt.EncodeUtf8(OVar(&#34;x&#34;))), plt.Integer(0)
                ),
            )
        elif isinstance(arg.typ, ByteStringType):
            return OLambda(
                [&#34;x&#34;],
                plt.NotEqualsInteger(plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(0)),
            )
        elif isinstance(arg.typ, ListType) or isinstance(arg.typ, DictType):
            return OLambda([&#34;x&#34;], plt.Not(plt.NullList(OVar(&#34;x&#34;))))
        elif isinstance(arg.typ, UnitType):
            return OLambda([&#34;x&#34;], plt.Bool(False))
        else:
            raise NotImplementedError(
                f&#34;Can not derive bool from type {arg.typ.__name__}&#34;
            )


class BytesImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;bytes&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only create bools from instances&#34;
        assert any(
            isinstance(typ.typ, t)
            for t in (
                IntegerType,
                ByteStringType,
                ListType,
            )
        ), &#34;Can only create bytes from int, bytes or integer lists&#34;
        if isinstance(typ.typ, ListType):
            assert (
                typ.typ.typ == IntegerInstanceType
            ), &#34;Can only create bytes from integer lists but got a list with another type&#34;
        return FunctionType(args, ByteStringInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only create bytes from instances&#34;
        if isinstance(arg.typ, ByteStringType):
            return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
        elif isinstance(arg.typ, IntegerType):
            return OLambda(
                [&#34;x&#34;],
                plt.Ite(
                    plt.LessThanInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    plt.TraceError(&#34;ValueError: negative count&#34;),
                    ByteStrIntMulImpl(plt.ByteString(b&#34;\x00&#34;), OVar(&#34;x&#34;)),
                ),
            )
        elif isinstance(arg.typ, ListType):
            return OLambda(
                [&#34;xs&#34;],
                plt.RFoldList(
                    OVar(&#34;xs&#34;),
                    OLambda([&#34;a&#34;, &#34;x&#34;], plt.ConsByteString(OVar(&#34;x&#34;), OVar(&#34;a&#34;))),
                    plt.ByteString(b&#34;&#34;),
                ),
            )
        else:
            raise NotImplementedError(
                f&#34;Can not derive bytes from type {arg.typ.__name__}&#34;
            )


@dataclass(frozen=True, unsafe_hash=True)
class PolymorphicFunctionType(ClassType):
    &#34;&#34;&#34;A special type of builtin that may act differently on different parameters&#34;&#34;&#34;

    polymorphic_function: PolymorphicFunction

    def __ge__(self, other):
        return (
            isinstance(other, PolymorphicFunctionType)
            and self.polymorphic_function == other.polymorphic_function
        )


@dataclass(frozen=True, unsafe_hash=True)
class PolymorphicFunctionInstanceType(InstanceType):
    typ: FunctionType
    polymorphic_function: PolymorphicFunction


EmptyListMap = {
    IntegerInstanceType: plt.EmptyIntegerList(),
    ByteStringInstanceType: plt.EmptyByteStringList(),
    StringInstanceType: plt.EmptyTextList(),
    UnitInstanceType: plt.EmptyUnitList(),
    BoolInstanceType: plt.EmptyBoolList(),
}


def empty_list(p: Type):
    if p in EmptyListMap:
        return EmptyListMap[p]
    assert isinstance(p, InstanceType), &#34;Can only create lists of instances&#34;
    if isinstance(p.typ, ListType):
        el = empty_list(p.typ.typ)
        return plt.EmptyListList(uplc.BuiltinList([], el.sample_value))
    if isinstance(p.typ, DictType):
        return plt.EmptyListList(
            uplc.BuiltinList(
                [],
                uplc.BuiltinPair(
                    uplc.PlutusConstr(0, frozenlist([])),
                    uplc.PlutusConstr(0, frozenlist([])),
                ),
            )
        )
    if (
        isinstance(p.typ, RecordType)
        or isinstance(p.typ, AnyType)
        or isinstance(p.typ, UnionType)
    ):
        return plt.EmptyDataList()
    raise NotImplementedError(f&#34;Empty lists of type {p} can&#39;t be constructed yet&#34;)


TransformExtParamsMap = {
    IntegerInstanceType: lambda x: plt.UnIData(x),
    ByteStringInstanceType: lambda x: plt.UnBData(x),
    StringInstanceType: lambda x: plt.DecodeUtf8(plt.UnBData(x)),
    UnitInstanceType: lambda x: plt.Apply(OLambda([&#34;_&#34;], plt.Unit())),
    BoolInstanceType: lambda x: plt.NotEqualsInteger(plt.UnIData(x), plt.Integer(0)),
}


def transform_ext_params_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if p in TransformExtParamsMap:
        return TransformExtParamsMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.MapList(
            plt.UnListData(x),
            OLambda([&#34;x&#34;], transform_ext_params_map(list_int_typ)(OVar(&#34;x&#34;))),
            empty_list(p.typ.typ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.UnMapData(x)
    return lambda x: x


TransformOutputMap = {
    StringInstanceType: lambda x: plt.BData(plt.EncodeUtf8(x)),
    IntegerInstanceType: lambda x: plt.IData(x),
    ByteStringInstanceType: lambda x: plt.BData(x),
    UnitInstanceType: lambda x: plt.Apply(
        OLambda([&#34;_&#34;], plt.ConstrData(plt.Integer(0), plt.EmptyDataList())), x
    ),
    BoolInstanceType: lambda x: plt.IData(
        plt.IfThenElse(x, plt.Integer(1), plt.Integer(0))
    ),
}


def transform_output_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if isinstance(p.typ, FunctionType) or isinstance(p.typ, PolymorphicFunction):
        raise NotImplementedError(
            &#34;Can not map functions into PlutusData and hence not return them from a function as Anything&#34;
        )
    if p in TransformOutputMap:
        return TransformOutputMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.ListData(
            plt.MapList(
                x,
                OLambda([&#34;x&#34;], transform_output_map(list_int_typ)(OVar(&#34;x&#34;))),
            ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.MapData(x)
    return lambda x: x</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opshin.type_impls.ByteStrIntMulImpl"><code class="name flex">
<span>def <span class="ident">ByteStrIntMulImpl</span></span>(<span>x:pluthon.pluthon_ast.AST, y:pluthon.pluthon_ast.AST)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RepeatedAdd(x: plt.AST, y: plt.AST):
    return plt.Apply(
        plt.RecFun(
            OLambda(
                [&#34;f&#34;, &#34;y&#34;, &#34;x&#34;, &#34;n&#34;],
                plt.Ite(
                    plt.LessThanEqualsInteger(OVar(&#34;n&#34;), plt.Integer(0)),
                    OVar(&#34;y&#34;),
                    OLet(
                        [
                            (
                                &#34;n_half&#34;,
                                plt.DivideInteger(OVar(&#34;n&#34;), plt.Integer(2)),
                            )
                        ],
                        plt.Ite(
                            # tests whether (x//2)*2 == x which is True iff x is even
                            plt.EqualsInteger(
                                plt.AddInteger(OVar(&#34;n_half&#34;), OVar(&#34;n_half&#34;)),
                                OVar(&#34;n&#34;),
                            ),
                            plt.Apply(
                                OVar(&#34;f&#34;),
                                OVar(&#34;f&#34;),
                                OVar(&#34;y&#34;),
                                add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                OVar(&#34;n_half&#34;),
                            ),
                            plt.Apply(
                                OVar(&#34;f&#34;),
                                OVar(&#34;f&#34;),
                                add(OVar(&#34;y&#34;), OVar(&#34;x&#34;)),
                                add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                OVar(&#34;n_half&#34;),
                            ),
                        ),
                    ),
                ),
            ),
        ),
        zero,
        x,
        y,
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.PowImpl"><code class="name flex">
<span>def <span class="ident">PowImpl</span></span>(<span>x:pluthon.pluthon_ast.AST, y:pluthon.pluthon_ast.AST)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RepeatedAdd(x: plt.AST, y: plt.AST):
    return plt.Apply(
        plt.RecFun(
            OLambda(
                [&#34;f&#34;, &#34;y&#34;, &#34;x&#34;, &#34;n&#34;],
                plt.Ite(
                    plt.LessThanEqualsInteger(OVar(&#34;n&#34;), plt.Integer(0)),
                    OVar(&#34;y&#34;),
                    OLet(
                        [
                            (
                                &#34;n_half&#34;,
                                plt.DivideInteger(OVar(&#34;n&#34;), plt.Integer(2)),
                            )
                        ],
                        plt.Ite(
                            # tests whether (x//2)*2 == x which is True iff x is even
                            plt.EqualsInteger(
                                plt.AddInteger(OVar(&#34;n_half&#34;), OVar(&#34;n_half&#34;)),
                                OVar(&#34;n&#34;),
                            ),
                            plt.Apply(
                                OVar(&#34;f&#34;),
                                OVar(&#34;f&#34;),
                                OVar(&#34;y&#34;),
                                add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                OVar(&#34;n_half&#34;),
                            ),
                            plt.Apply(
                                OVar(&#34;f&#34;),
                                OVar(&#34;f&#34;),
                                add(OVar(&#34;y&#34;), OVar(&#34;x&#34;)),
                                add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                OVar(&#34;n_half&#34;),
                            ),
                        ),
                    ),
                ),
            ),
        ),
        zero,
        x,
        y,
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.StrIntMulImpl"><code class="name flex">
<span>def <span class="ident">StrIntMulImpl</span></span>(<span>x:pluthon.pluthon_ast.AST, y:pluthon.pluthon_ast.AST)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RepeatedAdd(x: plt.AST, y: plt.AST):
    return plt.Apply(
        plt.RecFun(
            OLambda(
                [&#34;f&#34;, &#34;y&#34;, &#34;x&#34;, &#34;n&#34;],
                plt.Ite(
                    plt.LessThanEqualsInteger(OVar(&#34;n&#34;), plt.Integer(0)),
                    OVar(&#34;y&#34;),
                    OLet(
                        [
                            (
                                &#34;n_half&#34;,
                                plt.DivideInteger(OVar(&#34;n&#34;), plt.Integer(2)),
                            )
                        ],
                        plt.Ite(
                            # tests whether (x//2)*2 == x which is True iff x is even
                            plt.EqualsInteger(
                                plt.AddInteger(OVar(&#34;n_half&#34;), OVar(&#34;n_half&#34;)),
                                OVar(&#34;n&#34;),
                            ),
                            plt.Apply(
                                OVar(&#34;f&#34;),
                                OVar(&#34;f&#34;),
                                OVar(&#34;y&#34;),
                                add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                OVar(&#34;n_half&#34;),
                            ),
                            plt.Apply(
                                OVar(&#34;f&#34;),
                                OVar(&#34;f&#34;),
                                add(OVar(&#34;y&#34;), OVar(&#34;x&#34;)),
                                add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                OVar(&#34;n_half&#34;),
                            ),
                        ),
                    ),
                ),
            ),
        ),
        zero,
        x,
        y,
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.empty_list"><code class="name flex">
<span>def <span class="ident">empty_list</span></span>(<span>p:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty_list(p: Type):
    if p in EmptyListMap:
        return EmptyListMap[p]
    assert isinstance(p, InstanceType), &#34;Can only create lists of instances&#34;
    if isinstance(p.typ, ListType):
        el = empty_list(p.typ.typ)
        return plt.EmptyListList(uplc.BuiltinList([], el.sample_value))
    if isinstance(p.typ, DictType):
        return plt.EmptyListList(
            uplc.BuiltinList(
                [],
                uplc.BuiltinPair(
                    uplc.PlutusConstr(0, frozenlist([])),
                    uplc.PlutusConstr(0, frozenlist([])),
                ),
            )
        )
    if (
        isinstance(p.typ, RecordType)
        or isinstance(p.typ, AnyType)
        or isinstance(p.typ, UnionType)
    ):
        return plt.EmptyDataList()
    raise NotImplementedError(f&#34;Empty lists of type {p} can&#39;t be constructed yet&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.repeated_addition"><code class="name flex">
<span>def <span class="ident">repeated_addition</span></span>(<span>zero, add)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeated_addition(zero, add):
    # this is optimized for logarithmic complexity by exponentiation by squaring
    # it follows the implementation described here: https://en.wikipedia.org/wiki/Exponentiation_by_squaring#With_constant_auxiliary_memory
    def RepeatedAdd(x: plt.AST, y: plt.AST):
        return plt.Apply(
            plt.RecFun(
                OLambda(
                    [&#34;f&#34;, &#34;y&#34;, &#34;x&#34;, &#34;n&#34;],
                    plt.Ite(
                        plt.LessThanEqualsInteger(OVar(&#34;n&#34;), plt.Integer(0)),
                        OVar(&#34;y&#34;),
                        OLet(
                            [
                                (
                                    &#34;n_half&#34;,
                                    plt.DivideInteger(OVar(&#34;n&#34;), plt.Integer(2)),
                                )
                            ],
                            plt.Ite(
                                # tests whether (x//2)*2 == x which is True iff x is even
                                plt.EqualsInteger(
                                    plt.AddInteger(OVar(&#34;n_half&#34;), OVar(&#34;n_half&#34;)),
                                    OVar(&#34;n&#34;),
                                ),
                                plt.Apply(
                                    OVar(&#34;f&#34;),
                                    OVar(&#34;f&#34;),
                                    OVar(&#34;y&#34;),
                                    add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                    OVar(&#34;n_half&#34;),
                                ),
                                plt.Apply(
                                    OVar(&#34;f&#34;),
                                    OVar(&#34;f&#34;),
                                    add(OVar(&#34;y&#34;), OVar(&#34;x&#34;)),
                                    add(OVar(&#34;x&#34;), OVar(&#34;x&#34;)),
                                    OVar(&#34;n_half&#34;),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
            zero,
            x,
            y,
        )

    return RepeatedAdd</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.transform_ext_params_map"><code class="name flex">
<span>def <span class="ident">transform_ext_params_map</span></span>(<span>p:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_ext_params_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if p in TransformExtParamsMap:
        return TransformExtParamsMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.MapList(
            plt.UnListData(x),
            OLambda([&#34;x&#34;], transform_ext_params_map(list_int_typ)(OVar(&#34;x&#34;))),
            empty_list(p.typ.typ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.UnMapData(x)
    return lambda x: x</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.transform_output_map"><code class="name flex">
<span>def <span class="ident">transform_output_map</span></span>(<span>p:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_output_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if isinstance(p.typ, FunctionType) or isinstance(p.typ, PolymorphicFunction):
        raise NotImplementedError(
            &#34;Can not map functions into PlutusData and hence not return them from a function as Anything&#34;
        )
    if p in TransformOutputMap:
        return TransformOutputMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.ListData(
            plt.MapList(
                x,
                OLambda([&#34;x&#34;], transform_output_map(list_int_typ)(OVar(&#34;x&#34;))),
            ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.MapData(x)
    return lambda x: x</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opshin.type_impls.AnyType"><code class="flex name class">
<span>class <span class="ident">AnyType</span></span>
</code></dt>
<dd>
<div class="desc"><p>The top element in the partial order on types (excluding FunctionTypes, which do not compare to anything)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class AnyType(ClassType):
    &#34;&#34;&#34;The top element in the partial order on types (excluding FunctionTypes, which do not compare to anything)&#34;&#34;&#34;

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;any&#34;

    def attribute_type(self, attr: str) -&gt; Type:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        return super().attribute_type(attr)

    def attribute(self, attr: str) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return OLambda(
                [&#34;self&#34;],
                plt.Constructor(OVar(&#34;self&#34;)),
            )
        return super().attribute(attr)

    def __ge__(self, other):
        return (
            isinstance(other, ClassType)
            and not isinstance(other, FunctionType)
            and not isinstance(other, PolymorphicFunctionType)
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        if (
            (isinstance(o, RecordType))
            or isinstance(o, UnionType)
            or isinstance(o, AnyType)
        ):
            # Note that comparison with Record and UnionType is actually fine because both are Data
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                            OVar(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and (o.typ.typ &gt;= self or self &gt;= o.typ.typ)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        OPSHIN_LOGGER.warning(
            &#34;Serializing AnyType will result in RawPlutusData (CBOR representation) to be printed without additional type information. Annotate types where possible to avoid this warning.&#34;
        )
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [
                    (
                        &#34;joinMapList&#34;,
                        OLambda(
                            [&#34;m&#34;, &#34;l&#34;, &#34;start&#34;, &#34;end&#34;],
                            OLet(
                                [
                                    (
                                        &#34;g&#34;,
                                        plt.RecFun(
                                            OLambda(
                                                [&#34;f&#34;, &#34;l&#34;],
                                                plt.AppendString(
                                                    plt.Apply(
                                                        OVar(&#34;m&#34;),
                                                        plt.HeadList(OVar(&#34;l&#34;)),
                                                    ),
                                                    OLet(
                                                        [
                                                            (
                                                                &#34;t&#34;,
                                                                plt.TailList(OVar(&#34;l&#34;)),
                                                            )
                                                        ],
                                                        plt.IteNullList(
                                                            OVar(&#34;t&#34;),
                                                            OVar(&#34;end&#34;),
                                                            plt.AppendString(
                                                                plt.Text(&#34;, &#34;),
                                                                plt.Apply(
                                                                    OVar(&#34;f&#34;),
                                                                    OVar(&#34;f&#34;),
                                                                    OVar(&#34;t&#34;),
                                                                ),
                                                            ),
                                                        ),
                                                    ),
                                                ),
                                            )
                                        ),
                                    )
                                ],
                                plt.AppendString(
                                    OVar(&#34;start&#34;),
                                    plt.IteNullList(
                                        OVar(&#34;l&#34;),
                                        OVar(&#34;end&#34;),
                                        plt.Apply(
                                            OVar(&#34;g&#34;),
                                            OVar(&#34;l&#34;),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;stringifyPlutusData&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;d&#34;],
                                plt.DelayedChooseData(
                                    OVar(&#34;d&#34;),
                                    OLet(
                                        [
                                            (
                                                &#34;constructor&#34;,
                                                plt.FstPair(
                                                    plt.UnConstrData(OVar(&#34;d&#34;))
                                                ),
                                            )
                                        ],
                                        plt.Ite(
                                            plt.LessThanInteger(
                                                OVar(&#34;constructor&#34;),
                                                plt.Integer(128),
                                            ),
                                            plt.ConcatString(
                                                plt.Text(&#34;CBORTag(&#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.IData(
                                                        plt.AddInteger(
                                                            OVar(&#34;constructor&#34;),
                                                            plt.Ite(
                                                                plt.LessThanInteger(
                                                                    OVar(&#34;constructor&#34;),
                                                                    plt.Integer(7),
                                                                ),
                                                                plt.Integer(121),
                                                                plt.Integer(1280 - 7),
                                                            ),
                                                        )
                                                    ),
                                                ),
                                                plt.Text(&#34;, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.ListData(
                                                        plt.SndPair(
                                                            plt.UnConstrData(OVar(&#34;d&#34;))
                                                        )
                                                    ),
                                                ),
                                                plt.Text(&#34;)&#34;),
                                            ),
                                            plt.ConcatString(
                                                plt.Text(&#34;CBORTag(102, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.ListData(
                                                        plt.MkCons(
                                                            plt.IData(
                                                                OVar(&#34;constructor&#34;)
                                                            ),
                                                            plt.MkCons(
                                                                plt.ListData(
                                                                    plt.SndPair(
                                                                        plt.UnConstrData(
                                                                            OVar(&#34;d&#34;)
                                                                        )
                                                                    )
                                                                ),
                                                                plt.EmptyDataList(),
                                                            ),
                                                        )
                                                    ),
                                                ),
                                                plt.Text(&#34;)&#34;),
                                            ),
                                        ),
                                    ),
                                    plt.Apply(
                                        OVar(&#34;joinMapList&#34;),
                                        OLambda(
                                            [&#34;x&#34;],
                                            plt.ConcatString(
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.FstPair(OVar(&#34;x&#34;)),
                                                ),
                                                plt.Text(&#34;: &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.SndPair(OVar(&#34;x&#34;)),
                                                ),
                                            ),
                                        ),
                                        plt.UnMapData(OVar(&#34;d&#34;)),
                                        plt.Text(&#34;{&#34;),
                                        plt.Text(&#34;}&#34;),
                                    ),
                                    plt.Apply(
                                        OVar(&#34;joinMapList&#34;),
                                        OLambda(
                                            [&#34;x&#34;],
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;x&#34;),
                                            ),
                                        ),
                                        plt.UnListData(OVar(&#34;d&#34;)),
                                        plt.Text(&#34;[&#34;),
                                        plt.Text(&#34;]&#34;),
                                    ),
                                    plt.Apply(
                                        IntegerInstanceType.stringify(recursive=True),
                                        plt.UnIData(OVar(&#34;d&#34;)),
                                    ),
                                    plt.Apply(
                                        ByteStringInstanceType.stringify(
                                            recursive=True
                                        ),
                                        plt.UnBData(OVar(&#34;d&#34;)),
                                    ),
                                ),
                            )
                        ),
                    ),
                ],
                plt.ConcatString(
                    plt.Text(&#34;RawPlutusData(data=&#34;),
                    plt.Apply(OVar(&#34;stringifyPlutusData&#34;), OVar(&#34;self&#34;)),
                    plt.Text(&#34;)&#34;),
                ),
            ),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.AnyType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr:str) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The attributes of this class. Need to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr: str) -&gt; plt.AST:
    &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
    if attr == &#34;CONSTR_ID&#34;:
        # access to constructor
        return OLambda(
            [&#34;self&#34;],
            plt.Constructor(OVar(&#34;self&#34;)),
        )
    return super().attribute(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.AnyType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr:str) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr: str) -&gt; Type:
    &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
    if attr == &#34;CONSTR_ID&#34;:
        return IntegerInstanceType
    return super().attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.AnyType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.AnyType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.AnyType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    # this will reject comparisons that will always be false - most likely due to faults during programming
    if (
        (isinstance(o, RecordType))
        or isinstance(o, UnionType)
        or isinstance(o, AnyType)
    ):
        # Note that comparison with Record and UnionType is actually fine because both are Data
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
        if isinstance(op, NotEq):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        OVar(&#34;x&#34;),
                        OVar(&#34;y&#34;),
                    )
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and (o.typ.typ &gt;= self or self &gt;= o.typ.typ)
    ):
        if isinstance(op, In):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.AnyList(
                    OVar(&#34;y&#34;),
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        OVar(&#34;x&#34;),
                    ),
                ),
            )
        if isinstance(op, NotIn):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                ),
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.AnyType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.AnyType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.AnyType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.AnyType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return &#34;any&#34;</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.AnyType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    OPSHIN_LOGGER.warning(
        &#34;Serializing AnyType will result in RawPlutusData (CBOR representation) to be printed without additional type information. Annotate types where possible to avoid this warning.&#34;
    )
    return OLambda(
        [&#34;self&#34;],
        OLet(
            [
                (
                    &#34;joinMapList&#34;,
                    OLambda(
                        [&#34;m&#34;, &#34;l&#34;, &#34;start&#34;, &#34;end&#34;],
                        OLet(
                            [
                                (
                                    &#34;g&#34;,
                                    plt.RecFun(
                                        OLambda(
                                            [&#34;f&#34;, &#34;l&#34;],
                                            plt.AppendString(
                                                plt.Apply(
                                                    OVar(&#34;m&#34;),
                                                    plt.HeadList(OVar(&#34;l&#34;)),
                                                ),
                                                OLet(
                                                    [
                                                        (
                                                            &#34;t&#34;,
                                                            plt.TailList(OVar(&#34;l&#34;)),
                                                        )
                                                    ],
                                                    plt.IteNullList(
                                                        OVar(&#34;t&#34;),
                                                        OVar(&#34;end&#34;),
                                                        plt.AppendString(
                                                            plt.Text(&#34;, &#34;),
                                                            plt.Apply(
                                                                OVar(&#34;f&#34;),
                                                                OVar(&#34;f&#34;),
                                                                OVar(&#34;t&#34;),
                                                            ),
                                                        ),
                                                    ),
                                                ),
                                            ),
                                        )
                                    ),
                                )
                            ],
                            plt.AppendString(
                                OVar(&#34;start&#34;),
                                plt.IteNullList(
                                    OVar(&#34;l&#34;),
                                    OVar(&#34;end&#34;),
                                    plt.Apply(
                                        OVar(&#34;g&#34;),
                                        OVar(&#34;l&#34;),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
                (
                    &#34;stringifyPlutusData&#34;,
                    plt.RecFun(
                        OLambda(
                            [&#34;f&#34;, &#34;d&#34;],
                            plt.DelayedChooseData(
                                OVar(&#34;d&#34;),
                                OLet(
                                    [
                                        (
                                            &#34;constructor&#34;,
                                            plt.FstPair(
                                                plt.UnConstrData(OVar(&#34;d&#34;))
                                            ),
                                        )
                                    ],
                                    plt.Ite(
                                        plt.LessThanInteger(
                                            OVar(&#34;constructor&#34;),
                                            plt.Integer(128),
                                        ),
                                        plt.ConcatString(
                                            plt.Text(&#34;CBORTag(&#34;),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.IData(
                                                    plt.AddInteger(
                                                        OVar(&#34;constructor&#34;),
                                                        plt.Ite(
                                                            plt.LessThanInteger(
                                                                OVar(&#34;constructor&#34;),
                                                                plt.Integer(7),
                                                            ),
                                                            plt.Integer(121),
                                                            plt.Integer(1280 - 7),
                                                        ),
                                                    )
                                                ),
                                            ),
                                            plt.Text(&#34;, &#34;),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.ListData(
                                                    plt.SndPair(
                                                        plt.UnConstrData(OVar(&#34;d&#34;))
                                                    )
                                                ),
                                            ),
                                            plt.Text(&#34;)&#34;),
                                        ),
                                        plt.ConcatString(
                                            plt.Text(&#34;CBORTag(102, &#34;),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.ListData(
                                                    plt.MkCons(
                                                        plt.IData(
                                                            OVar(&#34;constructor&#34;)
                                                        ),
                                                        plt.MkCons(
                                                            plt.ListData(
                                                                plt.SndPair(
                                                                    plt.UnConstrData(
                                                                        OVar(&#34;d&#34;)
                                                                    )
                                                                )
                                                            ),
                                                            plt.EmptyDataList(),
                                                        ),
                                                    )
                                                ),
                                            ),
                                            plt.Text(&#34;)&#34;),
                                        ),
                                    ),
                                ),
                                plt.Apply(
                                    OVar(&#34;joinMapList&#34;),
                                    OLambda(
                                        [&#34;x&#34;],
                                        plt.ConcatString(
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.FstPair(OVar(&#34;x&#34;)),
                                            ),
                                            plt.Text(&#34;: &#34;),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.SndPair(OVar(&#34;x&#34;)),
                                            ),
                                        ),
                                    ),
                                    plt.UnMapData(OVar(&#34;d&#34;)),
                                    plt.Text(&#34;{&#34;),
                                    plt.Text(&#34;}&#34;),
                                ),
                                plt.Apply(
                                    OVar(&#34;joinMapList&#34;),
                                    OLambda(
                                        [&#34;x&#34;],
                                        plt.Apply(
                                            OVar(&#34;f&#34;),
                                            OVar(&#34;f&#34;),
                                            OVar(&#34;x&#34;),
                                        ),
                                    ),
                                    plt.UnListData(OVar(&#34;d&#34;)),
                                    plt.Text(&#34;[&#34;),
                                    plt.Text(&#34;]&#34;),
                                ),
                                plt.Apply(
                                    IntegerInstanceType.stringify(recursive=True),
                                    plt.UnIData(OVar(&#34;d&#34;)),
                                ),
                                plt.Apply(
                                    ByteStringInstanceType.stringify(
                                        recursive=True
                                    ),
                                    plt.UnBData(OVar(&#34;d&#34;)),
                                ),
                            ),
                        )
                    ),
                ),
            ],
            plt.ConcatString(
                plt.Text(&#34;RawPlutusData(data=&#34;),
                plt.Apply(OVar(&#34;stringifyPlutusData&#34;), OVar(&#34;self&#34;)),
                plt.Text(&#34;)&#34;),
            ),
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.AnyType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.AnyType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.AtomicType"><code class="flex name class">
<span>class <span class="ident">AtomicType</span></span>
</code></dt>
<dd>
<div class="desc"><p>AtomicType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class AtomicType(ClassType):
    def __ge__(self, other):
        # Can only substitute for its own type (also subtypes)
        return isinstance(other, self.__class__)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.BoolType" href="#opshin.type_impls.BoolType">BoolType</a></li>
<li><a title="opshin.type_impls.ByteStringType" href="#opshin.type_impls.ByteStringType">ByteStringType</a></li>
<li><a title="opshin.type_impls.IntegerType" href="#opshin.type_impls.IntegerType">IntegerType</a></li>
<li><a title="opshin.type_impls.StringType" href="#opshin.type_impls.StringType">StringType</a></li>
<li><a title="opshin.type_impls.UnitType" href="#opshin.type_impls.UnitType">UnitType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.AtomicType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.AtomicType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.BoolImpl"><code class="flex name class">
<span>class <span class="ident">BoolImpl</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoolImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;bool&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only create bools from instances&#34;
        assert any(
            isinstance(typ.typ, t)
            for t in (
                IntegerType,
                StringType,
                ByteStringType,
                BoolType,
                UnitType,
                ListType,
                DictType,
            )
        ), &#34;Can only create bools from int, str, bool, bytes, None, list or dict&#34;
        return FunctionType(args, BoolInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only create bools from instances&#34;
        if isinstance(arg.typ, BoolType):
            return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
        elif isinstance(arg.typ, IntegerType):
            return OLambda([&#34;x&#34;], plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)))
        elif isinstance(arg.typ, StringType):
            return OLambda(
                [&#34;x&#34;],
                plt.NotEqualsInteger(
                    plt.LengthOfByteString(plt.EncodeUtf8(OVar(&#34;x&#34;))), plt.Integer(0)
                ),
            )
        elif isinstance(arg.typ, ByteStringType):
            return OLambda(
                [&#34;x&#34;],
                plt.NotEqualsInteger(plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(0)),
            )
        elif isinstance(arg.typ, ListType) or isinstance(arg.typ, DictType):
            return OLambda([&#34;x&#34;], plt.Not(plt.NullList(OVar(&#34;x&#34;))))
        elif isinstance(arg.typ, UnitType):
            return OLambda([&#34;x&#34;], plt.Bool(False))
        else:
            raise NotImplementedError(
                f&#34;Can not derive bool from type {arg.typ.__name__}&#34;
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.BoolImpl.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    arg = args[0]
    assert isinstance(arg, InstanceType), &#34;Can only create bools from instances&#34;
    if isinstance(arg.typ, BoolType):
        return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
    elif isinstance(arg.typ, IntegerType):
        return OLambda([&#34;x&#34;], plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)))
    elif isinstance(arg.typ, StringType):
        return OLambda(
            [&#34;x&#34;],
            plt.NotEqualsInteger(
                plt.LengthOfByteString(plt.EncodeUtf8(OVar(&#34;x&#34;))), plt.Integer(0)
            ),
        )
    elif isinstance(arg.typ, ByteStringType):
        return OLambda(
            [&#34;x&#34;],
            plt.NotEqualsInteger(plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(0)),
        )
    elif isinstance(arg.typ, ListType) or isinstance(arg.typ, DictType):
        return OLambda([&#34;x&#34;], plt.Not(plt.NullList(OVar(&#34;x&#34;))))
    elif isinstance(arg.typ, UnitType):
        return OLambda([&#34;x&#34;], plt.Bool(False))
    else:
        raise NotImplementedError(
            f&#34;Can not derive bool from type {arg.typ.__name__}&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.BoolImpl.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) ><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    assert (
        len(args) == 1
    ), f&#34;&#39;bool&#39; takes only one argument, but {len(args)} were given&#34;
    typ = args[0]
    assert isinstance(typ, InstanceType), &#34;Can only create bools from instances&#34;
    assert any(
        isinstance(typ.typ, t)
        for t in (
            IntegerType,
            StringType,
            ByteStringType,
            BoolType,
            UnitType,
            ListType,
            DictType,
        )
    ), &#34;Can only create bools from int, str, bool, bytes, None, list or dict&#34;
    return FunctionType(args, BoolInstanceType)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.BoolType"><code class="flex name class">
<span>class <span class="ident">BoolType</span></span>
</code></dt>
<dd>
<div class="desc"><p>BoolType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class BoolType(AtomicType):
    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(PolymorphicFunctionType(BoolImpl()))

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return OLambda(
                    [&#34;y&#34;, &#34;x&#34;],
                    plt.Ite(
                        OVar(&#34;y&#34;),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;y&#34;, &#34;x&#34;],
                    plt.Ite(
                        OVar(&#34;y&#34;),
                        plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                        plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Iff(OVar(&#34;x&#34;), OVar(&#34;y&#34;)))
            if isinstance(op, NotEq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Not(plt.Iff(OVar(&#34;x&#34;), OVar(&#34;y&#34;))))
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;self&#34;],
            plt.Ite(
                OVar(&#34;self&#34;),
                plt.Text(&#34;True&#34;),
                plt.Text(&#34;False&#34;),
            ),
        )

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return plt.Not
        return super()._unop_fun(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></li>
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.BoolType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute" href="#opshin.type_impls.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.BoolType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute_type" href="#opshin.type_impls.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.BoolType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop" href="#opshin.type_impls.AtomicType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.BoolType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop_type" href="#opshin.type_impls.AtomicType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.BoolType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.cmp" href="#opshin.type_impls.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, IntegerType):
        if isinstance(op, Eq):
            # 1 == True
            # 0 == False
            # all other comparisons are False
            return OLambda(
                [&#34;y&#34;, &#34;x&#34;],
                plt.Ite(
                    OVar(&#34;y&#34;),
                    plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                    plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                ),
            )
        if isinstance(op, NotEq):
            return OLambda(
                [&#34;y&#34;, &#34;x&#34;],
                plt.Ite(
                    OVar(&#34;y&#34;),
                    plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                    plt.NotEqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                ),
            )
    if isinstance(o, BoolType):
        if isinstance(op, Eq):
            return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Iff(OVar(&#34;x&#34;), OVar(&#34;y&#34;)))
        if isinstance(op, NotEq):
            return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Not(plt.Iff(OVar(&#34;x&#34;), OVar(&#34;y&#34;))))
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.BoolType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr" href="#opshin.type_impls.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.BoolType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr_type" href="#opshin.type_impls.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; &#34;InstanceType&#34;:
    return InstanceType(PolymorphicFunctionType(BoolImpl()))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.BoolType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.copy_only_attributes" href="#opshin.type_impls.AtomicType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.BoolType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.id_map" href="#opshin.type_impls.AtomicType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.BoolType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.stringify" href="#opshin.type_impls.AtomicType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return OLambda(
        [&#34;self&#34;],
        plt.Ite(
            OVar(&#34;self&#34;),
            plt.Text(&#34;True&#34;),
            plt.Text(&#34;False&#34;),
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.BoolType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop" href="#opshin.type_impls.AtomicType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.BoolType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop_type" href="#opshin.type_impls.AtomicType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.ByteStringType"><code class="flex name class">
<span>class <span class="ident">ByteStringType</span></span>
</code></dt>
<dd>
<div class="desc"><p>ByteStringType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class ByteStringType(AtomicType):
    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;bytes&#34;

    def constr_type(self) -&gt; InstanceType:
        return InstanceType(PolymorphicFunctionType(BytesImpl()))

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;decode&#34;:
            return InstanceType(FunctionType(frozenlist([]), StringInstanceType))
        if attr == &#34;hex&#34;:
            return InstanceType(FunctionType(frozenlist([]), StringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;decode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return OLambda([&#34;x&#34;, &#34;_&#34;], plt.DecodeUtf8(OVar(&#34;x&#34;)))
        if attr == &#34;hex&#34;:
            return OLambda(
                [&#34;x&#34;, &#34;_&#34;],
                plt.DecodeUtf8(
                    OLet(
                        [
                            (
                                &#34;hexlist&#34;,
                                plt.RecFun(
                                    OLambda(
                                        [&#34;f&#34;, &#34;i&#34;],
                                        plt.Ite(
                                            plt.LessThanInteger(
                                                OVar(&#34;i&#34;), plt.Integer(0)
                                            ),
                                            plt.EmptyIntegerList(),
                                            plt.MkCons(
                                                plt.IndexByteString(
                                                    OVar(&#34;x&#34;), OVar(&#34;i&#34;)
                                                ),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    plt.SubtractInteger(
                                                        OVar(&#34;i&#34;), plt.Integer(1)
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                            (
                                &#34;map_str&#34;,
                                OLambda(
                                    [&#34;i&#34;],
                                    plt.AddInteger(
                                        OVar(&#34;i&#34;),
                                        plt.IfThenElse(
                                            plt.LessThanInteger(
                                                OVar(&#34;i&#34;), plt.Integer(10)
                                            ),
                                            plt.Integer(ord(&#34;0&#34;)),
                                            plt.Integer(ord(&#34;a&#34;) - 10),
                                        ),
                                    ),
                                ),
                            ),
                            (
                                &#34;mkstr&#34;,
                                OLambda(
                                    [&#34;i&#34;],
                                    plt.FoldList(
                                        plt.Apply(OVar(&#34;hexlist&#34;), OVar(&#34;i&#34;)),
                                        OLambda(
                                            [&#34;b&#34;, &#34;i&#34;],
                                            plt.ConsByteString(
                                                plt.Apply(
                                                    OVar(&#34;map_str&#34;),
                                                    plt.DivideInteger(
                                                        OVar(&#34;i&#34;), plt.Integer(16)
                                                    ),
                                                ),
                                                plt.ConsByteString(
                                                    plt.Apply(
                                                        OVar(&#34;map_str&#34;),
                                                        plt.ModInteger(
                                                            OVar(&#34;i&#34;),
                                                            plt.Integer(16),
                                                        ),
                                                    ),
                                                    OVar(&#34;b&#34;),
                                                ),
                                            ),
                                        ),
                                        plt.ByteString(b&#34;&#34;),
                                    ),
                                ),
                            ),
                        ],
                        plt.Apply(
                            OVar(&#34;mkstr&#34;),
                            plt.SubtractInteger(
                                plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(1)
                            ),
                        ),
                    ),
                ),
            )
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, ByteStringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsByteString)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            OVar(&#34;y&#34;),
                            OVar(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanByteString)
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString)
            if isinstance(op, Gt):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanByteString),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, ByteStringType)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;x&#34;],
            plt.DecodeUtf8(
                OLet(
                    [
                        (
                            &#34;hexlist&#34;,
                            plt.RecFun(
                                OLambda(
                                    [&#34;f&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        plt.LessThanInteger(OVar(&#34;i&#34;), plt.Integer(0)),
                                        plt.EmptyIntegerList(),
                                        plt.MkCons(
                                            plt.IndexByteString(OVar(&#34;x&#34;), OVar(&#34;i&#34;)),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.SubtractInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(1)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;map_str&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.AddInteger(
                                    OVar(&#34;i&#34;),
                                    plt.IfThenElse(
                                        plt.LessThanInteger(OVar(&#34;i&#34;), plt.Integer(10)),
                                        plt.Integer(ord(&#34;0&#34;)),
                                        plt.Integer(ord(&#34;a&#34;) - 10),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;mkstr&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.FoldList(
                                    plt.Apply(OVar(&#34;hexlist&#34;), OVar(&#34;i&#34;)),
                                    OLambda(
                                        [&#34;b&#34;, &#34;i&#34;],
                                        plt.Ite(
                                            # ascii printable characters are kept unmodified
                                            plt.And(
                                                plt.LessThanEqualsInteger(
                                                    plt.Integer(0x20), OVar(&#34;i&#34;)
                                                ),
                                                plt.LessThanEqualsInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(0x7E)
                                                ),
                                            ),
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;i&#34;),
                                                    plt.Integer(ord(&#34;\\&#34;)),
                                                ),
                                                plt.AppendByteString(
                                                    plt.ByteString(b&#34;\\\\&#34;),
                                                    OVar(&#34;b&#34;),
                                                ),
                                                plt.Ite(
                                                    plt.EqualsInteger(
                                                        OVar(&#34;i&#34;),
                                                        plt.Integer(ord(&#34;&#39;&#34;)),
                                                    ),
                                                    plt.AppendByteString(
                                                        plt.ByteString(b&#34;\\&#39;&#34;),
                                                        OVar(&#34;b&#34;),
                                                    ),
                                                    plt.ConsByteString(
                                                        OVar(&#34;i&#34;), OVar(&#34;b&#34;)
                                                    ),
                                                ),
                                            ),
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(ord(&#34;\t&#34;))
                                                ),
                                                plt.AppendByteString(
                                                    plt.ByteString(b&#34;\\t&#34;), OVar(&#34;b&#34;)
                                                ),
                                                plt.Ite(
                                                    plt.EqualsInteger(
                                                        OVar(&#34;i&#34;),
                                                        plt.Integer(ord(&#34;\n&#34;)),
                                                    ),
                                                    plt.AppendByteString(
                                                        plt.ByteString(b&#34;\\n&#34;),
                                                        OVar(&#34;b&#34;),
                                                    ),
                                                    plt.Ite(
                                                        plt.EqualsInteger(
                                                            OVar(&#34;i&#34;),
                                                            plt.Integer(ord(&#34;\r&#34;)),
                                                        ),
                                                        plt.AppendByteString(
                                                            plt.ByteString(b&#34;\\r&#34;),
                                                            OVar(&#34;b&#34;),
                                                        ),
                                                        plt.AppendByteString(
                                                            plt.ByteString(b&#34;\\x&#34;),
                                                            plt.ConsByteString(
                                                                plt.Apply(
                                                                    OVar(&#34;map_str&#34;),
                                                                    plt.DivideInteger(
                                                                        OVar(&#34;i&#34;),
                                                                        plt.Integer(16),
                                                                    ),
                                                                ),
                                                                plt.ConsByteString(
                                                                    plt.Apply(
                                                                        OVar(&#34;map_str&#34;),
                                                                        plt.ModInteger(
                                                                            OVar(&#34;i&#34;),
                                                                            plt.Integer(
                                                                                16
                                                                            ),
                                                                        ),
                                                                    ),
                                                                    OVar(&#34;b&#34;),
                                                                ),
                                                            ),
                                                        ),
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                    plt.ByteString(b&#34;&#34;),
                                ),
                            ),
                        ),
                    ],
                    plt.ConcatByteString(
                        plt.ByteString(b&#34;b&#39;&#34;),
                        plt.Apply(
                            OVar(&#34;mkstr&#34;),
                            plt.SubtractInteger(
                                plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(1)
                            ),
                        ),
                        plt.ByteString(b&#34;&#39;&#34;),
                    ),
                ),
            ),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if other == ByteStringInstanceType:
                return ByteStringType()
        if isinstance(binop, Mult):
            if other == IntegerInstanceType:
                return ByteStringType()
        return super().binop_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if isinstance(binop, Add):
            if other.typ == ByteStringInstanceType:
                return plt.AppendByteString
        if isinstance(binop, Mult):
            if other.typ == IntegerInstanceType:
                return ByteStrIntMulImpl

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.EqualsInteger(
                plt.LengthOfByteString(x), plt.Integer(0)
            )
        return super()._unop_fun(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></li>
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.ByteStringType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute" href="#opshin.type_impls.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    if attr == &#34;decode&#34;:
        # No codec -&gt; only the default (utf8) is allowed
        return OLambda([&#34;x&#34;, &#34;_&#34;], plt.DecodeUtf8(OVar(&#34;x&#34;)))
    if attr == &#34;hex&#34;:
        return OLambda(
            [&#34;x&#34;, &#34;_&#34;],
            plt.DecodeUtf8(
                OLet(
                    [
                        (
                            &#34;hexlist&#34;,
                            plt.RecFun(
                                OLambda(
                                    [&#34;f&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        plt.LessThanInteger(
                                            OVar(&#34;i&#34;), plt.Integer(0)
                                        ),
                                        plt.EmptyIntegerList(),
                                        plt.MkCons(
                                            plt.IndexByteString(
                                                OVar(&#34;x&#34;), OVar(&#34;i&#34;)
                                            ),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.SubtractInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(1)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;map_str&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.AddInteger(
                                    OVar(&#34;i&#34;),
                                    plt.IfThenElse(
                                        plt.LessThanInteger(
                                            OVar(&#34;i&#34;), plt.Integer(10)
                                        ),
                                        plt.Integer(ord(&#34;0&#34;)),
                                        plt.Integer(ord(&#34;a&#34;) - 10),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;mkstr&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.FoldList(
                                    plt.Apply(OVar(&#34;hexlist&#34;), OVar(&#34;i&#34;)),
                                    OLambda(
                                        [&#34;b&#34;, &#34;i&#34;],
                                        plt.ConsByteString(
                                            plt.Apply(
                                                OVar(&#34;map_str&#34;),
                                                plt.DivideInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(16)
                                                ),
                                            ),
                                            plt.ConsByteString(
                                                plt.Apply(
                                                    OVar(&#34;map_str&#34;),
                                                    plt.ModInteger(
                                                        OVar(&#34;i&#34;),
                                                        plt.Integer(16),
                                                    ),
                                                ),
                                                OVar(&#34;b&#34;),
                                            ),
                                        ),
                                    ),
                                    plt.ByteString(b&#34;&#34;),
                                ),
                            ),
                        ),
                    ],
                    plt.Apply(
                        OVar(&#34;mkstr&#34;),
                        plt.SubtractInteger(
                            plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(1)
                        ),
                    ),
                ),
            ),
        )
    return super().attribute(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ByteStringType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute_type" href="#opshin.type_impls.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; Type:
    if attr == &#34;decode&#34;:
        return InstanceType(FunctionType(frozenlist([]), StringInstanceType))
    if attr == &#34;hex&#34;:
        return InstanceType(FunctionType(frozenlist([]), StringInstanceType))
    return super().attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ByteStringType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop" href="#opshin.type_impls.AtomicType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.ByteStringType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop_type" href="#opshin.type_impls.AtomicType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.ByteStringType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.cmp" href="#opshin.type_impls.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, ByteStringType):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsByteString)
        if isinstance(op, NotEq):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    )
                ),
            )
        if isinstance(op, Lt):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanByteString)
        if isinstance(op, LtE):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString)
        if isinstance(op, Gt):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanByteString),
                    OVar(&#34;y&#34;),
                    OVar(&#34;x&#34;),
                ),
            )
        if isinstance(op, GtE):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString),
                    OVar(&#34;y&#34;),
                    OVar(&#34;x&#34;),
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and isinstance(o.typ.typ, ByteStringType)
    ):
        if isinstance(op, In):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.AnyList(
                    OVar(&#34;y&#34;),
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                        OVar(&#34;x&#34;),
                    ),
                ),
            )
        if isinstance(op, NotIn):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                ),
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ByteStringType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr" href="#opshin.type_impls.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.ByteStringType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr_type" href="#opshin.type_impls.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; InstanceType:
    return InstanceType(PolymorphicFunctionType(BytesImpl()))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ByteStringType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.copy_only_attributes" href="#opshin.type_impls.AtomicType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.ByteStringType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.id_map" href="#opshin.type_impls.AtomicType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return &#34;bytes&#34;</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ByteStringType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.stringify" href="#opshin.type_impls.AtomicType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return OLambda(
        [&#34;x&#34;],
        plt.DecodeUtf8(
            OLet(
                [
                    (
                        &#34;hexlist&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;i&#34;],
                                plt.Ite(
                                    plt.LessThanInteger(OVar(&#34;i&#34;), plt.Integer(0)),
                                    plt.EmptyIntegerList(),
                                    plt.MkCons(
                                        plt.IndexByteString(OVar(&#34;x&#34;), OVar(&#34;i&#34;)),
                                        plt.Apply(
                                            OVar(&#34;f&#34;),
                                            OVar(&#34;f&#34;),
                                            plt.SubtractInteger(
                                                OVar(&#34;i&#34;), plt.Integer(1)
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;map_str&#34;,
                        OLambda(
                            [&#34;i&#34;],
                            plt.AddInteger(
                                OVar(&#34;i&#34;),
                                plt.IfThenElse(
                                    plt.LessThanInteger(OVar(&#34;i&#34;), plt.Integer(10)),
                                    plt.Integer(ord(&#34;0&#34;)),
                                    plt.Integer(ord(&#34;a&#34;) - 10),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;mkstr&#34;,
                        OLambda(
                            [&#34;i&#34;],
                            plt.FoldList(
                                plt.Apply(OVar(&#34;hexlist&#34;), OVar(&#34;i&#34;)),
                                OLambda(
                                    [&#34;b&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        # ascii printable characters are kept unmodified
                                        plt.And(
                                            plt.LessThanEqualsInteger(
                                                plt.Integer(0x20), OVar(&#34;i&#34;)
                                            ),
                                            plt.LessThanEqualsInteger(
                                                OVar(&#34;i&#34;), plt.Integer(0x7E)
                                            ),
                                        ),
                                        plt.Ite(
                                            plt.EqualsInteger(
                                                OVar(&#34;i&#34;),
                                                plt.Integer(ord(&#34;\\&#34;)),
                                            ),
                                            plt.AppendByteString(
                                                plt.ByteString(b&#34;\\\\&#34;),
                                                OVar(&#34;b&#34;),
                                            ),
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;i&#34;),
                                                    plt.Integer(ord(&#34;&#39;&#34;)),
                                                ),
                                                plt.AppendByteString(
                                                    plt.ByteString(b&#34;\\&#39;&#34;),
                                                    OVar(&#34;b&#34;),
                                                ),
                                                plt.ConsByteString(
                                                    OVar(&#34;i&#34;), OVar(&#34;b&#34;)
                                                ),
                                            ),
                                        ),
                                        plt.Ite(
                                            plt.EqualsInteger(
                                                OVar(&#34;i&#34;), plt.Integer(ord(&#34;\t&#34;))
                                            ),
                                            plt.AppendByteString(
                                                plt.ByteString(b&#34;\\t&#34;), OVar(&#34;b&#34;)
                                            ),
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;i&#34;),
                                                    plt.Integer(ord(&#34;\n&#34;)),
                                                ),
                                                plt.AppendByteString(
                                                    plt.ByteString(b&#34;\\n&#34;),
                                                    OVar(&#34;b&#34;),
                                                ),
                                                plt.Ite(
                                                    plt.EqualsInteger(
                                                        OVar(&#34;i&#34;),
                                                        plt.Integer(ord(&#34;\r&#34;)),
                                                    ),
                                                    plt.AppendByteString(
                                                        plt.ByteString(b&#34;\\r&#34;),
                                                        OVar(&#34;b&#34;),
                                                    ),
                                                    plt.AppendByteString(
                                                        plt.ByteString(b&#34;\\x&#34;),
                                                        plt.ConsByteString(
                                                            plt.Apply(
                                                                OVar(&#34;map_str&#34;),
                                                                plt.DivideInteger(
                                                                    OVar(&#34;i&#34;),
                                                                    plt.Integer(16),
                                                                ),
                                                            ),
                                                            plt.ConsByteString(
                                                                plt.Apply(
                                                                    OVar(&#34;map_str&#34;),
                                                                    plt.ModInteger(
                                                                        OVar(&#34;i&#34;),
                                                                        plt.Integer(
                                                                            16
                                                                        ),
                                                                    ),
                                                                ),
                                                                OVar(&#34;b&#34;),
                                                            ),
                                                        ),
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                    ),
                ],
                plt.ConcatByteString(
                    plt.ByteString(b&#34;b&#39;&#34;),
                    plt.Apply(
                        OVar(&#34;mkstr&#34;),
                        plt.SubtractInteger(
                            plt.LengthOfByteString(OVar(&#34;x&#34;)), plt.Integer(1)
                        ),
                    ),
                    plt.ByteString(b&#34;&#39;&#34;),
                ),
            ),
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ByteStringType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop" href="#opshin.type_impls.AtomicType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.ByteStringType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop_type" href="#opshin.type_impls.AtomicType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.BytesImpl"><code class="flex name class">
<span>class <span class="ident">BytesImpl</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BytesImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;bytes&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only create bools from instances&#34;
        assert any(
            isinstance(typ.typ, t)
            for t in (
                IntegerType,
                ByteStringType,
                ListType,
            )
        ), &#34;Can only create bytes from int, bytes or integer lists&#34;
        if isinstance(typ.typ, ListType):
            assert (
                typ.typ.typ == IntegerInstanceType
            ), &#34;Can only create bytes from integer lists but got a list with another type&#34;
        return FunctionType(args, ByteStringInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only create bytes from instances&#34;
        if isinstance(arg.typ, ByteStringType):
            return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
        elif isinstance(arg.typ, IntegerType):
            return OLambda(
                [&#34;x&#34;],
                plt.Ite(
                    plt.LessThanInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    plt.TraceError(&#34;ValueError: negative count&#34;),
                    ByteStrIntMulImpl(plt.ByteString(b&#34;\x00&#34;), OVar(&#34;x&#34;)),
                ),
            )
        elif isinstance(arg.typ, ListType):
            return OLambda(
                [&#34;xs&#34;],
                plt.RFoldList(
                    OVar(&#34;xs&#34;),
                    OLambda([&#34;a&#34;, &#34;x&#34;], plt.ConsByteString(OVar(&#34;x&#34;), OVar(&#34;a&#34;))),
                    plt.ByteString(b&#34;&#34;),
                ),
            )
        else:
            raise NotImplementedError(
                f&#34;Can not derive bytes from type {arg.typ.__name__}&#34;
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.BytesImpl.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    arg = args[0]
    assert isinstance(arg, InstanceType), &#34;Can only create bytes from instances&#34;
    if isinstance(arg.typ, ByteStringType):
        return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
    elif isinstance(arg.typ, IntegerType):
        return OLambda(
            [&#34;x&#34;],
            plt.Ite(
                plt.LessThanInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                plt.TraceError(&#34;ValueError: negative count&#34;),
                ByteStrIntMulImpl(plt.ByteString(b&#34;\x00&#34;), OVar(&#34;x&#34;)),
            ),
        )
    elif isinstance(arg.typ, ListType):
        return OLambda(
            [&#34;xs&#34;],
            plt.RFoldList(
                OVar(&#34;xs&#34;),
                OLambda([&#34;a&#34;, &#34;x&#34;], plt.ConsByteString(OVar(&#34;x&#34;), OVar(&#34;a&#34;))),
                plt.ByteString(b&#34;&#34;),
            ),
        )
    else:
        raise NotImplementedError(
            f&#34;Can not derive bytes from type {arg.typ.__name__}&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.BytesImpl.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) ><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    assert (
        len(args) == 1
    ), f&#34;&#39;bytes&#39; takes only one argument, but {len(args)} were given&#34;
    typ = args[0]
    assert isinstance(typ, InstanceType), &#34;Can only create bools from instances&#34;
    assert any(
        isinstance(typ.typ, t)
        for t in (
            IntegerType,
            ByteStringType,
            ListType,
        )
    ), &#34;Can only create bytes from int, bytes or integer lists&#34;
    if isinstance(typ.typ, ListType):
        assert (
            typ.typ.typ == IntegerInstanceType
        ), &#34;Can only create bytes from integer lists but got a list with another type&#34;
    return FunctionType(args, ByteStringInstanceType)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.ClassType"><code class="flex name class">
<span>class <span class="ident">ClassType</span></span>
</code></dt>
<dd>
<div class="desc"><p>ClassType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class ClassType(Type):
    def __ge__(self, other):
        &#34;&#34;&#34;
        Returns whether other can be substituted for this type.
        In other words this returns whether the interface of this type is a subset of the interface of other.
        Note that this is usually &lt;= and not &gt;=, but this needs to be fixed later.
        Produces a partial order on types.
        The top element is the most generic type and can not substitute for anything.
        The bottom element is the most specific type and can be substituted for anything.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Comparison between raw classtypes impossible&#34;)

    def copy_only_attributes(self) -&gt; plt.AST:
        &#34;&#34;&#34;
        Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
        For anything but record types and union types, this is the identity function.
        &#34;&#34;&#34;
        return OLambda([&#34;self&#34;], OVar(&#34;self&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.rewrite.rewrite_import_hashlib.HashType" href="rewrite/rewrite_import_hashlib.html#opshin.rewrite.rewrite_import_hashlib.HashType">HashType</a></li>
<li><a title="opshin.type_impls.AnyType" href="#opshin.type_impls.AnyType">AnyType</a></li>
<li><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></li>
<li><a title="opshin.type_impls.DictType" href="#opshin.type_impls.DictType">DictType</a></li>
<li><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></li>
<li><a title="opshin.type_impls.InaccessibleType" href="#opshin.type_impls.InaccessibleType">InaccessibleType</a></li>
<li><a title="opshin.type_impls.ListType" href="#opshin.type_impls.ListType">ListType</a></li>
<li><a title="opshin.type_impls.PairType" href="#opshin.type_impls.PairType">PairType</a></li>
<li><a title="opshin.type_impls.PolymorphicFunctionType" href="#opshin.type_impls.PolymorphicFunctionType">PolymorphicFunctionType</a></li>
<li><a title="opshin.type_impls.RecordType" href="#opshin.type_impls.RecordType">RecordType</a></li>
<li><a title="opshin.type_impls.TupleType" href="#opshin.type_impls.TupleType">TupleType</a></li>
<li><a title="opshin.type_impls.UnionType" href="#opshin.type_impls.UnionType">UnionType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.ClassType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.attribute" href="#opshin.type_impls.Type.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.attribute_type" href="#opshin.type_impls.Type.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.binop" href="#opshin.type_impls.Type.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.binop_type" href="#opshin.type_impls.Type.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.cmp" href="#opshin.type_impls.Type.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.ClassType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.constr" href="#opshin.type_impls.Type.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.constr_type" href="#opshin.type_impls.Type.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record types and union types, this is the identity function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_only_attributes(self) -&gt; plt.AST:
    &#34;&#34;&#34;
    Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
    For anything but record types and union types, this is the identity function.
    &#34;&#34;&#34;
    return OLambda([&#34;self&#34;], OVar(&#34;self&#34;))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ClassType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.id_map" href="#opshin.type_impls.Type.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.stringify" href="#opshin.type_impls.Type.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
</dd>
<dt id="opshin.type_impls.ClassType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.unop" href="#opshin.type_impls.Type.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.ClassType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.unop_type" href="#opshin.type_impls.Type.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.DictType"><code class="flex name class">
<span>class <span class="ident">DictType</span></span>
<span>(</span><span>key_typ:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>, value_typ:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>DictType(key_typ: opshin.type_impls.Type, value_typ: opshin.type_impls.Type)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class DictType(ClassType):
    key_typ: Type
    value_typ: Type

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;map&lt;&#34; + self.key_typ.id_map() + &#34;,&#34; + self.value_typ.id_map() + &#34;&gt;&#34;

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;get&#34;:
            return InstanceType(
                FunctionType(frozenlist([self.key_typ, self.value_typ]), self.value_typ)
            )
        if attr == &#34;keys&#34;:
            return InstanceType(
                FunctionType(frozenlist([]), InstanceType(ListType(self.key_typ)))
            )
        if attr == &#34;values&#34;:
            return InstanceType(
                FunctionType(frozenlist([]), InstanceType(ListType(self.value_typ)))
            )
        if attr == &#34;items&#34;:
            return InstanceType(
                FunctionType(
                    frozenlist([]),
                    InstanceType(
                        ListType(InstanceType(PairType(self.key_typ, self.value_typ)))
                    ),
                )
            )
        raise TypeInferenceError(
            f&#34;Type of attribute &#39;{attr}&#39; is unknown for type Dict.&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;get&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;key&#34;, &#34;default&#34;],
                transform_ext_params_map(self.value_typ)(
                    OLet(
                        [
                            (
                                &#34;key_mapped&#34;,
                                transform_output_map(self.key_typ)(
                                    plt.Force(OVar(&#34;key&#34;))
                                ),
                            )
                        ],
                        plt.SndPair(
                            plt.FindList(
                                OVar(&#34;self&#34;),
                                OLambda(
                                    [&#34;x&#34;],
                                    plt.EqualsData(
                                        OVar(&#34;key_mapped&#34;),
                                        plt.FstPair(OVar(&#34;x&#34;)),
                                    ),
                                ),
                                # this is a bit ugly... we wrap - only to later unwrap again
                                plt.MkPairData(
                                    OVar(&#34;key_mapped&#34;),
                                    transform_output_map(self.value_typ)(
                                        plt.Force(OVar(&#34;default&#34;))
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            )
        if attr == &#34;keys&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    OVar(&#34;self&#34;),
                    OLambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.key_typ)(plt.FstPair(OVar(&#34;x&#34;))),
                    ),
                    empty_list(self.key_typ),
                ),
            )
        if attr == &#34;values&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    OVar(&#34;self&#34;),
                    OLambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.value_typ)(
                            plt.SndPair(OVar(&#34;x&#34;))
                        ),
                    ),
                    empty_list(self.value_typ),
                ),
            )
        if attr == &#34;items&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                OVar(&#34;self&#34;),
            )
        raise NotImplementedError(f&#34;Attribute &#39;{attr}&#39; of Dict is unknown.&#34;)

    def __ge__(self, other):
        return (
            isinstance(other, DictType)
            and self.key_typ &gt;= other.key_typ
            and self.value_typ &gt;= other.value_typ
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [
                    (
                        &#34;g&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;l&#34;],
                                OLet(
                                    [
                                        (&#34;h&#34;, plt.HeadList(OVar(&#34;l&#34;))),
                                        (&#34;t&#34;, plt.TailList(OVar(&#34;l&#34;))),
                                    ],
                                    plt.ConcatString(
                                        plt.Apply(
                                            self.key_typ.stringify(recursive=True),
                                            transform_ext_params_map(self.key_typ)(
                                                plt.FstPair(OVar(&#34;h&#34;))
                                            ),
                                        ),
                                        plt.Text(&#34;: &#34;),
                                        plt.Apply(
                                            self.value_typ.stringify(recursive=True),
                                            transform_ext_params_map(self.value_typ)(
                                                plt.SndPair(OVar(&#34;h&#34;))
                                            ),
                                        ),
                                        plt.IteNullList(
                                            OVar(&#34;t&#34;),
                                            plt.Text(&#34;}&#34;),
                                            plt.AppendString(
                                                plt.Text(&#34;, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;t&#34;),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            )
                        ),
                    )
                ],
                plt.AppendString(
                    plt.Text(&#34;{&#34;),
                    plt.IteNullList(
                        OVar(&#34;self&#34;),
                        plt.Text(&#34;}&#34;),
                        plt.Apply(
                            OVar(&#34;g&#34;),
                            OVar(&#34;self&#34;),
                        ),
                    ),
                ),
            ),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        def CustomMapFilterList(
            l: plt.AST,
            filter_op: plt.AST,
            map_op: plt.AST,
            empty_list=plt.EmptyDataList(),
        ):
            from pluthon import (
                Apply,
                Lambda as PLambda,
                RecFun,
                IteNullList,
                Var as PVar,
                HeadList,
                Ite,
                TailList,
                PrependList,
                Let as PLet,
            )

            &#34;&#34;&#34;
            Apply a filter and a map function on each element in a list (throws out all that evaluate to false)
            Performs only a single pass and is hence much more efficient than filter + map
            &#34;&#34;&#34;
            return Apply(
                PLambda(
                    [&#34;filter&#34;, &#34;map&#34;],
                    RecFun(
                        PLambda(
                            [&#34;filtermap&#34;, &#34;xs&#34;],
                            IteNullList(
                                PVar(&#34;xs&#34;),
                                empty_list,
                                PLet(
                                    [
                                        (&#34;head&#34;, HeadList(PVar(&#34;xs&#34;))),
                                        (&#34;tail&#34;, TailList(PVar(&#34;xs&#34;))),
                                    ],
                                    Ite(
                                        Apply(
                                            PVar(&#34;filter&#34;), PVar(&#34;head&#34;), PVar(&#34;tail&#34;)
                                        ),
                                        PrependList(
                                            Apply(PVar(&#34;map&#34;), PVar(&#34;head&#34;)),
                                            Apply(
                                                PVar(&#34;filtermap&#34;),
                                                PVar(&#34;filtermap&#34;),
                                                PVar(&#34;tail&#34;),
                                            ),
                                        ),
                                        Apply(
                                            PVar(&#34;filtermap&#34;),
                                            PVar(&#34;filtermap&#34;),
                                            PVar(&#34;tail&#34;),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
                filter_op,
                map_op,
                l,
            )

        mapped_attrs = CustomMapFilterList(
            OVar(&#34;self&#34;),
            OLambda(
                [&#34;h&#34;, &#34;t&#34;],
                OLet(
                    [
                        (&#34;hfst&#34;, plt.FstPair(OVar(&#34;h&#34;))),
                    ],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;t&#34;),
                            OLambda(
                                [&#34;e&#34;],
                                plt.EqualsData(OVar(&#34;hfst&#34;), plt.FstPair(OVar(&#34;e&#34;))),
                            ),
                        )
                    ),
                ),
            ),
            OLambda(
                [&#34;v&#34;],
                plt.MkPairData(
                    transform_output_map(self.key_typ)(
                        plt.Apply(
                            self.key_typ.copy_only_attributes(),
                            transform_ext_params_map(self.key_typ)(
                                plt.FstPair(OVar(&#34;v&#34;))
                            ),
                        )
                    ),
                    transform_output_map(self.value_typ)(
                        plt.Apply(
                            self.value_typ.copy_only_attributes(),
                            transform_ext_params_map(self.value_typ)(
                                plt.SndPair(OVar(&#34;v&#34;))
                            ),
                        )
                    ),
                ),
            ),
            plt.EmptyDataPairList(),
        )
        return OLambda([&#34;self&#34;], mapped_attrs)

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.IteNullList(x, plt.Bool(True), plt.Bool(False))
        return super()._unop_fun(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.DictType.key_typ"><code class="name">var <span class="ident">key_typ</span> :<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.DictType.value_typ"><code class="name">var <span class="ident">value_typ</span> :<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.DictType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    if attr == &#34;get&#34;:
        return OLambda(
            [&#34;self&#34;, &#34;key&#34;, &#34;default&#34;],
            transform_ext_params_map(self.value_typ)(
                OLet(
                    [
                        (
                            &#34;key_mapped&#34;,
                            transform_output_map(self.key_typ)(
                                plt.Force(OVar(&#34;key&#34;))
                            ),
                        )
                    ],
                    plt.SndPair(
                        plt.FindList(
                            OVar(&#34;self&#34;),
                            OLambda(
                                [&#34;x&#34;],
                                plt.EqualsData(
                                    OVar(&#34;key_mapped&#34;),
                                    plt.FstPair(OVar(&#34;x&#34;)),
                                ),
                            ),
                            # this is a bit ugly... we wrap - only to later unwrap again
                            plt.MkPairData(
                                OVar(&#34;key_mapped&#34;),
                                transform_output_map(self.value_typ)(
                                    plt.Force(OVar(&#34;default&#34;))
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        )
    if attr == &#34;keys&#34;:
        return OLambda(
            [&#34;self&#34;, &#34;_&#34;],
            plt.MapList(
                OVar(&#34;self&#34;),
                OLambda(
                    [&#34;x&#34;],
                    transform_ext_params_map(self.key_typ)(plt.FstPair(OVar(&#34;x&#34;))),
                ),
                empty_list(self.key_typ),
            ),
        )
    if attr == &#34;values&#34;:
        return OLambda(
            [&#34;self&#34;, &#34;_&#34;],
            plt.MapList(
                OVar(&#34;self&#34;),
                OLambda(
                    [&#34;x&#34;],
                    transform_ext_params_map(self.value_typ)(
                        plt.SndPair(OVar(&#34;x&#34;))
                    ),
                ),
                empty_list(self.value_typ),
            ),
        )
    if attr == &#34;items&#34;:
        return OLambda(
            [&#34;self&#34;, &#34;_&#34;],
            OVar(&#34;self&#34;),
        )
    raise NotImplementedError(f&#34;Attribute &#39;{attr}&#39; of Dict is unknown.&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.DictType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; &#34;Type&#34;:
    if attr == &#34;get&#34;:
        return InstanceType(
            FunctionType(frozenlist([self.key_typ, self.value_typ]), self.value_typ)
        )
    if attr == &#34;keys&#34;:
        return InstanceType(
            FunctionType(frozenlist([]), InstanceType(ListType(self.key_typ)))
        )
    if attr == &#34;values&#34;:
        return InstanceType(
            FunctionType(frozenlist([]), InstanceType(ListType(self.value_typ)))
        )
    if attr == &#34;items&#34;:
        return InstanceType(
            FunctionType(
                frozenlist([]),
                InstanceType(
                    ListType(InstanceType(PairType(self.key_typ, self.value_typ)))
                ),
            )
        )
    raise TypeInferenceError(
        f&#34;Type of attribute &#39;{attr}&#39; is unknown for type Dict.&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.DictType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.DictType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.DictType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.DictType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.DictType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.DictType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_only_attributes(self) -&gt; plt.AST:
    def CustomMapFilterList(
        l: plt.AST,
        filter_op: plt.AST,
        map_op: plt.AST,
        empty_list=plt.EmptyDataList(),
    ):
        from pluthon import (
            Apply,
            Lambda as PLambda,
            RecFun,
            IteNullList,
            Var as PVar,
            HeadList,
            Ite,
            TailList,
            PrependList,
            Let as PLet,
        )

        &#34;&#34;&#34;
        Apply a filter and a map function on each element in a list (throws out all that evaluate to false)
        Performs only a single pass and is hence much more efficient than filter + map
        &#34;&#34;&#34;
        return Apply(
            PLambda(
                [&#34;filter&#34;, &#34;map&#34;],
                RecFun(
                    PLambda(
                        [&#34;filtermap&#34;, &#34;xs&#34;],
                        IteNullList(
                            PVar(&#34;xs&#34;),
                            empty_list,
                            PLet(
                                [
                                    (&#34;head&#34;, HeadList(PVar(&#34;xs&#34;))),
                                    (&#34;tail&#34;, TailList(PVar(&#34;xs&#34;))),
                                ],
                                Ite(
                                    Apply(
                                        PVar(&#34;filter&#34;), PVar(&#34;head&#34;), PVar(&#34;tail&#34;)
                                    ),
                                    PrependList(
                                        Apply(PVar(&#34;map&#34;), PVar(&#34;head&#34;)),
                                        Apply(
                                            PVar(&#34;filtermap&#34;),
                                            PVar(&#34;filtermap&#34;),
                                            PVar(&#34;tail&#34;),
                                        ),
                                    ),
                                    Apply(
                                        PVar(&#34;filtermap&#34;),
                                        PVar(&#34;filtermap&#34;),
                                        PVar(&#34;tail&#34;),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
            filter_op,
            map_op,
            l,
        )

    mapped_attrs = CustomMapFilterList(
        OVar(&#34;self&#34;),
        OLambda(
            [&#34;h&#34;, &#34;t&#34;],
            OLet(
                [
                    (&#34;hfst&#34;, plt.FstPair(OVar(&#34;h&#34;))),
                ],
                plt.Not(
                    plt.AnyList(
                        OVar(&#34;t&#34;),
                        OLambda(
                            [&#34;e&#34;],
                            plt.EqualsData(OVar(&#34;hfst&#34;), plt.FstPair(OVar(&#34;e&#34;))),
                        ),
                    )
                ),
            ),
        ),
        OLambda(
            [&#34;v&#34;],
            plt.MkPairData(
                transform_output_map(self.key_typ)(
                    plt.Apply(
                        self.key_typ.copy_only_attributes(),
                        transform_ext_params_map(self.key_typ)(
                            plt.FstPair(OVar(&#34;v&#34;))
                        ),
                    )
                ),
                transform_output_map(self.value_typ)(
                    plt.Apply(
                        self.value_typ.copy_only_attributes(),
                        transform_ext_params_map(self.value_typ)(
                            plt.SndPair(OVar(&#34;v&#34;))
                        ),
                    )
                ),
            ),
        ),
        plt.EmptyDataPairList(),
    )
    return OLambda([&#34;self&#34;], mapped_attrs)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.DictType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return &#34;map&lt;&#34; + self.key_typ.id_map() + &#34;,&#34; + self.value_typ.id_map() + &#34;&gt;&#34;</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.DictType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return OLambda(
        [&#34;self&#34;],
        OLet(
            [
                (
                    &#34;g&#34;,
                    plt.RecFun(
                        OLambda(
                            [&#34;f&#34;, &#34;l&#34;],
                            OLet(
                                [
                                    (&#34;h&#34;, plt.HeadList(OVar(&#34;l&#34;))),
                                    (&#34;t&#34;, plt.TailList(OVar(&#34;l&#34;))),
                                ],
                                plt.ConcatString(
                                    plt.Apply(
                                        self.key_typ.stringify(recursive=True),
                                        transform_ext_params_map(self.key_typ)(
                                            plt.FstPair(OVar(&#34;h&#34;))
                                        ),
                                    ),
                                    plt.Text(&#34;: &#34;),
                                    plt.Apply(
                                        self.value_typ.stringify(recursive=True),
                                        transform_ext_params_map(self.value_typ)(
                                            plt.SndPair(OVar(&#34;h&#34;))
                                        ),
                                    ),
                                    plt.IteNullList(
                                        OVar(&#34;t&#34;),
                                        plt.Text(&#34;}&#34;),
                                        plt.AppendString(
                                            plt.Text(&#34;, &#34;),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;t&#34;),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        )
                    ),
                )
            ],
            plt.AppendString(
                plt.Text(&#34;{&#34;),
                plt.IteNullList(
                    OVar(&#34;self&#34;),
                    plt.Text(&#34;}&#34;),
                    plt.Apply(
                        OVar(&#34;g&#34;),
                        OVar(&#34;self&#34;),
                    ),
                ),
            ),
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.DictType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.DictType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.FunctionType"><code class="flex name class">
<span>class <span class="ident">FunctionType</span></span>
<span>(</span><span>argtyps:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>], rettyp:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>, bound_vars:Dict[str,<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]=&lt;factory&gt;, bind_self:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>FunctionType(argtyps: List[opshin.type_impls.Type], rettyp: opshin.type_impls.Type, bound_vars: Dict[str, opshin.type_impls.Type] = <factory>, bind_self: Optional[str] = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class FunctionType(ClassType):
    argtyps: typing.List[Type]
    rettyp: Type
    # A map from external variable names to their types when the function is defined
    bound_vars: typing.Dict[str, Type] = dataclasses.field(default_factory=frozendict)
    # Whether and under which name the function binds itself
    # The type of this variable is &#34;self&#34;
    bind_self: typing.Optional[str] = None

    def __post_init__(self):
        object.__setattr__(self, &#34;argtyps&#34;, frozenlist(self.argtyps))
        object.__setattr__(self, &#34;bound_vars&#34;, frozendict(self.bound_vars))

    def __ge__(self, other):
        return (
            isinstance(other, FunctionType)
            and len(self.argtyps) == len(other.argtyps)
            and all(a &gt;= oa for a, oa in zip(self.argtyps, other.argtyps))
            and self.bound_vars.keys() == other.bound_vars.keys()
            and all(sbv &gt;= other.bound_vars[k] for k, sbv in self.bound_vars.items())
            and self.bind_self == other.bind_self
            and other.rettyp &gt;= self.rettyp
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda([&#34;x&#34;], plt.Text(&#34;&lt;function&gt;&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.FunctionType.argtyps"><code class="name">var <span class="ident">argtyps</span> :List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.FunctionType.bind_self"><code class="name">var <span class="ident">bind_self</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.FunctionType.bound_vars"><code class="name">var <span class="ident">bound_vars</span> :Dict[str,<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.FunctionType.rettyp"><code class="name">var <span class="ident">rettyp</span> :<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.FunctionType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return OLambda([&#34;x&#34;], plt.Text(&#34;&lt;function&gt;&#34;))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.FunctionType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.FunctionType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.InaccessibleType"><code class="flex name class">
<span>class <span class="ident">InaccessibleType</span></span>
</code></dt>
<dd>
<div class="desc"><p>A type that blocks overwriting of a function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InaccessibleType(ClassType):
    &#34;&#34;&#34;A type that blocks overwriting of a function&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.InaccessibleType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.InaccessibleType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.InstanceType"><code class="flex name class">
<span>class <span class="ident">InstanceType</span></span>
<span>(</span><span>typ:<a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>InstanceType(typ: opshin.type_impls.ClassType)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class InstanceType(Type):
    typ: ClassType

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return self.typ.id_map(skip_constructor=skip_constructor)

    def constr_type(self) -&gt; FunctionType:
        raise TypeInferenceError(f&#34;Can not construct an instance {self}&#34;)

    def constr(self) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not construct an instance {self}&#34;)

    def attribute_type(self, attr) -&gt; Type:
        return self.typ.attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        return self.typ.attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, InstanceType):
            return self.typ.cmp(op, o.typ)
        return super().cmp(op, o)

    def __ge__(self, other):
        return isinstance(other, InstanceType) and self.typ &gt;= other.typ

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return self.typ.stringify(recursive=recursive)

    def copy_only_attributes(self) -&gt; plt.AST:
        return self.typ.copy_only_attributes()

    def binop_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        return self.typ.binop_type(binop, other)

    def binop(self, binop: operator, other: AST) -&gt; plt.AST:
        return self.typ.binop(binop, other)

    def unop_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        return self.typ.unop_type(unop)

    def unop(self, unop: unaryop) -&gt; plt.AST:
        return self.typ.unop(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.PolymorphicFunctionInstanceType" href="#opshin.type_impls.PolymorphicFunctionInstanceType">PolymorphicFunctionInstanceType</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.InstanceType.typ"><code class="name">var <span class="ident">typ</span> :<a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.InstanceType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.attribute" href="#opshin.type_impls.Type.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    return self.typ.attribute(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.attribute_type" href="#opshin.type_impls.Type.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; Type:
    return self.typ.attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.binop" href="#opshin.type_impls.Type.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def binop(self, binop: operator, other: AST) -&gt; plt.AST:
    return self.typ.binop(binop, other)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.binop_type" href="#opshin.type_impls.Type.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def binop_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
    return self.typ.binop_type(binop, other)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.cmp" href="#opshin.type_impls.Type.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    if isinstance(o, InstanceType):
        return self.typ.cmp(op, o.typ)
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.constr" href="#opshin.type_impls.Type.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    raise NotImplementedError(f&#34;Can not construct an instance {self}&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.constr_type" href="#opshin.type_impls.Type.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; FunctionType:
    raise TypeInferenceError(f&#34;Can not construct an instance {self}&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.copy_only_attributes" href="#opshin.type_impls.Type.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Pluthon function that returns a copy of only the attributes of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_only_attributes(self) -&gt; plt.AST:
    return self.typ.copy_only_attributes()</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.id_map" href="#opshin.type_impls.Type.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return self.typ.id_map(skip_constructor=skip_constructor)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.stringify" href="#opshin.type_impls.Type.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return self.typ.stringify(recursive=recursive)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.unop" href="#opshin.type_impls.Type.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unop(self, unop: unaryop) -&gt; plt.AST:
    return self.typ.unop(unop)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.InstanceType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code>.<code><a title="opshin.type_impls.Type.unop_type" href="#opshin.type_impls.Type.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unop_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
    return self.typ.unop_type(unop)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.IntImpl"><code class="flex name class">
<span>class <span class="ident">IntImpl</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;int&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only create ints from instances&#34;
        assert any(
            isinstance(typ.typ, t) for t in (IntegerType, StringType, BoolType)
        ), &#34;Can only create integers from int, str or bool&#34;
        return FunctionType(args, IntegerInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only create ints from instances&#34;
        if isinstance(arg.typ, IntegerType):
            return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
        elif isinstance(arg.typ, BoolType):
            return OLambda(
                [&#34;x&#34;], plt.IfThenElse(OVar(&#34;x&#34;), plt.Integer(1), plt.Integer(0))
            )
        elif isinstance(arg.typ, StringType):
            return OLambda(
                [&#34;x&#34;],
                OLet(
                    [
                        (&#34;e&#34;, plt.EncodeUtf8(OVar(&#34;x&#34;))),
                        (&#34;len&#34;, plt.LengthOfByteString(OVar(&#34;e&#34;))),
                        (
                            &#34;first_int&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Integer(0), OVar(&#34;len&#34;)),
                                plt.IndexByteString(OVar(&#34;e&#34;), plt.Integer(0)),
                                plt.Integer(ord(&#34;_&#34;)),
                            ),
                        ),
                        (
                            &#34;last_int&#34;,
                            plt.IndexByteString(
                                OVar(&#34;e&#34;),
                                plt.SubtractInteger(OVar(&#34;len&#34;), plt.Integer(1)),
                            ),
                        ),
                        (
                            &#34;fold_start&#34;,
                            OLambda(
                                [&#34;start&#34;],
                                plt.FoldList(
                                    plt.Range(OVar(&#34;len&#34;), OVar(&#34;start&#34;)),
                                    OLambda(
                                        [&#34;s&#34;, &#34;i&#34;],
                                        OLet(
                                            [
                                                (
                                                    &#34;b&#34;,
                                                    plt.IndexByteString(
                                                        OVar(&#34;e&#34;), OVar(&#34;i&#34;)
                                                    ),
                                                )
                                            ],
                                            plt.Ite(
                                                plt.EqualsInteger(
                                                    OVar(&#34;b&#34;), plt.Integer(ord(&#34;_&#34;))
                                                ),
                                                OVar(&#34;s&#34;),
                                                plt.Ite(
                                                    plt.Or(
                                                        plt.LessThanInteger(
                                                            OVar(&#34;b&#34;),
                                                            plt.Integer(ord(&#34;0&#34;)),
                                                        ),
                                                        plt.LessThanInteger(
                                                            plt.Integer(ord(&#34;9&#34;)),
                                                            OVar(&#34;b&#34;),
                                                        ),
                                                    ),
                                                    plt.TraceError(
                                                        &#34;ValueError: invalid literal for int() with base 10&#34;
                                                    ),
                                                    plt.AddInteger(
                                                        plt.SubtractInteger(
                                                            OVar(&#34;b&#34;),
                                                            plt.Integer(ord(&#34;0&#34;)),
                                                        ),
                                                        plt.MultiplyInteger(
                                                            OVar(&#34;s&#34;),
                                                            plt.Integer(10),
                                                        ),
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                    plt.Integer(0),
                                ),
                            ),
                        ),
                    ],
                    plt.Ite(
                        plt.Or(
                            plt.Or(
                                plt.EqualsInteger(
                                    OVar(&#34;first_int&#34;),
                                    plt.Integer(ord(&#34;_&#34;)),
                                ),
                                plt.EqualsInteger(
                                    OVar(&#34;last_int&#34;),
                                    plt.Integer(ord(&#34;_&#34;)),
                                ),
                            ),
                            plt.And(
                                plt.EqualsInteger(OVar(&#34;len&#34;), plt.Integer(1)),
                                plt.Or(
                                    plt.EqualsInteger(
                                        OVar(&#34;first_int&#34;),
                                        plt.Integer(ord(&#34;-&#34;)),
                                    ),
                                    plt.EqualsInteger(
                                        OVar(&#34;first_int&#34;),
                                        plt.Integer(ord(&#34;+&#34;)),
                                    ),
                                ),
                            ),
                        ),
                        plt.TraceError(
                            &#34;ValueError: invalid literal for int() with base 10&#34;
                        ),
                        plt.Ite(
                            plt.EqualsInteger(
                                OVar(&#34;first_int&#34;),
                                plt.Integer(ord(&#34;-&#34;)),
                            ),
                            plt.Negate(
                                plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(1)),
                            ),
                            plt.Ite(
                                plt.EqualsInteger(
                                    OVar(&#34;first_int&#34;),
                                    plt.Integer(ord(&#34;+&#34;)),
                                ),
                                plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(1)),
                                plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(0)),
                            ),
                        ),
                    ),
                ),
            )
        else:
            raise NotImplementedError(
                f&#34;Can not derive integer from type {arg.typ.__name__}&#34;
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.IntImpl.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    arg = args[0]
    assert isinstance(arg, InstanceType), &#34;Can only create ints from instances&#34;
    if isinstance(arg.typ, IntegerType):
        return OLambda([&#34;x&#34;], OVar(&#34;x&#34;))
    elif isinstance(arg.typ, BoolType):
        return OLambda(
            [&#34;x&#34;], plt.IfThenElse(OVar(&#34;x&#34;), plt.Integer(1), plt.Integer(0))
        )
    elif isinstance(arg.typ, StringType):
        return OLambda(
            [&#34;x&#34;],
            OLet(
                [
                    (&#34;e&#34;, plt.EncodeUtf8(OVar(&#34;x&#34;))),
                    (&#34;len&#34;, plt.LengthOfByteString(OVar(&#34;e&#34;))),
                    (
                        &#34;first_int&#34;,
                        plt.Ite(
                            plt.LessThanInteger(plt.Integer(0), OVar(&#34;len&#34;)),
                            plt.IndexByteString(OVar(&#34;e&#34;), plt.Integer(0)),
                            plt.Integer(ord(&#34;_&#34;)),
                        ),
                    ),
                    (
                        &#34;last_int&#34;,
                        plt.IndexByteString(
                            OVar(&#34;e&#34;),
                            plt.SubtractInteger(OVar(&#34;len&#34;), plt.Integer(1)),
                        ),
                    ),
                    (
                        &#34;fold_start&#34;,
                        OLambda(
                            [&#34;start&#34;],
                            plt.FoldList(
                                plt.Range(OVar(&#34;len&#34;), OVar(&#34;start&#34;)),
                                OLambda(
                                    [&#34;s&#34;, &#34;i&#34;],
                                    OLet(
                                        [
                                            (
                                                &#34;b&#34;,
                                                plt.IndexByteString(
                                                    OVar(&#34;e&#34;), OVar(&#34;i&#34;)
                                                ),
                                            )
                                        ],
                                        plt.Ite(
                                            plt.EqualsInteger(
                                                OVar(&#34;b&#34;), plt.Integer(ord(&#34;_&#34;))
                                            ),
                                            OVar(&#34;s&#34;),
                                            plt.Ite(
                                                plt.Or(
                                                    plt.LessThanInteger(
                                                        OVar(&#34;b&#34;),
                                                        plt.Integer(ord(&#34;0&#34;)),
                                                    ),
                                                    plt.LessThanInteger(
                                                        plt.Integer(ord(&#34;9&#34;)),
                                                        OVar(&#34;b&#34;),
                                                    ),
                                                ),
                                                plt.TraceError(
                                                    &#34;ValueError: invalid literal for int() with base 10&#34;
                                                ),
                                                plt.AddInteger(
                                                    plt.SubtractInteger(
                                                        OVar(&#34;b&#34;),
                                                        plt.Integer(ord(&#34;0&#34;)),
                                                    ),
                                                    plt.MultiplyInteger(
                                                        OVar(&#34;s&#34;),
                                                        plt.Integer(10),
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                                plt.Integer(0),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.Or(
                        plt.Or(
                            plt.EqualsInteger(
                                OVar(&#34;first_int&#34;),
                                plt.Integer(ord(&#34;_&#34;)),
                            ),
                            plt.EqualsInteger(
                                OVar(&#34;last_int&#34;),
                                plt.Integer(ord(&#34;_&#34;)),
                            ),
                        ),
                        plt.And(
                            plt.EqualsInteger(OVar(&#34;len&#34;), plt.Integer(1)),
                            plt.Or(
                                plt.EqualsInteger(
                                    OVar(&#34;first_int&#34;),
                                    plt.Integer(ord(&#34;-&#34;)),
                                ),
                                plt.EqualsInteger(
                                    OVar(&#34;first_int&#34;),
                                    plt.Integer(ord(&#34;+&#34;)),
                                ),
                            ),
                        ),
                    ),
                    plt.TraceError(
                        &#34;ValueError: invalid literal for int() with base 10&#34;
                    ),
                    plt.Ite(
                        plt.EqualsInteger(
                            OVar(&#34;first_int&#34;),
                            plt.Integer(ord(&#34;-&#34;)),
                        ),
                        plt.Negate(
                            plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(1)),
                        ),
                        plt.Ite(
                            plt.EqualsInteger(
                                OVar(&#34;first_int&#34;),
                                plt.Integer(ord(&#34;+&#34;)),
                            ),
                            plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(1)),
                            plt.Apply(OVar(&#34;fold_start&#34;), plt.Integer(0)),
                        ),
                    ),
                ),
            ),
        )
    else:
        raise NotImplementedError(
            f&#34;Can not derive integer from type {arg.typ.__name__}&#34;
        )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.IntImpl.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) ><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    assert (
        len(args) == 1
    ), f&#34;&#39;int&#39; takes only one argument, but {len(args)} were given&#34;
    typ = args[0]
    assert isinstance(typ, InstanceType), &#34;Can only create ints from instances&#34;
    assert any(
        isinstance(typ.typ, t) for t in (IntegerType, StringType, BoolType)
    ), &#34;Can only create integers from int, str or bool&#34;
    return FunctionType(args, IntegerInstanceType)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.IntegerType"><code class="flex name class">
<span>class <span class="ident">IntegerType</span></span>
</code></dt>
<dd>
<div class="desc"><p>IntegerType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class IntegerType(AtomicType):
    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;int&#34;

    def constr_type(self) -&gt; InstanceType:
        return InstanceType(PolymorphicFunctionType(IntImpl()))

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Ite(
                        OVar(&#34;y&#34;),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsInteger)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger),
                            OVar(&#34;y&#34;),
                            OVar(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger)
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanInteger)
            if isinstance(op, Gt):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanInteger),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, IntegerType)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), OVar(&#34;x&#34;)
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), OVar(&#34;x&#34;)
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;x&#34;],
            plt.DecodeUtf8(
                OLet(
                    [
                        (
                            &#34;strlist&#34;,
                            plt.RecFun(
                                OLambda(
                                    [&#34;f&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        plt.LessThanEqualsInteger(
                                            OVar(&#34;i&#34;), plt.Integer(0)
                                        ),
                                        plt.EmptyIntegerList(),
                                        plt.MkCons(
                                            plt.AddInteger(
                                                plt.ModInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(10)
                                                ),
                                                plt.Integer(ord(&#34;0&#34;)),
                                            ),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                plt.DivideInteger(
                                                    OVar(&#34;i&#34;), plt.Integer(10)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;mkstr&#34;,
                            OLambda(
                                [&#34;i&#34;],
                                plt.FoldList(
                                    plt.Apply(OVar(&#34;strlist&#34;), OVar(&#34;i&#34;)),
                                    OLambda(
                                        [&#34;b&#34;, &#34;i&#34;],
                                        plt.ConsByteString(OVar(&#34;i&#34;), OVar(&#34;b&#34;)),
                                    ),
                                    plt.ByteString(b&#34;&#34;),
                                ),
                            ),
                        ),
                    ],
                    plt.Ite(
                        plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                        plt.ByteString(b&#34;0&#34;),
                        plt.Ite(
                            plt.LessThanInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                            plt.ConsByteString(
                                plt.Integer(ord(&#34;-&#34;)),
                                plt.Apply(OVar(&#34;mkstr&#34;), plt.Negate(OVar(&#34;x&#34;))),
                            ),
                            plt.Apply(OVar(&#34;mkstr&#34;), OVar(&#34;x&#34;)),
                        ),
                    ),
                )
            ),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if (
            isinstance(binop, Add)
            or isinstance(binop, Sub)
            or isinstance(binop, FloorDiv)
            or isinstance(binop, Mod)
            or isinstance(binop, Div)
            or isinstance(binop, Pow)
        ):
            if other == IntegerInstanceType:
                return IntegerType()
        if isinstance(binop, Mult):
            if other == IntegerInstanceType:
                return IntegerType()
            elif other == ByteStringInstanceType:
                return ByteStringType()
            elif other == StringInstanceType:
                return StringType()
        return super().binop_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if other.typ == IntegerInstanceType:
            if isinstance(binop, Add):
                return plt.AddInteger
            elif isinstance(binop, Sub):
                return plt.SubtractInteger
            elif isinstance(binop, FloorDiv):
                return plt.DivideInteger
            elif isinstance(binop, Mod):
                return plt.ModInteger
            elif isinstance(binop, Pow):
                return lambda x, y: OLet(
                    [(&#34;y&#34;, y)],
                    plt.Ite(
                        plt.LessThanInteger(OVar(&#34;y&#34;), plt.Integer(0)),
                        plt.TraceError(&#34;Negative exponentiation is not supported&#34;),
                        PowImpl(x, OVar(&#34;y&#34;)),
                    ),
                )

        if isinstance(binop, Mult):
            if other.typ == IntegerInstanceType:
                return plt.MultiplyInteger
            elif other.typ == ByteStringInstanceType:
                return lambda x, y: ByteStrIntMulImpl(y, x)
            elif other.typ == StringInstanceType:
                return lambda x, y: StrIntMulImpl(y, x)

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, USub):
            return IntegerType()
        elif isinstance(unop, UAdd):
            return IntegerType()
        elif isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, USub):
            return lambda x: plt.SubtractInteger(plt.Integer(0), x)
        if isinstance(unop, UAdd):
            return lambda x: x
        if isinstance(unop, Not):
            return lambda x: plt.EqualsInteger(x, plt.Integer(0))
        return super()._unop_fun(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></li>
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.IntegerType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute" href="#opshin.type_impls.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.IntegerType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute_type" href="#opshin.type_impls.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.IntegerType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop" href="#opshin.type_impls.AtomicType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.IntegerType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop_type" href="#opshin.type_impls.AtomicType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.IntegerType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.cmp" href="#opshin.type_impls.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    if isinstance(o, BoolType):
        if isinstance(op, Eq):
            # 1 == True
            # 0 == False
            # all other comparisons are False
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Ite(
                    OVar(&#34;y&#34;),
                    plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(1)),
                    plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                ),
            )
    if isinstance(o, IntegerType):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsInteger)
        if isinstance(op, NotEq):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsInteger),
                        OVar(&#34;y&#34;),
                        OVar(&#34;x&#34;),
                    )
                ),
            )
        if isinstance(op, LtE):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger)
        if isinstance(op, Lt):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanInteger)
        if isinstance(op, Gt):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanInteger),
                    OVar(&#34;y&#34;),
                    OVar(&#34;x&#34;),
                ),
            )
        if isinstance(op, GtE):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger),
                    OVar(&#34;y&#34;),
                    OVar(&#34;x&#34;),
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and isinstance(o.typ.typ, IntegerType)
    ):
        if isinstance(op, In):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.AnyList(
                    OVar(&#34;y&#34;),
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), OVar(&#34;x&#34;)
                    ),
                ),
            )
        if isinstance(op, NotIn):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), OVar(&#34;x&#34;)
                        ),
                    ),
                ),
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.IntegerType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr" href="#opshin.type_impls.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.IntegerType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr_type" href="#opshin.type_impls.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; InstanceType:
    return InstanceType(PolymorphicFunctionType(IntImpl()))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.IntegerType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.copy_only_attributes" href="#opshin.type_impls.AtomicType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.IntegerType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.id_map" href="#opshin.type_impls.AtomicType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return &#34;int&#34;</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.IntegerType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.stringify" href="#opshin.type_impls.AtomicType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return OLambda(
        [&#34;x&#34;],
        plt.DecodeUtf8(
            OLet(
                [
                    (
                        &#34;strlist&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;i&#34;],
                                plt.Ite(
                                    plt.LessThanEqualsInteger(
                                        OVar(&#34;i&#34;), plt.Integer(0)
                                    ),
                                    plt.EmptyIntegerList(),
                                    plt.MkCons(
                                        plt.AddInteger(
                                            plt.ModInteger(
                                                OVar(&#34;i&#34;), plt.Integer(10)
                                            ),
                                            plt.Integer(ord(&#34;0&#34;)),
                                        ),
                                        plt.Apply(
                                            OVar(&#34;f&#34;),
                                            OVar(&#34;f&#34;),
                                            plt.DivideInteger(
                                                OVar(&#34;i&#34;), plt.Integer(10)
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;mkstr&#34;,
                        OLambda(
                            [&#34;i&#34;],
                            plt.FoldList(
                                plt.Apply(OVar(&#34;strlist&#34;), OVar(&#34;i&#34;)),
                                OLambda(
                                    [&#34;b&#34;, &#34;i&#34;],
                                    plt.ConsByteString(OVar(&#34;i&#34;), OVar(&#34;b&#34;)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.EqualsInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                    plt.ByteString(b&#34;0&#34;),
                    plt.Ite(
                        plt.LessThanInteger(OVar(&#34;x&#34;), plt.Integer(0)),
                        plt.ConsByteString(
                            plt.Integer(ord(&#34;-&#34;)),
                            plt.Apply(OVar(&#34;mkstr&#34;), plt.Negate(OVar(&#34;x&#34;))),
                        ),
                        plt.Apply(OVar(&#34;mkstr&#34;), OVar(&#34;x&#34;)),
                    ),
                ),
            )
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.IntegerType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop" href="#opshin.type_impls.AtomicType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.IntegerType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop_type" href="#opshin.type_impls.AtomicType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.ListType"><code class="flex name class">
<span>class <span class="ident">ListType</span></span>
<span>(</span><span>typ:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>ListType(typ: opshin.type_impls.Type)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class ListType(ClassType):
    typ: Type

    def __ge__(self, other):
        return isinstance(other, ListType) and self.typ &gt;= other.typ

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;list&lt;&#34; + self.typ.id_map() + &#34;&gt;&#34;

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;index&#34;:
            return InstanceType(
                FunctionType(frozenlist([self.typ]), IntegerInstanceType)
            )
        super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;index&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;x&#34;],
                OLet(
                    [(&#34;x&#34;, plt.Force(OVar(&#34;x&#34;)))],
                    plt.Apply(
                        plt.RecFun(
                            OLambda(
                                [&#34;index&#34;, &#34;xs&#34;, &#34;a&#34;],
                                plt.IteNullList(
                                    OVar(&#34;xs&#34;),
                                    plt.TraceError(&#34;Did not find element in list&#34;),
                                    plt.Ite(
                                        plt.EqualsInteger(
                                            OVar(&#34;x&#34;), plt.HeadList(OVar(&#34;xs&#34;))
                                        ),
                                        OVar(&#34;a&#34;),
                                        plt.Apply(
                                            OVar(&#34;index&#34;),
                                            OVar(&#34;index&#34;),
                                            plt.TailList(OVar(&#34;xs&#34;)),
                                            plt.AddInteger(OVar(&#34;a&#34;), plt.Integer(1)),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        OVar(&#34;self&#34;),
                        plt.Integer(0),
                    ),
                ),
            )
        super().attribute(attr)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [
                    (
                        &#34;g&#34;,
                        plt.RecFun(
                            OLambda(
                                [&#34;f&#34;, &#34;l&#34;],
                                plt.AppendString(
                                    plt.Apply(
                                        self.typ.stringify(recursive=True),
                                        plt.HeadList(OVar(&#34;l&#34;)),
                                    ),
                                    OLet(
                                        [(&#34;t&#34;, plt.TailList(OVar(&#34;l&#34;)))],
                                        plt.IteNullList(
                                            OVar(&#34;t&#34;),
                                            plt.Text(&#34;]&#34;),
                                            plt.AppendString(
                                                plt.Text(&#34;, &#34;),
                                                plt.Apply(
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;f&#34;),
                                                    OVar(&#34;t&#34;),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            )
                        ),
                    )
                ],
                plt.AppendString(
                    plt.Text(&#34;[&#34;),
                    plt.IteNullList(
                        OVar(&#34;self&#34;),
                        plt.Text(&#34;]&#34;),
                        plt.Apply(
                            OVar(&#34;g&#34;),
                            OVar(&#34;self&#34;),
                        ),
                    ),
                ),
            ),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        mapped_attrs = plt.MapList(
            OVar(&#34;self&#34;),
            OLambda(
                [&#34;v&#34;],
                transform_output_map(self.typ)(
                    plt.Apply(
                        self.typ.copy_only_attributes(),
                        transform_ext_params_map(self.typ)(OVar(&#34;v&#34;)),
                    )
                ),
            ),
            plt.EmptyDataList(),
        )
        return OLambda([&#34;self&#34;], mapped_attrs)

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if isinstance(other, InstanceType) and isinstance(other.typ, ListType):
                other_typ = other.typ
                assert (
                    self.typ &gt;= other_typ.typ or other_typ.typ &gt;= self.typ
                ), f&#34;Types of lists {self.typ} and {other_typ.typ} are not compatible&#34;
                return ListType(
                    self.typ if self.typ &gt;= other_typ.typ else other_typ.typ
                )
        return super()._binop_return_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if isinstance(binop, Add):
            if isinstance(other.typ, InstanceType) and isinstance(
                other.typ.typ, ListType
            ):
                return plt.AppendList

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.IteNullList(x, plt.Bool(True), plt.Bool(False))
        return super()._unop_fun(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.ListType.typ"><code class="name">var <span class="ident">typ</span> :<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.ListType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    if attr == &#34;index&#34;:
        return OLambda(
            [&#34;self&#34;, &#34;x&#34;],
            OLet(
                [(&#34;x&#34;, plt.Force(OVar(&#34;x&#34;)))],
                plt.Apply(
                    plt.RecFun(
                        OLambda(
                            [&#34;index&#34;, &#34;xs&#34;, &#34;a&#34;],
                            plt.IteNullList(
                                OVar(&#34;xs&#34;),
                                plt.TraceError(&#34;Did not find element in list&#34;),
                                plt.Ite(
                                    plt.EqualsInteger(
                                        OVar(&#34;x&#34;), plt.HeadList(OVar(&#34;xs&#34;))
                                    ),
                                    OVar(&#34;a&#34;),
                                    plt.Apply(
                                        OVar(&#34;index&#34;),
                                        OVar(&#34;index&#34;),
                                        plt.TailList(OVar(&#34;xs&#34;)),
                                        plt.AddInteger(OVar(&#34;a&#34;), plt.Integer(1)),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    OVar(&#34;self&#34;),
                    plt.Integer(0),
                ),
            ),
        )
    super().attribute(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ListType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; &#34;Type&#34;:
    if attr == &#34;index&#34;:
        return InstanceType(
            FunctionType(frozenlist([self.typ]), IntegerInstanceType)
        )
    super().attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ListType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.ListType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.ListType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.ListType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.ListType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.ListType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_only_attributes(self) -&gt; plt.AST:
    mapped_attrs = plt.MapList(
        OVar(&#34;self&#34;),
        OLambda(
            [&#34;v&#34;],
            transform_output_map(self.typ)(
                plt.Apply(
                    self.typ.copy_only_attributes(),
                    transform_ext_params_map(self.typ)(OVar(&#34;v&#34;)),
                )
            ),
        ),
        plt.EmptyDataList(),
    )
    return OLambda([&#34;self&#34;], mapped_attrs)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ListType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return &#34;list&lt;&#34; + self.typ.id_map() + &#34;&gt;&#34;</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ListType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return OLambda(
        [&#34;self&#34;],
        OLet(
            [
                (
                    &#34;g&#34;,
                    plt.RecFun(
                        OLambda(
                            [&#34;f&#34;, &#34;l&#34;],
                            plt.AppendString(
                                plt.Apply(
                                    self.typ.stringify(recursive=True),
                                    plt.HeadList(OVar(&#34;l&#34;)),
                                ),
                                OLet(
                                    [(&#34;t&#34;, plt.TailList(OVar(&#34;l&#34;)))],
                                    plt.IteNullList(
                                        OVar(&#34;t&#34;),
                                        plt.Text(&#34;]&#34;),
                                        plt.AppendString(
                                            plt.Text(&#34;, &#34;),
                                            plt.Apply(
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;f&#34;),
                                                OVar(&#34;t&#34;),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        )
                    ),
                )
            ],
            plt.AppendString(
                plt.Text(&#34;[&#34;),
                plt.IteNullList(
                    OVar(&#34;self&#34;),
                    plt.Text(&#34;]&#34;),
                    plt.Apply(
                        OVar(&#34;g&#34;),
                        OVar(&#34;self&#34;),
                    ),
                ),
            ),
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.ListType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.ListType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.PairType"><code class="flex name class">
<span>class <span class="ident">PairType</span></span>
<span>(</span><span>l_typ:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>, r_typ:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An internal type representing built-in PlutusData pairs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class PairType(ClassType):
    &#34;&#34;&#34;An internal type representing built-in PlutusData pairs&#34;&#34;&#34;

    l_typ: Type
    r_typ: Type

    def __ge__(self, other):
        return isinstance(other, PairType) and all(
            t &gt;= ot
            for t, ot in zip((self.l_typ, self.r_typ), (other.l_typ, other.r_typ))
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        tuple_content = plt.ConcatString(
            plt.Apply(
                self.l_typ.stringify(recursive=True),
                transform_ext_params_map(self.l_typ)(plt.FstPair(OVar(&#34;self&#34;))),
            ),
            plt.Text(&#34;, &#34;),
            plt.Apply(
                self.r_typ.stringify(recursive=True),
                transform_ext_params_map(self.r_typ)(plt.SndPair(OVar(&#34;self&#34;))),
            ),
        )
        return OLambda(
            [&#34;self&#34;],
            plt.ConcatString(plt.Text(&#34;(&#34;), tuple_content, plt.Text(&#34;)&#34;)),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.PairType.l_typ"><code class="name">var <span class="ident">l_typ</span> :<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.PairType.r_typ"><code class="name">var <span class="ident">r_typ</span> :<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.PairType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.PairType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.PairType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.PairType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.PairType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.PairType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.PairType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.PairType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.PairType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.PairType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    tuple_content = plt.ConcatString(
        plt.Apply(
            self.l_typ.stringify(recursive=True),
            transform_ext_params_map(self.l_typ)(plt.FstPair(OVar(&#34;self&#34;))),
        ),
        plt.Text(&#34;, &#34;),
        plt.Apply(
            self.r_typ.stringify(recursive=True),
            transform_ext_params_map(self.r_typ)(plt.SndPair(OVar(&#34;self&#34;))),
        ),
    )
    return OLambda(
        [&#34;self&#34;],
        plt.ConcatString(plt.Text(&#34;(&#34;), tuple_content, plt.Text(&#34;)&#34;)),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.PairType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.PairType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.PolymorphicFunction"><code class="flex name class">
<span>class <span class="ident">PolymorphicFunction</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolymorphicFunction:
    def __new__(meta, *args, **kwargs):
        klass = super().__new__(meta)

        for key in [&#34;impl_from_args&#34;]:
            value = getattr(klass, key)
            wrapped = patternize(value)
            object.__setattr__(klass, key, wrapped)

        return klass

    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        raise NotImplementedError()

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.fun_impls.LenImpl" href="fun_impls.html#opshin.fun_impls.LenImpl">LenImpl</a></li>
<li><a title="opshin.fun_impls.PrintImpl" href="fun_impls.html#opshin.fun_impls.PrintImpl">PrintImpl</a></li>
<li><a title="opshin.fun_impls.ReversedImpl" href="fun_impls.html#opshin.fun_impls.ReversedImpl">ReversedImpl</a></li>
<li><a title="opshin.rewrite.rewrite_import_integrity_check.IntegrityCheckImpl" href="rewrite/rewrite_import_integrity_check.html#opshin.rewrite.rewrite_import_integrity_check.IntegrityCheckImpl">IntegrityCheckImpl</a></li>
<li><a title="opshin.type_impls.BoolImpl" href="#opshin.type_impls.BoolImpl">BoolImpl</a></li>
<li><a title="opshin.type_impls.BytesImpl" href="#opshin.type_impls.BytesImpl">BytesImpl</a></li>
<li><a title="opshin.type_impls.IntImpl" href="#opshin.type_impls.IntImpl">IntImpl</a></li>
<li><a title="opshin.type_impls.StrImpl" href="#opshin.type_impls.StrImpl">StrImpl</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.PolymorphicFunction.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.PolymorphicFunction.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) ><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType"><code class="flex name class">
<span>class <span class="ident">PolymorphicFunctionInstanceType</span></span>
<span>(</span><span>typ:<a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a>, polymorphic_function:<a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>PolymorphicFunctionInstanceType(typ: opshin.type_impls.FunctionType, polymorphic_function: opshin.type_impls.PolymorphicFunction)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class PolymorphicFunctionInstanceType(InstanceType):
    typ: FunctionType
    polymorphic_function: PolymorphicFunction</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.polymorphic_function"><code class="name">var <span class="ident">polymorphic_function</span> :<a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.typ"><code class="name">var <span class="ident">typ</span> :<a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.attribute" href="#opshin.type_impls.InstanceType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.attribute_type" href="#opshin.type_impls.InstanceType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.binop" href="#opshin.type_impls.InstanceType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.binop_type" href="#opshin.type_impls.InstanceType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.cmp" href="#opshin.type_impls.InstanceType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.constr" href="#opshin.type_impls.InstanceType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.constr_type" href="#opshin.type_impls.InstanceType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.copy_only_attributes" href="#opshin.type_impls.InstanceType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Pluthon function that returns a copy of only the attributes of the object</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.id_map" href="#opshin.type_impls.InstanceType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.stringify" href="#opshin.type_impls.InstanceType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.unop" href="#opshin.type_impls.InstanceType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionInstanceType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code>.<code><a title="opshin.type_impls.InstanceType.unop_type" href="#opshin.type_impls.InstanceType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType"><code class="flex name class">
<span>class <span class="ident">PolymorphicFunctionType</span></span>
<span>(</span><span>polymorphic_function:<a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A special type of builtin that may act differently on different parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class PolymorphicFunctionType(ClassType):
    &#34;&#34;&#34;A special type of builtin that may act differently on different parameters&#34;&#34;&#34;

    polymorphic_function: PolymorphicFunction

    def __ge__(self, other):
        return (
            isinstance(other, PolymorphicFunctionType)
            and self.polymorphic_function == other.polymorphic_function
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.PolymorphicFunctionType.polymorphic_function"><code class="name">var <span class="ident">polymorphic_function</span> :<a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.PolymorphicFunctionType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.PolymorphicFunctionType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.Record"><code class="flex name class">
<span>class <span class="ident">Record</span></span>
<span>(</span><span>name:str, orig_name:str, constructor:int, fields:Union[List[Tuple[str,<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]],frozenlist2.frozenlist])</span>
</code></dt>
<dd>
<div class="desc"><p>Record(name: str, orig_name: str, constructor: int, fields: Union[List[Tuple[str, opshin.type_impls.Type]], frozenlist2.frozenlist])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class Record:
    name: str
    orig_name: str
    constructor: int
    fields: typing.Union[typing.List[typing.Tuple[str, Type]], frozenlist]

    def __post_init__(self):
        object.__setattr__(self, &#34;fields&#34;, frozenlist(self.fields))

    def __ge__(self, other):
        if not isinstance(other, Record):
            return False
        return (
            self.constructor == other.constructor
            and len(self.fields) == len(other.fields)
            and all(a &gt;= b for a, b in zip(self.fields, other.fields))
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.Record.constructor"><code class="name">var <span class="ident">constructor</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.Record.fields"><code class="name">var <span class="ident">fields</span> :Union[List[Tuple[str,<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]],frozenlist2.frozenlist]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.Record.name"><code class="name">var <span class="ident">name</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.type_impls.Record.orig_name"><code class="name">var <span class="ident">orig_name</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.RecordType"><code class="flex name class">
<span>class <span class="ident">RecordType</span></span>
<span>(</span><span>record:<a title="opshin.type_impls.Record" href="#opshin.type_impls.Record">Record</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>RecordType(record: opshin.type_impls.Record)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class RecordType(ClassType):
    record: Record

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return (
            &#34;cons[&#34;
            + self.record.orig_name
            + &#34;](&#34;
            + (str(self.record.constructor) if not skip_constructor else &#34;_&#34;)
            + &#34;;&#34;
            + &#34;,&#34;.join(name + &#34;:&#34; + type.id_map() for name, type in self.record.fields)
            + &#34;)&#34;
        )

    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(
            FunctionType(
                frozenlist([f[1] for f in self.record.fields]), InstanceType(self)
            )
        )

    def constr(self) -&gt; plt.AST:
        # wrap all constructor values to PlutusData
        build_constr_params = plt.EmptyDataList()
        for n, t in reversed(self.record.fields):
            build_constr_params = plt.MkCons(
                transform_output_map(t)(plt.Force(OVar(n))), build_constr_params
            )
        # then build a constr type with this PlutusData
        return SafeOLambda(
            [n for n, _ in self.record.fields],
            plt.ConstrData(plt.Integer(self.record.constructor), build_constr_params),
        )

    def attribute_type(self, attr: str) -&gt; Type:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        for n, t in self.record.fields:
            if n == attr:
                return t
        if attr == &#34;to_cbor&#34;:
            return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
        raise TypeInferenceError(
            f&#34;Type {self.record.name} does not have attribute {attr}&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return OLambda(
                [&#34;self&#34;],
                plt.Constructor(OVar(&#34;self&#34;)),
            )
        if attr in (n for n, t in self.record.fields):
            attr_typ = self.attribute_type(attr)
            pos = next(i for i, (n, _) in enumerate(self.record.fields) if n == attr)
            # access to normal fields
            return OLambda(
                [&#34;self&#34;],
                transform_ext_params_map(attr_typ)(
                    plt.ConstantNthField(
                        OVar(&#34;self&#34;),
                        pos,
                    ),
                ),
            )
        if attr == &#34;to_cbor&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.SerialiseData(
                    OVar(&#34;self&#34;),
                ),
            )
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        if (
            (
                isinstance(o, RecordType)
                and (self.record &gt;= o.record or o.record &gt;= self.record)
            )
            or (
                isinstance(o, UnionType) and any(self &gt;= o or self &gt;= o for o in o.typs)
            )
            or isinstance(o, AnyType)
        ):
            # Note that comparison with AnyType is actually fine because both are Data
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                            OVar(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and (o.typ.typ &gt;= self or self &gt;= o.typ.typ)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def __ge__(self, other):
        # Can only substitute for its own type, records need to be equal
        # if someone wants to be funny, they can implement &lt;= to be true if all fields match up to some point
        return isinstance(other, self.__class__) and self.record &gt;= other.record

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        &#34;&#34;&#34;Returns a stringified version of the object&#34;&#34;&#34;
        map_fields = plt.Text(&#34;)&#34;)
        if self.record.fields:
            # TODO access to fields is a bit inefficient but this is debugging stuff only anyways
            pos = len(self.record.fields) - 1
            for field_name, field_type in reversed(self.record.fields[1:]):
                map_fields = plt.ConcatString(
                    plt.Text(f&#34;, {field_name}=&#34;),
                    plt.Apply(
                        field_type.stringify(recursive=True),
                        transform_ext_params_map(field_type)(
                            plt.ConstantNthField(OVar(&#34;self&#34;), pos)
                        ),
                    ),
                    map_fields,
                )
                pos -= 1
            map_fields = plt.ConcatString(
                plt.Text(f&#34;{self.record.fields[0][0]}=&#34;),
                plt.Apply(
                    self.record.fields[0][1].stringify(recursive=True),
                    transform_ext_params_map(self.record.fields[0][1])(
                        plt.ConstantNthField(OVar(&#34;self&#34;), pos)
                    ),
                ),
                map_fields,
            )
        return OLambda(
            [&#34;self&#34;],
            plt.AppendString(plt.Text(f&#34;{self.record.orig_name}(&#34;), map_fields),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        copied_attributes = plt.EmptyDataList()
        for attr_name, attr_type in reversed(self.record.fields):
            copied_attributes = OLet(
                [
                    (&#34;f&#34;, plt.HeadList(OVar(&#34;fs&#34;))),
                    (&#34;fs&#34;, plt.TailList(OVar(&#34;fs&#34;))),
                ],
                plt.MkCons(
                    transform_output_map(attr_type)(
                        plt.Apply(
                            attr_type.copy_only_attributes(),
                            transform_ext_params_map(attr_type)(
                                OVar(&#34;f&#34;),
                            ),
                        )
                    ),
                    copied_attributes,
                ),
            )
        copied_attributes = OLet(
            [(&#34;fs&#34;, plt.Fields(OVar(&#34;self&#34;)))],
            copied_attributes,
        )
        return OLambda(
            [&#34;self&#34;],
            plt.ConstrData(
                plt.Integer(self.record.constructor),
                copied_attributes,
            ),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.RecordType.record"><code class="name">var <span class="ident">record</span> :<a title="opshin.type_impls.Record" href="#opshin.type_impls.Record">Record</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.RecordType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr:str) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The attributes of this class. Need to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr: str) -&gt; plt.AST:
    &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
    if attr == &#34;CONSTR_ID&#34;:
        # access to constructor
        return OLambda(
            [&#34;self&#34;],
            plt.Constructor(OVar(&#34;self&#34;)),
        )
    if attr in (n for n, t in self.record.fields):
        attr_typ = self.attribute_type(attr)
        pos = next(i for i, (n, _) in enumerate(self.record.fields) if n == attr)
        # access to normal fields
        return OLambda(
            [&#34;self&#34;],
            transform_ext_params_map(attr_typ)(
                plt.ConstantNthField(
                    OVar(&#34;self&#34;),
                    pos,
                ),
            ),
        )
    if attr == &#34;to_cbor&#34;:
        return OLambda(
            [&#34;self&#34;, &#34;_&#34;],
            plt.SerialiseData(
                OVar(&#34;self&#34;),
            ),
        )
    raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr:str) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr: str) -&gt; Type:
    &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
    if attr == &#34;CONSTR_ID&#34;:
        return IntegerInstanceType
    for n, t in self.record.fields:
        if n == attr:
            return t
    if attr == &#34;to_cbor&#34;:
        return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
    raise TypeInferenceError(
        f&#34;Type {self.record.name} does not have attribute {attr}&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.RecordType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.RecordType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    # this will reject comparisons that will always be false - most likely due to faults during programming
    if (
        (
            isinstance(o, RecordType)
            and (self.record &gt;= o.record or o.record &gt;= self.record)
        )
        or (
            isinstance(o, UnionType) and any(self &gt;= o or self &gt;= o for o in o.typs)
        )
        or isinstance(o, AnyType)
    ):
        # Note that comparison with AnyType is actually fine because both are Data
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
        if isinstance(op, NotEq):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        OVar(&#34;x&#34;),
                        OVar(&#34;y&#34;),
                    )
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and (o.typ.typ &gt;= self or self &gt;= o.typ.typ)
    ):
        if isinstance(op, In):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.AnyList(
                    OVar(&#34;y&#34;),
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        OVar(&#34;x&#34;),
                    ),
                ),
            )
        if isinstance(op, NotIn):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                ),
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    # wrap all constructor values to PlutusData
    build_constr_params = plt.EmptyDataList()
    for n, t in reversed(self.record.fields):
        build_constr_params = plt.MkCons(
            transform_output_map(t)(plt.Force(OVar(n))), build_constr_params
        )
    # then build a constr type with this PlutusData
    return SafeOLambda(
        [n for n, _ in self.record.fields],
        plt.ConstrData(plt.Integer(self.record.constructor), build_constr_params),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; &#34;InstanceType&#34;:
    return InstanceType(
        FunctionType(
            frozenlist([f[1] for f in self.record.fields]), InstanceType(self)
        )
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_only_attributes(self) -&gt; plt.AST:
    copied_attributes = plt.EmptyDataList()
    for attr_name, attr_type in reversed(self.record.fields):
        copied_attributes = OLet(
            [
                (&#34;f&#34;, plt.HeadList(OVar(&#34;fs&#34;))),
                (&#34;fs&#34;, plt.TailList(OVar(&#34;fs&#34;))),
            ],
            plt.MkCons(
                transform_output_map(attr_type)(
                    plt.Apply(
                        attr_type.copy_only_attributes(),
                        transform_ext_params_map(attr_type)(
                            OVar(&#34;f&#34;),
                        ),
                    )
                ),
                copied_attributes,
            ),
        )
    copied_attributes = OLet(
        [(&#34;fs&#34;, plt.Fields(OVar(&#34;self&#34;)))],
        copied_attributes,
    )
    return OLambda(
        [&#34;self&#34;],
        plt.ConstrData(
            plt.Integer(self.record.constructor),
            copied_attributes,
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return (
        &#34;cons[&#34;
        + self.record.orig_name
        + &#34;](&#34;
        + (str(self.record.constructor) if not skip_constructor else &#34;_&#34;)
        + &#34;;&#34;
        + &#34;,&#34;.join(name + &#34;:&#34; + type.id_map() for name, type in self.record.fields)
        + &#34;)&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stringified version of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    &#34;&#34;&#34;Returns a stringified version of the object&#34;&#34;&#34;
    map_fields = plt.Text(&#34;)&#34;)
    if self.record.fields:
        # TODO access to fields is a bit inefficient but this is debugging stuff only anyways
        pos = len(self.record.fields) - 1
        for field_name, field_type in reversed(self.record.fields[1:]):
            map_fields = plt.ConcatString(
                plt.Text(f&#34;, {field_name}=&#34;),
                plt.Apply(
                    field_type.stringify(recursive=True),
                    transform_ext_params_map(field_type)(
                        plt.ConstantNthField(OVar(&#34;self&#34;), pos)
                    ),
                ),
                map_fields,
            )
            pos -= 1
        map_fields = plt.ConcatString(
            plt.Text(f&#34;{self.record.fields[0][0]}=&#34;),
            plt.Apply(
                self.record.fields[0][1].stringify(recursive=True),
                transform_ext_params_map(self.record.fields[0][1])(
                    plt.ConstantNthField(OVar(&#34;self&#34;), pos)
                ),
            ),
            map_fields,
        )
    return OLambda(
        [&#34;self&#34;],
        plt.AppendString(plt.Text(f&#34;{self.record.orig_name}(&#34;), map_fields),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.RecordType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.RecordType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.StrImpl"><code class="flex name class">
<span>class <span class="ident">StrImpl</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;str&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only stringify instances&#34;
        return FunctionType(args, StringInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only stringify instances&#34;
        return arg.typ.stringify()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.StrImpl.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    arg = args[0]
    assert isinstance(arg, InstanceType), &#34;Can only stringify instances&#34;
    return arg.typ.stringify()</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.StrImpl.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]) ><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    assert (
        len(args) == 1
    ), f&#34;&#39;str&#39; takes only one argument, but {len(args)} were given&#34;
    typ = args[0]
    assert isinstance(typ, InstanceType), &#34;Can only stringify instances&#34;
    return FunctionType(args, StringInstanceType)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.StringType"><code class="flex name class">
<span>class <span class="ident">StringType</span></span>
</code></dt>
<dd>
<div class="desc"><p>StringType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class StringType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(PolymorphicFunctionType(StrImpl()))

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;encode&#34;:
            return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;encode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return OLambda([&#34;x&#34;, &#34;_&#34;], plt.EncodeUtf8(OVar(&#34;x&#34;)))
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, StringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsString)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;], plt.Not(plt.EqualsString(OVar(&#34;x&#34;), OVar(&#34;y&#34;)))
                )
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        if recursive:
            # TODO this is not correct, as the string is not properly escaped
            return OLambda(
                [&#34;self&#34;],
                plt.ConcatString(plt.Text(&#34;&#39;&#34;), OVar(&#34;self&#34;), plt.Text(&#34;&#39;&#34;)),
            )
        else:
            return OLambda([&#34;self&#34;], OVar(&#34;self&#34;))

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if other == StringInstanceType:
                return StringType()
        if isinstance(binop, Mult):
            if other == IntegerInstanceType:
                return StringType()
        return super().binop_type(binop, other)

    def _binop_bin_fun(self, binop: operator, other: AST):
        if isinstance(binop, Add):
            if other.typ == StringInstanceType:
                return plt.AppendString
        if isinstance(binop, Mult):
            if other.typ == IntegerInstanceType:
                return StrIntMulImpl

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.EqualsInteger(
                plt.LengthOfByteString(plt.EncodeUtf8(x)), plt.Integer(0)
            )
        return super()._unop_fun(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></li>
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.StringType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute" href="#opshin.type_impls.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    if attr == &#34;encode&#34;:
        # No codec -&gt; only the default (utf8) is allowed
        return OLambda([&#34;x&#34;, &#34;_&#34;], plt.EncodeUtf8(OVar(&#34;x&#34;)))
    return super().attribute(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.StringType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute_type" href="#opshin.type_impls.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; Type:
    if attr == &#34;encode&#34;:
        return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
    return super().attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.StringType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop" href="#opshin.type_impls.AtomicType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.StringType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop_type" href="#opshin.type_impls.AtomicType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.StringType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.cmp" href="#opshin.type_impls.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, StringType):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsString)
        if isinstance(op, NotEq):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;], plt.Not(plt.EqualsString(OVar(&#34;x&#34;), OVar(&#34;y&#34;)))
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.StringType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr" href="#opshin.type_impls.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.StringType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr_type" href="#opshin.type_impls.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; InstanceType:
    return InstanceType(PolymorphicFunctionType(StrImpl()))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.StringType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.copy_only_attributes" href="#opshin.type_impls.AtomicType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.StringType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.id_map" href="#opshin.type_impls.AtomicType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.StringType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.stringify" href="#opshin.type_impls.AtomicType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    if recursive:
        # TODO this is not correct, as the string is not properly escaped
        return OLambda(
            [&#34;self&#34;],
            plt.ConcatString(plt.Text(&#34;&#39;&#34;), OVar(&#34;self&#34;), plt.Text(&#34;&#39;&#34;)),
        )
    else:
        return OLambda([&#34;self&#34;], OVar(&#34;self&#34;))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.StringType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop" href="#opshin.type_impls.AtomicType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.StringType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop_type" href="#opshin.type_impls.AtomicType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.TupleType"><code class="flex name class">
<span>class <span class="ident">TupleType</span></span>
<span>(</span><span>typs:List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>TupleType(typs: List[opshin.type_impls.Type])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class TupleType(ClassType):
    typs: typing.List[Type]

    def __ge__(self, other):
        return isinstance(other, TupleType) and all(
            t &gt;= ot for t, ot in zip(self.typs, other.typs)
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        if not self.typs:
            return OLambda(
                [&#34;self&#34;],
                plt.Text(&#34;()&#34;),
            )
        elif len(self.typs) == 1:
            tuple_content = plt.ConcatString(
                plt.Apply(
                    self.typs[0].stringify(recursive=True),
                    plt.FunctionalTupleAccess(OVar(&#34;self&#34;), 0, len(self.typs)),
                ),
                plt.Text(&#34;,&#34;),
            )
        else:
            tuple_content = plt.ConcatString(
                plt.Apply(
                    self.typs[0].stringify(recursive=True),
                    plt.FunctionalTupleAccess(OVar(&#34;self&#34;), 0, len(self.typs)),
                ),
            )
            for i, t in enumerate(self.typs[1:], start=1):
                tuple_content = plt.ConcatString(
                    tuple_content,
                    plt.Text(&#34;, &#34;),
                    plt.Apply(
                        t.stringify(recursive=True),
                        plt.FunctionalTupleAccess(OVar(&#34;self&#34;), i, len(self.typs)),
                    ),
                )
        return OLambda(
            [&#34;self&#34;],
            plt.ConcatString(plt.Text(&#34;(&#34;), tuple_content, plt.Text(&#34;)&#34;)),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        if isinstance(binop, Add):
            if isinstance(other, TupleType):
                return TupleType(self.typs + other.typs)
        return super()._binop_return_type(binop, other)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.TupleType.typs"><code class="name">var <span class="ident">typs</span> :List[<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.TupleType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
</dd>
<dt id="opshin.type_impls.TupleType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.TupleType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    if not self.typs:
        return OLambda(
            [&#34;self&#34;],
            plt.Text(&#34;()&#34;),
        )
    elif len(self.typs) == 1:
        tuple_content = plt.ConcatString(
            plt.Apply(
                self.typs[0].stringify(recursive=True),
                plt.FunctionalTupleAccess(OVar(&#34;self&#34;), 0, len(self.typs)),
            ),
            plt.Text(&#34;,&#34;),
        )
    else:
        tuple_content = plt.ConcatString(
            plt.Apply(
                self.typs[0].stringify(recursive=True),
                plt.FunctionalTupleAccess(OVar(&#34;self&#34;), 0, len(self.typs)),
            ),
        )
        for i, t in enumerate(self.typs[1:], start=1):
            tuple_content = plt.ConcatString(
                tuple_content,
                plt.Text(&#34;, &#34;),
                plt.Apply(
                    t.stringify(recursive=True),
                    plt.FunctionalTupleAccess(OVar(&#34;self&#34;), i, len(self.typs)),
                ),
            )
    return OLambda(
        [&#34;self&#34;],
        plt.ConcatString(plt.Text(&#34;(&#34;), tuple_content, plt.Text(&#34;)&#34;)),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.TupleType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.TupleType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.Type"><code class="flex name class">
<span>class <span class="ident">Type</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Type:
    def __new__(meta, *args, **kwargs):
        klass = super().__new__(meta)

        for key in [&#34;constr&#34;, &#34;attribute&#34;, &#34;cmp&#34;, &#34;stringify&#34;, &#34;copy_only_attributes&#34;]:
            value = getattr(klass, key)
            wrapped = patternize(value)
            object.__setattr__(klass, key, wrapped)

        return klass

    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        &#34;&#34;&#34;The type of the constructor for this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {self.__class__} does not have a constructor&#34;
        )

    def constr(self) -&gt; plt.AST:
        &#34;&#34;&#34;The constructor for this class&#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Constructor of {type(self).__name__} not implemented&#34;
        )

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {type(self).__name__} does not have attribute {attr}&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Needs to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Comparison {type(op).__name__} for {self.__class__.__name__} and {o.__class__.__name__} is not implemented. This is likely intended because it would always evaluate to False.&#34;
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        &#34;&#34;&#34;
        Returns a stringified version of the object

        The recursive parameter informs the method whether it was invoked recursively from another invokation
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;{type(self).__name__} can not be stringified&#34;)

    def copy_only_attributes(self) -&gt; plt.AST:
        &#34;&#34;&#34;
        Pluthon function that returns a copy of only the attributes of the object
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;{type(self).__name__} can not be copied&#34;)

    def binop_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Type of a binary operation between self and other.
        &#34;&#34;&#34;
        return FunctionType(
            [InstanceType(self), InstanceType(other)],
            InstanceType(self._binop_return_type(binop, other)),
        )

    def _binop_return_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Return the type of a binary operation between self and other
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} does not implement {binop.__class__.__name__}&#34;
        )

    def binop(self, binop: operator, other: AST) -&gt; plt.AST:
        &#34;&#34;&#34;
        Implements a binary operation between self and other
        &#34;&#34;&#34;
        return OLambda(
            [&#34;self&#34;, &#34;other&#34;],
            self._binop_bin_fun(binop, other)(OVar(&#34;self&#34;), OVar(&#34;other&#34;)),
        )

    def _binop_bin_fun(
        self, binop: operator, other: AST
    ) -&gt; Callable[[plt.AST, plt.AST], plt.AST]:
        &#34;&#34;&#34;
        Returns a binary function that implements the binary operation between self and other.
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} can not be used with operation {binop.__class__.__name__}&#34;
        )

    def unop_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Type of a unary operation on self.
        &#34;&#34;&#34;
        return FunctionType(
            [InstanceType(self)],
            InstanceType(self._unop_return_type(unop)),
        )

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;
        Return the type of a binary operation between self and other
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} does not implement {unop.__class__.__name__}&#34;
        )

    def unop(self, unop: unaryop) -&gt; plt.AST:
        &#34;&#34;&#34;
        Implements a unary operation on self
        &#34;&#34;&#34;
        return OLambda(
            [&#34;self&#34;],
            self._unop_fun(unop)(OVar(&#34;self&#34;)),
        )

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        &#34;&#34;&#34;
        Returns a unary function that implements the unary operation on self.
        &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;{type(self).__name__} can not be used with operation {unop.__class__.__name__}&#34;
        )

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        &#34;&#34;&#34;
        Returns a map from the constructor id to a descriptive typestring
        &#34;&#34;&#34;
        raise NotImplementedError(f&#34;Type {type(self).__name__} does not have a id map&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.Type.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    &#34;&#34;&#34;The attributes of this class. Needs to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
    raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<div class="desc"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; &#34;Type&#34;:
    &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
    raise TypeInferenceError(
        f&#34;Object of type {type(self).__name__} does not have attribute {attr}&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Implements a binary operation between self and other</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def binop(self, binop: operator, other: AST) -&gt; plt.AST:
    &#34;&#34;&#34;
    Implements a binary operation between self and other
    &#34;&#34;&#34;
    return OLambda(
        [&#34;self&#34;, &#34;other&#34;],
        self._binop_bin_fun(binop, other)(OVar(&#34;self&#34;), OVar(&#34;other&#34;)),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<div class="desc"><p>Type of a binary operation between self and other.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def binop_type(self, binop: operator, other: &#34;Type&#34;) -&gt; &#34;Type&#34;:
    &#34;&#34;&#34;
    Type of a binary operation between self and other.
    &#34;&#34;&#34;
    return FunctionType(
        [InstanceType(self), InstanceType(other)],
        InstanceType(self._binop_return_type(binop, other)),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    raise NotImplementedError(
        f&#34;Comparison {type(op).__name__} for {self.__class__.__name__} and {o.__class__.__name__} is not implemented. This is likely intended because it would always evaluate to False.&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    &#34;&#34;&#34;The constructor for this class&#34;&#34;&#34;
    raise NotImplementedError(
        f&#34;Constructor of {type(self).__name__} not implemented&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<div class="desc"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; &#34;InstanceType&#34;:
    &#34;&#34;&#34;The type of the constructor for this class&#34;&#34;&#34;
    raise TypeInferenceError(
        f&#34;Object of type {self.__class__} does not have a constructor&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Pluthon function that returns a copy of only the attributes of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_only_attributes(self) -&gt; plt.AST:
    &#34;&#34;&#34;
    Pluthon function that returns a copy of only the attributes of the object
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;{type(self).__name__} can not be copied&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    &#34;&#34;&#34;
    Returns a map from the constructor id to a descriptive typestring
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;Type {type(self).__name__} does not have a id map&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stringified version of the object</p>
<p>The recursive parameter informs the method whether it was invoked recursively from another invokation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    &#34;&#34;&#34;
    Returns a stringified version of the object

    The recursive parameter informs the method whether it was invoked recursively from another invokation
    &#34;&#34;&#34;
    raise NotImplementedError(f&#34;{type(self).__name__} can not be stringified&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Implements a unary operation on self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unop(self, unop: unaryop) -&gt; plt.AST:
    &#34;&#34;&#34;
    Implements a unary operation on self
    &#34;&#34;&#34;
    return OLambda(
        [&#34;self&#34;],
        self._unop_fun(unop)(OVar(&#34;self&#34;)),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.Type.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<div class="desc"><p>Type of a unary operation on self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unop_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
    &#34;&#34;&#34;
    Type of a unary operation on self.
    &#34;&#34;&#34;
    return FunctionType(
        [InstanceType(self)],
        InstanceType(self._unop_return_type(unop)),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.TypeInferenceError"><code class="flex name class">
<span>class <span class="ident">TypeInferenceError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Assertion failed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeInferenceError(AssertionError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.AssertionError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="opshin.type_impls.UnionType"><code class="flex name class">
<span>class <span class="ident">UnionType</span></span>
<span>(</span><span>typs:List[<a title="opshin.type_impls.RecordType" href="#opshin.type_impls.RecordType">RecordType</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>UnionType(typs: List[opshin.type_impls.RecordType])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class UnionType(ClassType):
    typs: typing.List[RecordType]

    def __post_init__(self):
        object.__setattr__(self, &#34;typs&#34;, frozenlist(self.typs))

    def id_map(self, skip_constructor: bool = False) -&gt; str:
        return &#34;union&lt;&#34; + &#34;,&#34;.join(t.id_map() for t in self.typs) + &#34;&gt;&#34;

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        # need to have a common field with the same name
        if all(attr in (n for n, t in x.record.fields) for x in self.typs):
            attr_types = OrderedSet(
                t for x in self.typs for n, t in x.record.fields if n == attr
            )
            for at in attr_types:
                # return the maximum element if there is one
                if all(at &gt;= at2 for at2 in attr_types):
                    return at
            # return the union type of all possible instantiations if all possible values are record types
            if all(
                isinstance(at, InstanceType) and isinstance(at.typ, RecordType)
                for at in attr_types
            ) and distinct([at.typ.record.constructor for at in attr_types]):
                return InstanceType(
                    UnionType(frozenlist([at.typ for at in attr_types]))
                )
            # return Anytype
            return InstanceType(AnyType())
        if attr == &#34;to_cbor&#34;:
            return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
        raise TypeInferenceError(
            f&#34;Can not access attribute {attr} of Union type. Cast to desired type with an &#39;if isinstance(_, _):&#39; branch.&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return OLambda(
                [&#34;self&#34;],
                plt.Constructor(OVar(&#34;self&#34;)),
            )
        # iterate through all names/types of the unioned records by position
        if any(attr in (n for n, t in r.record.fields) for r in self.typs):
            attr_typ = self.attribute_type(attr)
            pos_constrs = [
                (i, x.record.constructor)
                for x in self.typs
                for i, (n, t) in enumerate(x.record.fields)
                if n == attr
            ]
            pos_constrs = sorted(pos_constrs, key=lambda x: x[0])
            pos_constrs = [
                (pos, [c[1] for c in constrs])
                for (pos, constrs) in itertools.groupby(pos_constrs, key=lambda x: x[0])
            ]
            # largest group last so we save the comparisons for that
            pos_constrs = sorted(pos_constrs, key=lambda x: len(x[1]))
            # access to normal fields
            if not pos_constrs:
                pos_decisor = plt.TraceError(&#34;Invalid constructor&#34;)
            else:
                pos_decisor = plt.Integer(pos_constrs[-1][0])
                pos_constrs = pos_constrs[:-1]
            for pos, constrs in pos_constrs:
                assert constrs, &#34;Found empty constructors for a position&#34;
                constr_check = plt.EqualsInteger(
                    OVar(&#34;constr&#34;), plt.Integer(constrs[0])
                )
                for constr in constrs[1:]:
                    constr_check = plt.Or(
                        plt.EqualsInteger(OVar(&#34;constr&#34;), plt.Integer(constr)),
                        constr_check,
                    )
                pos_decisor = plt.Ite(
                    constr_check,
                    plt.Integer(pos),
                    pos_decisor,
                )
            return OLambda(
                [&#34;self&#34;],
                transform_ext_params_map(attr_typ)(
                    plt.NthField(
                        OVar(&#34;self&#34;),
                        OLet(
                            [(&#34;constr&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
                            pos_decisor,
                        ),
                    ),
                ),
            )
        if attr == &#34;to_cbor&#34;:
            return OLambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.SerialiseData(
                    OVar(&#34;self&#34;),
                ),
            )
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def __ge__(self, other):
        if isinstance(other, UnionType):
            return all(self &gt;= ot for ot in other.typs)
        return any(t &gt;= other for t in self.typs)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        # note we require that there is an overlapt between the possible types for unions
        if (isinstance(o, RecordType) and any(t &gt;= o or o &gt;= t for t in self.typs)) or (
            isinstance(o, UnionType)
            and any(t &gt;= ot or t &gt;= ot for t in self.typs for ot in o.typs)
        ):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                            OVar(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and any(o.typ.typ &gt;= t or t &gt;= o.typ.typ for t in self.typs)
        ):
            if isinstance(op, In):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                )
            if isinstance(op, NotIn):
                return OLambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.AnyList(
                            OVar(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                                OVar(&#34;x&#34;),
                            ),
                        ),
                    ),
                )
        raise NotImplementedError(
            f&#34;Can not compare {o} and {self} with operation {op.__class__}. Note that comparisons that always return false are also rejected.&#34;
        )

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        decide_string_func = plt.TraceError(&#34;Invalid constructor id in Union&#34;)
        for t in self.typs:
            decide_string_func = plt.Ite(
                plt.EqualsInteger(OVar(&#34;c&#34;), plt.Integer(t.record.constructor)),
                t.stringify(recursive=True),
                decide_string_func,
            )
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [(&#34;c&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
                plt.Apply(decide_string_func, OVar(&#34;self&#34;)),
            ),
        )

    def copy_only_attributes(self) -&gt; plt.AST:
        copied_attributes = plt.TraceError(
            f&#34;Invalid CONSTR_ID for instance of Union[{&#39;, &#39;.join(type(typ).__name__ for typ in self.typs)}]&#34;
        )
        for typ in self.typs:
            copied_attributes = plt.Ite(
                plt.EqualsInteger(OVar(&#34;constr&#34;), plt.Integer(typ.record.constructor)),
                plt.Apply(typ.copy_only_attributes(), OVar(&#34;self&#34;)),
                copied_attributes,
            )
        return OLambda(
            [&#34;self&#34;],
            OLet(
                [(&#34;constr&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
                copied_attributes,
            ),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.type_impls.UnionType.typs"><code class="name">var <span class="ident">typs</span> :List[<a title="opshin.type_impls.RecordType" href="#opshin.type_impls.RecordType">RecordType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.UnionType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr:str) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr: str) -&gt; plt.AST:
    if attr == &#34;CONSTR_ID&#34;:
        # access to constructor
        return OLambda(
            [&#34;self&#34;],
            plt.Constructor(OVar(&#34;self&#34;)),
        )
    # iterate through all names/types of the unioned records by position
    if any(attr in (n for n, t in r.record.fields) for r in self.typs):
        attr_typ = self.attribute_type(attr)
        pos_constrs = [
            (i, x.record.constructor)
            for x in self.typs
            for i, (n, t) in enumerate(x.record.fields)
            if n == attr
        ]
        pos_constrs = sorted(pos_constrs, key=lambda x: x[0])
        pos_constrs = [
            (pos, [c[1] for c in constrs])
            for (pos, constrs) in itertools.groupby(pos_constrs, key=lambda x: x[0])
        ]
        # largest group last so we save the comparisons for that
        pos_constrs = sorted(pos_constrs, key=lambda x: len(x[1]))
        # access to normal fields
        if not pos_constrs:
            pos_decisor = plt.TraceError(&#34;Invalid constructor&#34;)
        else:
            pos_decisor = plt.Integer(pos_constrs[-1][0])
            pos_constrs = pos_constrs[:-1]
        for pos, constrs in pos_constrs:
            assert constrs, &#34;Found empty constructors for a position&#34;
            constr_check = plt.EqualsInteger(
                OVar(&#34;constr&#34;), plt.Integer(constrs[0])
            )
            for constr in constrs[1:]:
                constr_check = plt.Or(
                    plt.EqualsInteger(OVar(&#34;constr&#34;), plt.Integer(constr)),
                    constr_check,
                )
            pos_decisor = plt.Ite(
                constr_check,
                plt.Integer(pos),
                pos_decisor,
            )
        return OLambda(
            [&#34;self&#34;],
            transform_ext_params_map(attr_typ)(
                plt.NthField(
                    OVar(&#34;self&#34;),
                    OLet(
                        [(&#34;constr&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
                        pos_decisor,
                    ),
                ),
            ),
        )
    if attr == &#34;to_cbor&#34;:
        return OLambda(
            [&#34;self&#34;, &#34;_&#34;],
            plt.SerialiseData(
                OVar(&#34;self&#34;),
            ),
        )
    raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnionType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; &#34;Type&#34;:
    if attr == &#34;CONSTR_ID&#34;:
        return IntegerInstanceType
    # need to have a common field with the same name
    if all(attr in (n for n, t in x.record.fields) for x in self.typs):
        attr_types = OrderedSet(
            t for x in self.typs for n, t in x.record.fields if n == attr
        )
        for at in attr_types:
            # return the maximum element if there is one
            if all(at &gt;= at2 for at2 in attr_types):
                return at
        # return the union type of all possible instantiations if all possible values are record types
        if all(
            isinstance(at, InstanceType) and isinstance(at.typ, RecordType)
            for at in attr_types
        ) and distinct([at.typ.record.constructor for at in attr_types]):
            return InstanceType(
                UnionType(frozenlist([at.typ for at in attr_types]))
            )
        # return Anytype
        return InstanceType(AnyType())
    if attr == &#34;to_cbor&#34;:
        return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))
    raise TypeInferenceError(
        f&#34;Can not access attribute {attr} of Union type. Cast to desired type with an &#39;if isinstance(_, _):&#39; branch.&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnionType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.UnionType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.UnionType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    # this will reject comparisons that will always be false - most likely due to faults during programming
    # note we require that there is an overlapt between the possible types for unions
    if (isinstance(o, RecordType) and any(t &gt;= o or o &gt;= t for t in self.typs)) or (
        isinstance(o, UnionType)
        and any(t &gt;= ot or t &gt;= ot for t in self.typs for ot in o.typs)
    ):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
        if isinstance(op, NotEq):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        OVar(&#34;x&#34;),
                        OVar(&#34;y&#34;),
                    )
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and any(o.typ.typ &gt;= t or t &gt;= o.typ.typ for t in self.typs)
    ):
        if isinstance(op, In):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.AnyList(
                    OVar(&#34;y&#34;),
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        OVar(&#34;x&#34;),
                    ),
                ),
            )
        if isinstance(op, NotIn):
            return OLambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.AnyList(
                        OVar(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            OVar(&#34;x&#34;),
                        ),
                    ),
                ),
            )
    raise NotImplementedError(
        f&#34;Can not compare {o} and {self} with operation {op.__class__}. Note that comparisons that always return false are also rejected.&#34;
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnionType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.UnionType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.UnionType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_only_attributes(self) -&gt; plt.AST:
    copied_attributes = plt.TraceError(
        f&#34;Invalid CONSTR_ID for instance of Union[{&#39;, &#39;.join(type(typ).__name__ for typ in self.typs)}]&#34;
    )
    for typ in self.typs:
        copied_attributes = plt.Ite(
            plt.EqualsInteger(OVar(&#34;constr&#34;), plt.Integer(typ.record.constructor)),
            plt.Apply(typ.copy_only_attributes(), OVar(&#34;self&#34;)),
            copied_attributes,
        )
    return OLambda(
        [&#34;self&#34;],
        OLet(
            [(&#34;constr&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
            copied_attributes,
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnionType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_map(self, skip_constructor: bool = False) -&gt; str:
    return &#34;union&lt;&#34; + &#34;,&#34;.join(t.id_map() for t in self.typs) + &#34;&gt;&#34;</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnionType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    decide_string_func = plt.TraceError(&#34;Invalid constructor id in Union&#34;)
    for t in self.typs:
        decide_string_func = plt.Ite(
            plt.EqualsInteger(OVar(&#34;c&#34;), plt.Integer(t.record.constructor)),
            t.stringify(recursive=True),
            decide_string_func,
        )
    return OLambda(
        [&#34;self&#34;],
        OLet(
            [(&#34;c&#34;, plt.Constructor(OVar(&#34;self&#34;)))],
            plt.Apply(decide_string_func, OVar(&#34;self&#34;)),
        ),
    )</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnionType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.UnionType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code>.<code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.type_impls.UnitType"><code class="flex name class">
<span>class <span class="ident">UnitType</span></span>
</code></dt>
<dd>
<div class="desc"><p>UnitType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, unsafe_hash=True)
class UnitType(AtomicType):
    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, UnitType):
            if isinstance(op, Eq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(True))
            if isinstance(op, NotEq):
                return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(False))
        return super().cmp(op, o)

    def stringify(self, recursive: bool = False) -&gt; plt.AST:
        return OLambda([&#34;self&#34;], plt.Text(&#34;None&#34;))

    def _unop_return_type(self, unop: unaryop) -&gt; &#34;Type&#34;:
        if isinstance(unop, Not):
            return BoolType()
        return super()._unop_return_type(unop)

    def _unop_fun(self, unop: unaryop) -&gt; Callable[[plt.AST], plt.AST]:
        if isinstance(unop, Not):
            return lambda x: plt.Bool(True)
        return super()._unop_fun(unop)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></li>
<li><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></li>
<li><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.type_impls.UnitType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute" href="#opshin.type_impls.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.attribute_type" href="#opshin.type_impls.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.binop"><code class="name flex">
<span>def <span class="ident">binop</span></span>(<span>self, binop:ast.operator, other:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop" href="#opshin.type_impls.AtomicType.binop">binop</a></code>
</p>
<div class="desc inherited"><p>Implements a binary operation between self and other</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.binop_type"><code class="name flex">
<span>def <span class="ident">binop_type</span></span>(<span>self, binop:ast.operator, other:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.binop_type" href="#opshin.type_impls.AtomicType.binop_type">binop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a binary operation between self and other.</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op:ast.cmpop, o:<a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.cmp" href="#opshin.type_impls.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, UnitType):
        if isinstance(op, Eq):
            return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(True))
        if isinstance(op, NotEq):
            return OLambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(False))
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnitType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr" href="#opshin.type_impls.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.constr_type" href="#opshin.type_impls.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.copy_only_attributes"><code class="name flex">
<span>def <span class="ident">copy_only_attributes</span></span>(<span>self) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.copy_only_attributes" href="#opshin.type_impls.AtomicType.copy_only_attributes">copy_only_attributes</a></code>
</p>
<div class="desc inherited"><p>Returns a copy of this type with only the declared attributes (mapped to builtin values, thus checking atomic types too).
For anything but record </p></div>
</dd>
<dt id="opshin.type_impls.UnitType.id_map"><code class="name flex">
<span>def <span class="ident">id_map</span></span>(<span>self, skip_constructor:bool=False) >str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.id_map" href="#opshin.type_impls.AtomicType.id_map">id_map</a></code>
</p>
<div class="desc inherited"><p>Returns a map from the constructor id to a descriptive typestring</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, recursive:bool=False) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.stringify" href="#opshin.type_impls.AtomicType.stringify">stringify</a></code>
</p>
<div class="desc inherited"><p>Returns a stringified version of the object </p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, recursive: bool = False) -&gt; plt.AST:
    return OLambda([&#34;self&#34;], plt.Text(&#34;None&#34;))</code></pre>
</details>
</dd>
<dt id="opshin.type_impls.UnitType.unop"><code class="name flex">
<span>def <span class="ident">unop</span></span>(<span>self, unop:ast.unaryop) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop" href="#opshin.type_impls.AtomicType.unop">unop</a></code>
</p>
<div class="desc inherited"><p>Implements a unary operation on self</p></div>
</dd>
<dt id="opshin.type_impls.UnitType.unop_type"><code class="name flex">
<span>def <span class="ident">unop_type</span></span>(<span>self, unop:ast.unaryop) ><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code>.<code><a title="opshin.type_impls.AtomicType.unop_type" href="#opshin.type_impls.AtomicType.unop_type">unop_type</a></code>
</p>
<div class="desc inherited"><p>Type of a unary operation on self.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="opshin Home" href="https://opshin.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/opshin/master/opshin.png" alt="opshin logo"> &nbsp; opshin
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opshin" href="index.html">opshin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opshin.type_impls.ByteStrIntMulImpl" href="#opshin.type_impls.ByteStrIntMulImpl">ByteStrIntMulImpl</a></code></li>
<li><code><a title="opshin.type_impls.PowImpl" href="#opshin.type_impls.PowImpl">PowImpl</a></code></li>
<li><code><a title="opshin.type_impls.StrIntMulImpl" href="#opshin.type_impls.StrIntMulImpl">StrIntMulImpl</a></code></li>
<li><code><a title="opshin.type_impls.empty_list" href="#opshin.type_impls.empty_list">empty_list</a></code></li>
<li><code><a title="opshin.type_impls.repeated_addition" href="#opshin.type_impls.repeated_addition">repeated_addition</a></code></li>
<li><code><a title="opshin.type_impls.transform_ext_params_map" href="#opshin.type_impls.transform_ext_params_map">transform_ext_params_map</a></code></li>
<li><code><a title="opshin.type_impls.transform_output_map" href="#opshin.type_impls.transform_output_map">transform_output_map</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opshin.type_impls.AnyType" href="#opshin.type_impls.AnyType">AnyType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.AnyType.attribute" href="#opshin.type_impls.AnyType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.attribute_type" href="#opshin.type_impls.AnyType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.binop" href="#opshin.type_impls.AnyType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.binop_type" href="#opshin.type_impls.AnyType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.cmp" href="#opshin.type_impls.AnyType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.constr" href="#opshin.type_impls.AnyType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.constr_type" href="#opshin.type_impls.AnyType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.copy_only_attributes" href="#opshin.type_impls.AnyType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.id_map" href="#opshin.type_impls.AnyType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.stringify" href="#opshin.type_impls.AnyType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.unop" href="#opshin.type_impls.AnyType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.AnyType.unop_type" href="#opshin.type_impls.AnyType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.AtomicType" href="#opshin.type_impls.AtomicType">AtomicType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.AtomicType.attribute" href="#opshin.type_impls.AtomicType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.attribute_type" href="#opshin.type_impls.AtomicType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.binop" href="#opshin.type_impls.AtomicType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.binop_type" href="#opshin.type_impls.AtomicType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.cmp" href="#opshin.type_impls.AtomicType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.constr" href="#opshin.type_impls.AtomicType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.constr_type" href="#opshin.type_impls.AtomicType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.copy_only_attributes" href="#opshin.type_impls.AtomicType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.id_map" href="#opshin.type_impls.AtomicType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.stringify" href="#opshin.type_impls.AtomicType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.unop" href="#opshin.type_impls.AtomicType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.AtomicType.unop_type" href="#opshin.type_impls.AtomicType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.BoolImpl" href="#opshin.type_impls.BoolImpl">BoolImpl</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.BoolImpl.impl_from_args" href="#opshin.type_impls.BoolImpl.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="opshin.type_impls.BoolImpl.type_from_args" href="#opshin.type_impls.BoolImpl.type_from_args">type_from_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.BoolType" href="#opshin.type_impls.BoolType">BoolType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.BoolType.attribute" href="#opshin.type_impls.BoolType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.attribute_type" href="#opshin.type_impls.BoolType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.binop" href="#opshin.type_impls.BoolType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.binop_type" href="#opshin.type_impls.BoolType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.cmp" href="#opshin.type_impls.BoolType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.constr" href="#opshin.type_impls.BoolType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.constr_type" href="#opshin.type_impls.BoolType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.copy_only_attributes" href="#opshin.type_impls.BoolType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.id_map" href="#opshin.type_impls.BoolType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.stringify" href="#opshin.type_impls.BoolType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.unop" href="#opshin.type_impls.BoolType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.BoolType.unop_type" href="#opshin.type_impls.BoolType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.ByteStringType" href="#opshin.type_impls.ByteStringType">ByteStringType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.ByteStringType.attribute" href="#opshin.type_impls.ByteStringType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.attribute_type" href="#opshin.type_impls.ByteStringType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.binop" href="#opshin.type_impls.ByteStringType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.binop_type" href="#opshin.type_impls.ByteStringType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.cmp" href="#opshin.type_impls.ByteStringType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.constr" href="#opshin.type_impls.ByteStringType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.constr_type" href="#opshin.type_impls.ByteStringType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.copy_only_attributes" href="#opshin.type_impls.ByteStringType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.id_map" href="#opshin.type_impls.ByteStringType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.stringify" href="#opshin.type_impls.ByteStringType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.unop" href="#opshin.type_impls.ByteStringType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.ByteStringType.unop_type" href="#opshin.type_impls.ByteStringType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.BytesImpl" href="#opshin.type_impls.BytesImpl">BytesImpl</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.BytesImpl.impl_from_args" href="#opshin.type_impls.BytesImpl.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="opshin.type_impls.BytesImpl.type_from_args" href="#opshin.type_impls.BytesImpl.type_from_args">type_from_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.ClassType" href="#opshin.type_impls.ClassType">ClassType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.ClassType.attribute" href="#opshin.type_impls.ClassType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.attribute_type" href="#opshin.type_impls.ClassType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.binop" href="#opshin.type_impls.ClassType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.binop_type" href="#opshin.type_impls.ClassType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.cmp" href="#opshin.type_impls.ClassType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.constr" href="#opshin.type_impls.ClassType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.constr_type" href="#opshin.type_impls.ClassType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.copy_only_attributes" href="#opshin.type_impls.ClassType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.id_map" href="#opshin.type_impls.ClassType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.stringify" href="#opshin.type_impls.ClassType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.unop" href="#opshin.type_impls.ClassType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.ClassType.unop_type" href="#opshin.type_impls.ClassType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.DictType" href="#opshin.type_impls.DictType">DictType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.DictType.attribute" href="#opshin.type_impls.DictType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.DictType.attribute_type" href="#opshin.type_impls.DictType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.DictType.binop" href="#opshin.type_impls.DictType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.DictType.binop_type" href="#opshin.type_impls.DictType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.DictType.cmp" href="#opshin.type_impls.DictType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.DictType.constr" href="#opshin.type_impls.DictType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.DictType.constr_type" href="#opshin.type_impls.DictType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.DictType.copy_only_attributes" href="#opshin.type_impls.DictType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.DictType.id_map" href="#opshin.type_impls.DictType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.DictType.key_typ" href="#opshin.type_impls.DictType.key_typ">key_typ</a></code></li>
<li><code><a title="opshin.type_impls.DictType.stringify" href="#opshin.type_impls.DictType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.DictType.unop" href="#opshin.type_impls.DictType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.DictType.unop_type" href="#opshin.type_impls.DictType.unop_type">unop_type</a></code></li>
<li><code><a title="opshin.type_impls.DictType.value_typ" href="#opshin.type_impls.DictType.value_typ">value_typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.FunctionType" href="#opshin.type_impls.FunctionType">FunctionType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.FunctionType.argtyps" href="#opshin.type_impls.FunctionType.argtyps">argtyps</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.attribute" href="#opshin.type_impls.FunctionType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.attribute_type" href="#opshin.type_impls.FunctionType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.bind_self" href="#opshin.type_impls.FunctionType.bind_self">bind_self</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.binop" href="#opshin.type_impls.FunctionType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.binop_type" href="#opshin.type_impls.FunctionType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.bound_vars" href="#opshin.type_impls.FunctionType.bound_vars">bound_vars</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.cmp" href="#opshin.type_impls.FunctionType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.constr" href="#opshin.type_impls.FunctionType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.constr_type" href="#opshin.type_impls.FunctionType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.copy_only_attributes" href="#opshin.type_impls.FunctionType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.id_map" href="#opshin.type_impls.FunctionType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.rettyp" href="#opshin.type_impls.FunctionType.rettyp">rettyp</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.stringify" href="#opshin.type_impls.FunctionType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.unop" href="#opshin.type_impls.FunctionType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.FunctionType.unop_type" href="#opshin.type_impls.FunctionType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.InaccessibleType" href="#opshin.type_impls.InaccessibleType">InaccessibleType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.InaccessibleType.attribute" href="#opshin.type_impls.InaccessibleType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.attribute_type" href="#opshin.type_impls.InaccessibleType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.binop" href="#opshin.type_impls.InaccessibleType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.binop_type" href="#opshin.type_impls.InaccessibleType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.cmp" href="#opshin.type_impls.InaccessibleType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.constr" href="#opshin.type_impls.InaccessibleType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.constr_type" href="#opshin.type_impls.InaccessibleType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.copy_only_attributes" href="#opshin.type_impls.InaccessibleType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.id_map" href="#opshin.type_impls.InaccessibleType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.stringify" href="#opshin.type_impls.InaccessibleType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.unop" href="#opshin.type_impls.InaccessibleType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.InaccessibleType.unop_type" href="#opshin.type_impls.InaccessibleType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.InstanceType" href="#opshin.type_impls.InstanceType">InstanceType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.InstanceType.attribute" href="#opshin.type_impls.InstanceType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.attribute_type" href="#opshin.type_impls.InstanceType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.binop" href="#opshin.type_impls.InstanceType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.binop_type" href="#opshin.type_impls.InstanceType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.cmp" href="#opshin.type_impls.InstanceType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.constr" href="#opshin.type_impls.InstanceType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.constr_type" href="#opshin.type_impls.InstanceType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.copy_only_attributes" href="#opshin.type_impls.InstanceType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.id_map" href="#opshin.type_impls.InstanceType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.stringify" href="#opshin.type_impls.InstanceType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.typ" href="#opshin.type_impls.InstanceType.typ">typ</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.unop" href="#opshin.type_impls.InstanceType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.InstanceType.unop_type" href="#opshin.type_impls.InstanceType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.IntImpl" href="#opshin.type_impls.IntImpl">IntImpl</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.IntImpl.impl_from_args" href="#opshin.type_impls.IntImpl.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="opshin.type_impls.IntImpl.type_from_args" href="#opshin.type_impls.IntImpl.type_from_args">type_from_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.IntegerType" href="#opshin.type_impls.IntegerType">IntegerType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.IntegerType.attribute" href="#opshin.type_impls.IntegerType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.attribute_type" href="#opshin.type_impls.IntegerType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.binop" href="#opshin.type_impls.IntegerType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.binop_type" href="#opshin.type_impls.IntegerType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.cmp" href="#opshin.type_impls.IntegerType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.constr" href="#opshin.type_impls.IntegerType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.constr_type" href="#opshin.type_impls.IntegerType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.copy_only_attributes" href="#opshin.type_impls.IntegerType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.id_map" href="#opshin.type_impls.IntegerType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.stringify" href="#opshin.type_impls.IntegerType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.unop" href="#opshin.type_impls.IntegerType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.IntegerType.unop_type" href="#opshin.type_impls.IntegerType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.ListType" href="#opshin.type_impls.ListType">ListType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.ListType.attribute" href="#opshin.type_impls.ListType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.ListType.attribute_type" href="#opshin.type_impls.ListType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.ListType.binop" href="#opshin.type_impls.ListType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.ListType.binop_type" href="#opshin.type_impls.ListType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.ListType.cmp" href="#opshin.type_impls.ListType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.ListType.constr" href="#opshin.type_impls.ListType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.ListType.constr_type" href="#opshin.type_impls.ListType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.ListType.copy_only_attributes" href="#opshin.type_impls.ListType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.ListType.id_map" href="#opshin.type_impls.ListType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.ListType.stringify" href="#opshin.type_impls.ListType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.ListType.typ" href="#opshin.type_impls.ListType.typ">typ</a></code></li>
<li><code><a title="opshin.type_impls.ListType.unop" href="#opshin.type_impls.ListType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.ListType.unop_type" href="#opshin.type_impls.ListType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.PairType" href="#opshin.type_impls.PairType">PairType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.PairType.attribute" href="#opshin.type_impls.PairType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.PairType.attribute_type" href="#opshin.type_impls.PairType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.PairType.binop" href="#opshin.type_impls.PairType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.PairType.binop_type" href="#opshin.type_impls.PairType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.PairType.cmp" href="#opshin.type_impls.PairType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.PairType.constr" href="#opshin.type_impls.PairType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.PairType.constr_type" href="#opshin.type_impls.PairType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.PairType.copy_only_attributes" href="#opshin.type_impls.PairType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.PairType.id_map" href="#opshin.type_impls.PairType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.PairType.l_typ" href="#opshin.type_impls.PairType.l_typ">l_typ</a></code></li>
<li><code><a title="opshin.type_impls.PairType.r_typ" href="#opshin.type_impls.PairType.r_typ">r_typ</a></code></li>
<li><code><a title="opshin.type_impls.PairType.stringify" href="#opshin.type_impls.PairType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.PairType.unop" href="#opshin.type_impls.PairType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.PairType.unop_type" href="#opshin.type_impls.PairType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.PolymorphicFunction" href="#opshin.type_impls.PolymorphicFunction">PolymorphicFunction</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.PolymorphicFunction.impl_from_args" href="#opshin.type_impls.PolymorphicFunction.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunction.type_from_args" href="#opshin.type_impls.PolymorphicFunction.type_from_args">type_from_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType" href="#opshin.type_impls.PolymorphicFunctionInstanceType">PolymorphicFunctionInstanceType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.attribute" href="#opshin.type_impls.PolymorphicFunctionInstanceType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.attribute_type" href="#opshin.type_impls.PolymorphicFunctionInstanceType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.binop" href="#opshin.type_impls.PolymorphicFunctionInstanceType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.binop_type" href="#opshin.type_impls.PolymorphicFunctionInstanceType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.cmp" href="#opshin.type_impls.PolymorphicFunctionInstanceType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.constr" href="#opshin.type_impls.PolymorphicFunctionInstanceType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.constr_type" href="#opshin.type_impls.PolymorphicFunctionInstanceType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.copy_only_attributes" href="#opshin.type_impls.PolymorphicFunctionInstanceType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.id_map" href="#opshin.type_impls.PolymorphicFunctionInstanceType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.polymorphic_function" href="#opshin.type_impls.PolymorphicFunctionInstanceType.polymorphic_function">polymorphic_function</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.stringify" href="#opshin.type_impls.PolymorphicFunctionInstanceType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.typ" href="#opshin.type_impls.PolymorphicFunctionInstanceType.typ">typ</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.unop" href="#opshin.type_impls.PolymorphicFunctionInstanceType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionInstanceType.unop_type" href="#opshin.type_impls.PolymorphicFunctionInstanceType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.PolymorphicFunctionType" href="#opshin.type_impls.PolymorphicFunctionType">PolymorphicFunctionType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.attribute" href="#opshin.type_impls.PolymorphicFunctionType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.attribute_type" href="#opshin.type_impls.PolymorphicFunctionType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.binop" href="#opshin.type_impls.PolymorphicFunctionType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.binop_type" href="#opshin.type_impls.PolymorphicFunctionType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.cmp" href="#opshin.type_impls.PolymorphicFunctionType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.constr" href="#opshin.type_impls.PolymorphicFunctionType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.constr_type" href="#opshin.type_impls.PolymorphicFunctionType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.copy_only_attributes" href="#opshin.type_impls.PolymorphicFunctionType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.id_map" href="#opshin.type_impls.PolymorphicFunctionType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.polymorphic_function" href="#opshin.type_impls.PolymorphicFunctionType.polymorphic_function">polymorphic_function</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.stringify" href="#opshin.type_impls.PolymorphicFunctionType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.unop" href="#opshin.type_impls.PolymorphicFunctionType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.PolymorphicFunctionType.unop_type" href="#opshin.type_impls.PolymorphicFunctionType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.Record" href="#opshin.type_impls.Record">Record</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.Record.constructor" href="#opshin.type_impls.Record.constructor">constructor</a></code></li>
<li><code><a title="opshin.type_impls.Record.fields" href="#opshin.type_impls.Record.fields">fields</a></code></li>
<li><code><a title="opshin.type_impls.Record.name" href="#opshin.type_impls.Record.name">name</a></code></li>
<li><code><a title="opshin.type_impls.Record.orig_name" href="#opshin.type_impls.Record.orig_name">orig_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.RecordType" href="#opshin.type_impls.RecordType">RecordType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.RecordType.attribute" href="#opshin.type_impls.RecordType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.attribute_type" href="#opshin.type_impls.RecordType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.binop" href="#opshin.type_impls.RecordType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.binop_type" href="#opshin.type_impls.RecordType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.cmp" href="#opshin.type_impls.RecordType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.constr" href="#opshin.type_impls.RecordType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.constr_type" href="#opshin.type_impls.RecordType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.copy_only_attributes" href="#opshin.type_impls.RecordType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.id_map" href="#opshin.type_impls.RecordType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.record" href="#opshin.type_impls.RecordType.record">record</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.stringify" href="#opshin.type_impls.RecordType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.unop" href="#opshin.type_impls.RecordType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.RecordType.unop_type" href="#opshin.type_impls.RecordType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.StrImpl" href="#opshin.type_impls.StrImpl">StrImpl</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.StrImpl.impl_from_args" href="#opshin.type_impls.StrImpl.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="opshin.type_impls.StrImpl.type_from_args" href="#opshin.type_impls.StrImpl.type_from_args">type_from_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.StringType" href="#opshin.type_impls.StringType">StringType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.StringType.attribute" href="#opshin.type_impls.StringType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.StringType.attribute_type" href="#opshin.type_impls.StringType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.StringType.binop" href="#opshin.type_impls.StringType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.StringType.binop_type" href="#opshin.type_impls.StringType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.StringType.cmp" href="#opshin.type_impls.StringType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.StringType.constr" href="#opshin.type_impls.StringType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.StringType.constr_type" href="#opshin.type_impls.StringType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.StringType.copy_only_attributes" href="#opshin.type_impls.StringType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.StringType.id_map" href="#opshin.type_impls.StringType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.StringType.stringify" href="#opshin.type_impls.StringType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.StringType.unop" href="#opshin.type_impls.StringType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.StringType.unop_type" href="#opshin.type_impls.StringType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.TupleType" href="#opshin.type_impls.TupleType">TupleType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.TupleType.attribute" href="#opshin.type_impls.TupleType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.attribute_type" href="#opshin.type_impls.TupleType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.binop" href="#opshin.type_impls.TupleType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.binop_type" href="#opshin.type_impls.TupleType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.cmp" href="#opshin.type_impls.TupleType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.constr" href="#opshin.type_impls.TupleType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.constr_type" href="#opshin.type_impls.TupleType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.copy_only_attributes" href="#opshin.type_impls.TupleType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.id_map" href="#opshin.type_impls.TupleType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.stringify" href="#opshin.type_impls.TupleType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.typs" href="#opshin.type_impls.TupleType.typs">typs</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.unop" href="#opshin.type_impls.TupleType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.TupleType.unop_type" href="#opshin.type_impls.TupleType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.Type" href="#opshin.type_impls.Type">Type</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.Type.attribute" href="#opshin.type_impls.Type.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.Type.attribute_type" href="#opshin.type_impls.Type.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.Type.binop" href="#opshin.type_impls.Type.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.Type.binop_type" href="#opshin.type_impls.Type.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.Type.cmp" href="#opshin.type_impls.Type.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.Type.constr" href="#opshin.type_impls.Type.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.Type.constr_type" href="#opshin.type_impls.Type.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.Type.copy_only_attributes" href="#opshin.type_impls.Type.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.Type.id_map" href="#opshin.type_impls.Type.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.Type.stringify" href="#opshin.type_impls.Type.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.Type.unop" href="#opshin.type_impls.Type.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.Type.unop_type" href="#opshin.type_impls.Type.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.TypeInferenceError" href="#opshin.type_impls.TypeInferenceError">TypeInferenceError</a></code></h4>
</li>
<li>
<h4><code><a title="opshin.type_impls.UnionType" href="#opshin.type_impls.UnionType">UnionType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.UnionType.attribute" href="#opshin.type_impls.UnionType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.attribute_type" href="#opshin.type_impls.UnionType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.binop" href="#opshin.type_impls.UnionType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.binop_type" href="#opshin.type_impls.UnionType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.cmp" href="#opshin.type_impls.UnionType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.constr" href="#opshin.type_impls.UnionType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.constr_type" href="#opshin.type_impls.UnionType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.copy_only_attributes" href="#opshin.type_impls.UnionType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.id_map" href="#opshin.type_impls.UnionType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.stringify" href="#opshin.type_impls.UnionType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.typs" href="#opshin.type_impls.UnionType.typs">typs</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.unop" href="#opshin.type_impls.UnionType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.UnionType.unop_type" href="#opshin.type_impls.UnionType.unop_type">unop_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.type_impls.UnitType" href="#opshin.type_impls.UnitType">UnitType</a></code></h4>
<ul class="">
<li><code><a title="opshin.type_impls.UnitType.attribute" href="#opshin.type_impls.UnitType.attribute">attribute</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.attribute_type" href="#opshin.type_impls.UnitType.attribute_type">attribute_type</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.binop" href="#opshin.type_impls.UnitType.binop">binop</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.binop_type" href="#opshin.type_impls.UnitType.binop_type">binop_type</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.cmp" href="#opshin.type_impls.UnitType.cmp">cmp</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.constr" href="#opshin.type_impls.UnitType.constr">constr</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.constr_type" href="#opshin.type_impls.UnitType.constr_type">constr_type</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.copy_only_attributes" href="#opshin.type_impls.UnitType.copy_only_attributes">copy_only_attributes</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.id_map" href="#opshin.type_impls.UnitType.id_map">id_map</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.stringify" href="#opshin.type_impls.UnitType.stringify">stringify</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.unop" href="#opshin.type_impls.UnitType.unop">unop</a></code></li>
<li><code><a title="opshin.type_impls.UnitType.unop_type" href="#opshin.type_impls.UnitType.unop_type">unop_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>