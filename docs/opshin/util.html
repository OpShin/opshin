<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/opshin/dev/docs/opshin_32.png" sizes="32x32" type="image/png">
<title>opshin.util API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/opshin" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>opshin.util</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from _ast import Name, Store, ClassDef, FunctionDef, Load
from collections import defaultdict
from copy import copy, deepcopy

import typing

import ast
from dataclasses import dataclass

import pycardano
from frozendict import frozendict
from frozenlist2 import frozenlist

import uplc.ast as uplc
import pluthon as plt
from hashlib import sha256


def distinct(xs: list):
    &#34;&#34;&#34;Returns true iff the list consists of distinct elements&#34;&#34;&#34;
    return len(xs) == len(set(xs))


class TypedNodeTransformer(ast.NodeTransformer):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)


class TypedNodeVisitor(ast.NodeVisitor):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)


class CompilerError(Exception):
    def __init__(self, orig_err: Exception, node: ast.AST, compilation_step: str):
        self.orig_err = orig_err
        self.node = node
        self.compilation_step = compilation_step


class CompilingNodeTransformer(TypedNodeTransformer):
    step = &#34;Node transformation&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)


class NoOp(CompilingNodeTransformer):
    &#34;&#34;&#34;A variation of the Compiling Node transformer that performs no changes&#34;&#34;&#34;

    pass


class CompilingNodeVisitor(TypedNodeVisitor):
    step = &#34;Node visiting&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)


def data_from_json(j: typing.Dict[str, typing.Any]) -&gt; uplc.PlutusData:
    if &#34;bytes&#34; in j:
        return uplc.PlutusByteString(bytes.fromhex(j[&#34;bytes&#34;]))
    if &#34;int&#34; in j:
        return uplc.PlutusInteger(int(j[&#34;int&#34;]))
    if &#34;list&#34; in j:
        return uplc.PlutusList(frozenlist(list(map(data_from_json, j[&#34;list&#34;]))))
    if &#34;map&#34; in j:
        return uplc.PlutusMap(
            frozendict(
                {data_from_json(d[&#34;k&#34;]): data_from_json(d[&#34;v&#34;]) for d in j[&#34;map&#34;]}
            )
        )
    if &#34;constructor&#34; in j and &#34;fields&#34; in j:
        return uplc.PlutusConstr(
            j[&#34;constructor&#34;], frozenlist(list(map(data_from_json, j[&#34;fields&#34;])))
        )
    raise NotImplementedError(f&#34;Unknown datum representation {j}&#34;)


def datum_to_cbor(d: pycardano.Datum) -&gt; bytes:
    return pycardano.PlutusData.to_cbor(d)


def datum_to_json(d: pycardano.Datum) -&gt; str:
    return pycardano.PlutusData.to_json(d)


def custom_fix_missing_locations(node, parent=None):
    &#34;&#34;&#34;
    Works like ast.fix_missing_location but forces it onto everything
    &#34;&#34;&#34;

    def _fix(node, lineno, col_offset, end_lineno, end_col_offset):
        if getattr(node, &#34;lineno&#34;, None) is None:
            node.lineno = lineno
        else:
            lineno = node.lineno
        if getattr(node, &#34;end_lineno&#34;, None) is None:
            node.end_lineno = end_lineno
        else:
            end_lineno = node.end_lineno
        if getattr(node, &#34;col_offset&#34;, None) is None:
            node.col_offset = col_offset
        else:
            col_offset = node.col_offset
        if getattr(node, &#34;end_col_offset&#34;, None) is None:
            node.end_col_offset = end_col_offset
        else:
            end_col_offset = node.end_col_offset
        for child in ast.iter_child_nodes(node):
            _fix(child, lineno, col_offset, end_lineno, end_col_offset)

    lineno, col_offset, end_lineno, end_col_offset = (
        getattr(parent, &#34;lineno&#34;, 1),
        getattr(parent, &#34;col_offset&#34;, 0),
        getattr(parent, &#34;end_lineno&#34;, 1),
        getattr(parent, &#34;end_col_offset&#34;, 0),
    )
    _fix(node, lineno, col_offset, end_lineno, end_col_offset)
    return node


_patterns_cached = {}


def make_pattern(structure: plt.AST) -&gt; plt.Pattern:
    &#34;&#34;&#34;Creates a shared pattern from the given lambda, cached so that it is re-used in subsequent calls&#34;&#34;&#34;
    structure_serialized = structure.dumps()
    if _patterns_cached.get(structure_serialized) is None:
        # @dataclass
        # class AdHocPattern(plt.Pattern):

        #     def compose(self):
        #         return structure
        AdHocPattern = type(
            f&#34;AdHocPattern_{sha256(structure_serialized.encode()).digest().hex()}&#34;,
            (plt.Pattern,),
            {&#34;compose&#34;: lambda self: deepcopy(structure)},
        )
        AdHocPattern = dataclass(AdHocPattern)

        _patterns_cached[structure_serialized] = AdHocPattern()
    return deepcopy(_patterns_cached[structure_serialized])


def patternize(method):
    def wrapped(*args, **kwargs):
        return make_pattern(method(*args, **kwargs))

    return wrapped


def force_params(lmd: plt.Lambda) -&gt; plt.Lambda:
    if isinstance(lmd, plt.Lambda):
        return plt.Lambda(
            lmd.vars, plt.Let([(v, plt.Force(plt.Var(v))) for v in lmd.vars], lmd.term)
        )
    if isinstance(lmd, plt.Pattern):
        return make_pattern(force_params(lmd.compose()))


class NameWriteCollector(CompilingNodeVisitor):
    step = &#34;Collecting variables that are written&#34;

    def __init__(self):
        self.written = defaultdict(int)

    def visit_Name(self, node: Name) -&gt; None:
        if isinstance(node.ctx, Store):
            self.written[node.id] += 1

    def visit_ClassDef(self, node: ClassDef):
        # ignore the content (i.e. attribute names) of class definitions
        self.written[node.name] += 1
        pass

    def visit_FunctionDef(self, node: FunctionDef):
        # ignore the type hints of function arguments
        self.written[node.name] += 1
        for a in node.args.args:
            self.written[a.arg] += 1
        for s in node.body:
            self.visit(s)


def written_vars(node):
    &#34;&#34;&#34;
    Returns all variable names written to in this node
    &#34;&#34;&#34;
    collector = NameWriteCollector()
    collector.visit(node)
    return sorted(collector.written.keys())


class NameReadCollector(CompilingNodeVisitor):
    step = &#34;Collecting variables that are read&#34;

    def __init__(self):
        self.read = defaultdict(int)

    def visit_AnnAssign(self, node) -&gt; None:
        # ignore annotations of variables
        self.visit(node.value)
        self.visit(node.target)

    def visit_FunctionDef(self, node) -&gt; None:
        # ignore annotations of paramters and return
        self.visit(node.args)
        for b in node.body:
            self.visit(b)

    def visit_Name(self, node: Name) -&gt; None:
        if isinstance(node.ctx, Load):
            self.read[node.id] += 1

    def visit_ClassDef(self, node: ClassDef):
        # ignore the content (i.e. attribute names) of class definitions
        pass

    def visit_FunctionDef(self, node: FunctionDef):
        # ignore the type hints of function arguments
        for s in node.body:
            self.visit(s)


def read_vars(node):
    &#34;&#34;&#34;
    Returns all variable names read to in this node
    &#34;&#34;&#34;
    collector = NameReadCollector()
    collector.visit(node)
    return sorted(collector.read.keys())


def all_vars(node):
    return sorted(set(read_vars(node) + written_vars(node)))


def externally_bound_vars(node: FunctionDef):
    &#34;&#34;&#34;A superset of the variables bound from an outer scope&#34;&#34;&#34;
    return sorted(set(read_vars(node)) - (set(written_vars(node)) - {node.name}))


def opshin_name_scheme_compatible_varname(n: str):
    return f&#34;1{n}&#34;


def OVar(name: str):
    return plt.Var(opshin_name_scheme_compatible_varname(name))


def OLambda(names: typing.List[str], term: plt.AST):
    return plt.Lambda([opshin_name_scheme_compatible_varname(x) for x in names], term)


def OLet(bindings: typing.List[typing.Tuple[str, plt.AST]], term: plt.AST):
    return plt.Let(
        [(opshin_name_scheme_compatible_varname(n), t) for n, t in bindings], term
    )


def SafeLambda(vars: typing.List[str], term: plt.AST) -&gt; plt.Lambda:
    if not vars:
        return plt.Lambda([&#34;0_&#34;], term)
    return plt.Lambda(vars, term)


def SafeOLambda(vars: typing.List[str], term: plt.AST) -&gt; plt.Lambda:
    if not vars:
        return OLambda([&#34;0_&#34;], term)
    return OLambda(vars, term)


def SafeApply(term: plt.AST, *vars: typing.List[plt.AST]) -&gt; plt.Apply:
    if not vars:
        return plt.Apply(term, plt.Delay(plt.Unit()))
    return plt.Apply(term, *vars)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opshin.util.OLambda"><code class="name flex">
<span>def <span class="ident">OLambda</span></span>(<span>names: List[str], term: pluthon.pluthon_ast.AST)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OLambda(names: typing.List[str], term: plt.AST):
    return plt.Lambda([opshin_name_scheme_compatible_varname(x) for x in names], term)</code></pre>
</details>
</dd>
<dt id="opshin.util.OLet"><code class="name flex">
<span>def <span class="ident">OLet</span></span>(<span>bindings: List[Tuple[str, pluthon.pluthon_ast.AST]], term: pluthon.pluthon_ast.AST)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OLet(bindings: typing.List[typing.Tuple[str, plt.AST]], term: plt.AST):
    return plt.Let(
        [(opshin_name_scheme_compatible_varname(n), t) for n, t in bindings], term
    )</code></pre>
</details>
</dd>
<dt id="opshin.util.OVar"><code class="name flex">
<span>def <span class="ident">OVar</span></span>(<span>name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OVar(name: str):
    return plt.Var(opshin_name_scheme_compatible_varname(name))</code></pre>
</details>
</dd>
<dt id="opshin.util.SafeApply"><code class="name flex">
<span>def <span class="ident">SafeApply</span></span>(<span>term: pluthon.pluthon_ast.AST, *vars: List[pluthon.pluthon_ast.AST]) ‑> pluthon.pluthon_ast.Apply</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SafeApply(term: plt.AST, *vars: typing.List[plt.AST]) -&gt; plt.Apply:
    if not vars:
        return plt.Apply(term, plt.Delay(plt.Unit()))
    return plt.Apply(term, *vars)</code></pre>
</details>
</dd>
<dt id="opshin.util.SafeLambda"><code class="name flex">
<span>def <span class="ident">SafeLambda</span></span>(<span>vars: List[str], term: pluthon.pluthon_ast.AST) ‑> pluthon.pluthon_ast.Lambda</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SafeLambda(vars: typing.List[str], term: plt.AST) -&gt; plt.Lambda:
    if not vars:
        return plt.Lambda([&#34;0_&#34;], term)
    return plt.Lambda(vars, term)</code></pre>
</details>
</dd>
<dt id="opshin.util.SafeOLambda"><code class="name flex">
<span>def <span class="ident">SafeOLambda</span></span>(<span>vars: List[str], term: pluthon.pluthon_ast.AST) ‑> pluthon.pluthon_ast.Lambda</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SafeOLambda(vars: typing.List[str], term: plt.AST) -&gt; plt.Lambda:
    if not vars:
        return OLambda([&#34;0_&#34;], term)
    return OLambda(vars, term)</code></pre>
</details>
</dd>
<dt id="opshin.util.all_vars"><code class="name flex">
<span>def <span class="ident">all_vars</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_vars(node):
    return sorted(set(read_vars(node) + written_vars(node)))</code></pre>
</details>
</dd>
<dt id="opshin.util.custom_fix_missing_locations"><code class="name flex">
<span>def <span class="ident">custom_fix_missing_locations</span></span>(<span>node, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like ast.fix_missing_location but forces it onto everything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_fix_missing_locations(node, parent=None):
    &#34;&#34;&#34;
    Works like ast.fix_missing_location but forces it onto everything
    &#34;&#34;&#34;

    def _fix(node, lineno, col_offset, end_lineno, end_col_offset):
        if getattr(node, &#34;lineno&#34;, None) is None:
            node.lineno = lineno
        else:
            lineno = node.lineno
        if getattr(node, &#34;end_lineno&#34;, None) is None:
            node.end_lineno = end_lineno
        else:
            end_lineno = node.end_lineno
        if getattr(node, &#34;col_offset&#34;, None) is None:
            node.col_offset = col_offset
        else:
            col_offset = node.col_offset
        if getattr(node, &#34;end_col_offset&#34;, None) is None:
            node.end_col_offset = end_col_offset
        else:
            end_col_offset = node.end_col_offset
        for child in ast.iter_child_nodes(node):
            _fix(child, lineno, col_offset, end_lineno, end_col_offset)

    lineno, col_offset, end_lineno, end_col_offset = (
        getattr(parent, &#34;lineno&#34;, 1),
        getattr(parent, &#34;col_offset&#34;, 0),
        getattr(parent, &#34;end_lineno&#34;, 1),
        getattr(parent, &#34;end_col_offset&#34;, 0),
    )
    _fix(node, lineno, col_offset, end_lineno, end_col_offset)
    return node</code></pre>
</details>
</dd>
<dt id="opshin.util.data_from_json"><code class="name flex">
<span>def <span class="ident">data_from_json</span></span>(<span>j: Dict[str, Any]) ‑> uplc.ast.PlutusData</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_from_json(j: typing.Dict[str, typing.Any]) -&gt; uplc.PlutusData:
    if &#34;bytes&#34; in j:
        return uplc.PlutusByteString(bytes.fromhex(j[&#34;bytes&#34;]))
    if &#34;int&#34; in j:
        return uplc.PlutusInteger(int(j[&#34;int&#34;]))
    if &#34;list&#34; in j:
        return uplc.PlutusList(frozenlist(list(map(data_from_json, j[&#34;list&#34;]))))
    if &#34;map&#34; in j:
        return uplc.PlutusMap(
            frozendict(
                {data_from_json(d[&#34;k&#34;]): data_from_json(d[&#34;v&#34;]) for d in j[&#34;map&#34;]}
            )
        )
    if &#34;constructor&#34; in j and &#34;fields&#34; in j:
        return uplc.PlutusConstr(
            j[&#34;constructor&#34;], frozenlist(list(map(data_from_json, j[&#34;fields&#34;])))
        )
    raise NotImplementedError(f&#34;Unknown datum representation {j}&#34;)</code></pre>
</details>
</dd>
<dt id="opshin.util.datum_to_cbor"><code class="name flex">
<span>def <span class="ident">datum_to_cbor</span></span>(<span>d: Union[pycardano.plutus.PlutusData, dict, int, bytes, pycardano.serialization.IndefiniteList, pycardano.serialization.RawCBOR, pycardano.plutus.RawPlutusData]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datum_to_cbor(d: pycardano.Datum) -&gt; bytes:
    return pycardano.PlutusData.to_cbor(d)</code></pre>
</details>
</dd>
<dt id="opshin.util.datum_to_json"><code class="name flex">
<span>def <span class="ident">datum_to_json</span></span>(<span>d: Union[pycardano.plutus.PlutusData, dict, int, bytes, pycardano.serialization.IndefiniteList, pycardano.serialization.RawCBOR, pycardano.plutus.RawPlutusData]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datum_to_json(d: pycardano.Datum) -&gt; str:
    return pycardano.PlutusData.to_json(d)</code></pre>
</details>
</dd>
<dt id="opshin.util.distinct"><code class="name flex">
<span>def <span class="ident">distinct</span></span>(<span>xs: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true iff the list consists of distinct elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distinct(xs: list):
    &#34;&#34;&#34;Returns true iff the list consists of distinct elements&#34;&#34;&#34;
    return len(xs) == len(set(xs))</code></pre>
</details>
</dd>
<dt id="opshin.util.externally_bound_vars"><code class="name flex">
<span>def <span class="ident">externally_bound_vars</span></span>(<span>node: ast.FunctionDef)</span>
</code></dt>
<dd>
<div class="desc"><p>A superset of the variables bound from an outer scope</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def externally_bound_vars(node: FunctionDef):
    &#34;&#34;&#34;A superset of the variables bound from an outer scope&#34;&#34;&#34;
    return sorted(set(read_vars(node)) - (set(written_vars(node)) - {node.name}))</code></pre>
</details>
</dd>
<dt id="opshin.util.force_params"><code class="name flex">
<span>def <span class="ident">force_params</span></span>(<span>lmd: pluthon.pluthon_ast.Lambda) ‑> pluthon.pluthon_ast.Lambda</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_params(lmd: plt.Lambda) -&gt; plt.Lambda:
    if isinstance(lmd, plt.Lambda):
        return plt.Lambda(
            lmd.vars, plt.Let([(v, plt.Force(plt.Var(v))) for v in lmd.vars], lmd.term)
        )
    if isinstance(lmd, plt.Pattern):
        return make_pattern(force_params(lmd.compose()))</code></pre>
</details>
</dd>
<dt id="opshin.util.make_pattern"><code class="name flex">
<span>def <span class="ident">make_pattern</span></span>(<span>structure: pluthon.pluthon_ast.AST) ‑> pluthon.pluthon_ast.Pattern</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a shared pattern from the given lambda, cached so that it is re-used in subsequent calls</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_pattern(structure: plt.AST) -&gt; plt.Pattern:
    &#34;&#34;&#34;Creates a shared pattern from the given lambda, cached so that it is re-used in subsequent calls&#34;&#34;&#34;
    structure_serialized = structure.dumps()
    if _patterns_cached.get(structure_serialized) is None:
        # @dataclass
        # class AdHocPattern(plt.Pattern):

        #     def compose(self):
        #         return structure
        AdHocPattern = type(
            f&#34;AdHocPattern_{sha256(structure_serialized.encode()).digest().hex()}&#34;,
            (plt.Pattern,),
            {&#34;compose&#34;: lambda self: deepcopy(structure)},
        )
        AdHocPattern = dataclass(AdHocPattern)

        _patterns_cached[structure_serialized] = AdHocPattern()
    return deepcopy(_patterns_cached[structure_serialized])</code></pre>
</details>
</dd>
<dt id="opshin.util.opshin_name_scheme_compatible_varname"><code class="name flex">
<span>def <span class="ident">opshin_name_scheme_compatible_varname</span></span>(<span>n: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opshin_name_scheme_compatible_varname(n: str):
    return f&#34;1{n}&#34;</code></pre>
</details>
</dd>
<dt id="opshin.util.patternize"><code class="name flex">
<span>def <span class="ident">patternize</span></span>(<span>method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patternize(method):
    def wrapped(*args, **kwargs):
        return make_pattern(method(*args, **kwargs))

    return wrapped</code></pre>
</details>
</dd>
<dt id="opshin.util.read_vars"><code class="name flex">
<span>def <span class="ident">read_vars</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all variable names read to in this node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_vars(node):
    &#34;&#34;&#34;
    Returns all variable names read to in this node
    &#34;&#34;&#34;
    collector = NameReadCollector()
    collector.visit(node)
    return sorted(collector.read.keys())</code></pre>
</details>
</dd>
<dt id="opshin.util.written_vars"><code class="name flex">
<span>def <span class="ident">written_vars</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all variable names written to in this node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def written_vars(node):
    &#34;&#34;&#34;
    Returns all variable names written to in this node
    &#34;&#34;&#34;
    collector = NameWriteCollector()
    collector.visit(node)
    return sorted(collector.written.keys())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opshin.util.CompilerError"><code class="flex name class">
<span>class <span class="ident">CompilerError</span></span>
<span>(</span><span>orig_err: Exception, node: ast.AST, compilation_step: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompilerError(Exception):
    def __init__(self, orig_err: Exception, node: ast.AST, compilation_step: str):
        self.orig_err = orig_err
        self.node = node
        self.compilation_step = compilation_step</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="opshin.util.CompilingNodeTransformer"><code class="flex name class">
<span>class <span class="ident">CompilingNodeTransformer</span></span>
</code></dt>
<dd>
<div class="desc"><p>A :class:<code>NodeVisitor</code> subclass that walks the abstract syntax tree and
allows modification of nodes.</p>
<p>The <code>NodeTransformer</code> will walk the AST and use the return value of the
visitor methods to replace or remove the old node.
If the return value of
the visitor method is <code>None</code>, the node will be removed from its location,
otherwise it is replaced with the return value.
The return value may be the
original node in which case no replacement takes place.</p>
<p>Here is an example transformer that rewrites all occurrences of name lookups
(<code>foo</code>) to <code>data['foo']</code>::</p>
<p>class RewriteName(NodeTransformer):</p>
<pre><code>   def visit_Name(self, node):
       return Subscript(
           value=Name(id='data', ctx=Load()),
           slice=Constant(value=node.id),
           ctx=node.ctx
       )
</code></pre>
<p>Keep in mind that if the node you're operating on has child nodes you must
either transform the child nodes yourself or call the :meth:<code>generic_visit</code>
method for the node first.</p>
<p>For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.</p>
<p>Usually you use the transformer like this::</p>
<p>node = YourTransformer().visit(node)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompilingNodeTransformer(TypedNodeTransformer):
    step = &#34;Node transformation&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.TypedNodeTransformer" href="#opshin.util.TypedNodeTransformer">TypedNodeTransformer</a></li>
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.compiler.PlutoCompiler" href="compiler.html#opshin.compiler.PlutoCompiler">PlutoCompiler</a></li>
<li><a title="opshin.optimize.optimize_const_folding.OptimizeConstantFolding" href="optimize/optimize_const_folding.html#opshin.optimize.optimize_const_folding.OptimizeConstantFolding">OptimizeConstantFolding</a></li>
<li><a title="opshin.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants" href="optimize/optimize_remove_comments.html#opshin.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants">OptimizeRemoveDeadconstants</a></li>
<li><a title="opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars" href="optimize/optimize_remove_deadvars.html#opshin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars">OptimizeRemoveDeadvars</a></li>
<li><a title="opshin.optimize.optimize_remove_pass.OptimizeRemovePass" href="optimize/optimize_remove_pass.html#opshin.optimize.optimize_remove_pass.OptimizeRemovePass">OptimizeRemovePass</a></li>
<li><a title="opshin.rewrite.rewrite_augassign.RewriteAugAssign" href="rewrite/rewrite_augassign.html#opshin.rewrite.rewrite_augassign.RewriteAugAssign">RewriteAugAssign</a></li>
<li><a title="opshin.rewrite.rewrite_cast_condition.RewriteConditions" href="rewrite/rewrite_cast_condition.html#opshin.rewrite.rewrite_cast_condition.RewriteConditions">RewriteConditions</a></li>
<li><a title="opshin.rewrite.rewrite_comparison_chaining.RewriteComparisonChaining" href="rewrite/rewrite_comparison_chaining.html#opshin.rewrite.rewrite_comparison_chaining.RewriteComparisonChaining">RewriteComparisonChaining</a></li>
<li><a title="opshin.rewrite.rewrite_empty_dicts.RewriteEmptyDicts" href="rewrite/rewrite_empty_dicts.html#opshin.rewrite.rewrite_empty_dicts.RewriteEmptyDicts">RewriteEmptyDicts</a></li>
<li><a title="opshin.rewrite.rewrite_empty_lists.RewriteEmptyLists" href="rewrite/rewrite_empty_lists.html#opshin.rewrite.rewrite_empty_lists.RewriteEmptyLists">RewriteEmptyLists</a></li>
<li><a title="opshin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites" href="rewrite/rewrite_forbidden_overwrites.html#opshin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites">RewriteForbiddenOverwrites</a></li>
<li><a title="opshin.rewrite.rewrite_forbidden_return.RewriteForbiddenReturn" href="rewrite/rewrite_forbidden_return.html#opshin.rewrite.rewrite_forbidden_return.RewriteForbiddenReturn">RewriteForbiddenReturn</a></li>
<li><a title="opshin.rewrite.rewrite_import.RewriteImport" href="rewrite/rewrite_import.html#opshin.rewrite.rewrite_import.RewriteImport">RewriteImport</a></li>
<li><a title="opshin.rewrite.rewrite_import.RewriteLocation" href="rewrite/rewrite_import.html#opshin.rewrite.rewrite_import.RewriteLocation">RewriteLocation</a></li>
<li><a title="opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses" href="rewrite/rewrite_import_dataclasses.html#opshin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses">RewriteImportDataclasses</a></li>
<li><a title="opshin.rewrite.rewrite_import_hashlib.RewriteImportHashlib" href="rewrite/rewrite_import_hashlib.html#opshin.rewrite.rewrite_import_hashlib.RewriteImportHashlib">RewriteImportHashlib</a></li>
<li><a title="opshin.rewrite.rewrite_import_integrity_check.RewriteImportIntegrityCheck" href="rewrite/rewrite_import_integrity_check.html#opshin.rewrite.rewrite_import_integrity_check.RewriteImportIntegrityCheck">RewriteImportIntegrityCheck</a></li>
<li><a title="opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData" href="rewrite/rewrite_import_plutusdata.html#opshin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData">RewriteImportPlutusData</a></li>
<li><a title="opshin.rewrite.rewrite_import_typing.RewriteImportTyping" href="rewrite/rewrite_import_typing.html#opshin.rewrite.rewrite_import_typing.RewriteImportTyping">RewriteImportTyping</a></li>
<li><a title="opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins" href="rewrite/rewrite_import_uplc_builtins.html#opshin.rewrite.rewrite_import_uplc_builtins.RewriteImportUPLCBuiltins">RewriteImportUPLCBuiltins</a></li>
<li><a title="opshin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr" href="rewrite/rewrite_inject_builtin_constr.html#opshin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr">RewriteInjectBuiltinsConstr</a></li>
<li><a title="opshin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins" href="rewrite/rewrite_inject_builtins.html#opshin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins">RewriteInjectBuiltins</a></li>
<li><a title="opshin.rewrite.rewrite_orig_name.RewriteOrigName" href="rewrite/rewrite_orig_name.html#opshin.rewrite.rewrite_orig_name.RewriteOrigName">RewriteOrigName</a></li>
<li><a title="opshin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff" href="rewrite/rewrite_remove_type_stuff.html#opshin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff">RewriteRemoveTypeStuff</a></li>
<li><a title="opshin.rewrite.rewrite_scoping.RewriteScoping" href="rewrite/rewrite_scoping.html#opshin.rewrite.rewrite_scoping.RewriteScoping">RewriteScoping</a></li>
<li><a title="opshin.rewrite.rewrite_subscript38.RewriteSubscript38" href="rewrite/rewrite_subscript38.html#opshin.rewrite.rewrite_subscript38.RewriteSubscript38">RewriteSubscript38</a></li>
<li><a title="opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign" href="rewrite/rewrite_tuple_assign.html#opshin.rewrite.rewrite_tuple_assign.RewriteTupleAssign">RewriteTupleAssign</a></li>
<li><a title="opshin.type_inference.AggressiveTypeInferencer" href="type_inference.html#opshin.type_inference.AggressiveTypeInferencer">AggressiveTypeInferencer</a></li>
<li><a title="opshin.util.NoOp" href="#opshin.util.NoOp">NoOp</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.util.CompilingNodeTransformer.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.util.CompilingNodeTransformer.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.TypedNodeTransformer" href="#opshin.util.TypedNodeTransformer">TypedNodeTransformer</a></code>.<code><a title="opshin.util.TypedNodeTransformer.visit" href="#opshin.util.TypedNodeTransformer.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    try:
        return super().visit(node)
    except Exception as e:
        if isinstance(e, CompilerError):
            raise e
        raise CompilerError(e, node, self.step)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.util.CompilingNodeVisitor"><code class="flex name class">
<span>class <span class="ident">CompilingNodeVisitor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompilingNodeVisitor(TypedNodeVisitor):
    step = &#34;Node visiting&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.TypedNodeVisitor" href="#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.optimize.optimize_const_folding.DefinedTimesVisitor" href="optimize/optimize_const_folding.html#opshin.optimize.optimize_const_folding.DefinedTimesVisitor">DefinedTimesVisitor</a></li>
<li><a title="opshin.optimize.optimize_const_folding.ShallowNameDefCollector" href="optimize/optimize_const_folding.html#opshin.optimize.optimize_const_folding.ShallowNameDefCollector">ShallowNameDefCollector</a></li>
<li><a title="opshin.optimize.optimize_remove_deadvars.NameLoadCollector" href="optimize/optimize_remove_deadvars.html#opshin.optimize.optimize_remove_deadvars.NameLoadCollector">NameLoadCollector</a></li>
<li><a title="opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor" href="optimize/optimize_remove_deadvars.html#opshin.optimize.optimize_remove_deadvars.SafeOperationVisitor">SafeOperationVisitor</a></li>
<li><a title="opshin.rewrite.rewrite_scoping.ShallowNameDefCollector" href="rewrite/rewrite_scoping.html#opshin.rewrite.rewrite_scoping.ShallowNameDefCollector">ShallowNameDefCollector</a></li>
<li><a title="opshin.util.NameReadCollector" href="#opshin.util.NameReadCollector">NameReadCollector</a></li>
<li><a title="opshin.util.NameWriteCollector" href="#opshin.util.NameWriteCollector">NameWriteCollector</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.util.CompilingNodeVisitor.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.util.CompilingNodeVisitor.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.TypedNodeVisitor" href="#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></code>.<code><a title="opshin.util.TypedNodeVisitor.visit" href="#opshin.util.TypedNodeVisitor.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    try:
        return super().visit(node)
    except Exception as e:
        if isinstance(e, CompilerError):
            raise e
        raise CompilerError(e, node, self.step)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.util.NameReadCollector"><code class="flex name class">
<span>class <span class="ident">NameReadCollector</span></span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NameReadCollector(CompilingNodeVisitor):
    step = &#34;Collecting variables that are read&#34;

    def __init__(self):
        self.read = defaultdict(int)

    def visit_AnnAssign(self, node) -&gt; None:
        # ignore annotations of variables
        self.visit(node.value)
        self.visit(node.target)

    def visit_FunctionDef(self, node) -&gt; None:
        # ignore annotations of paramters and return
        self.visit(node.args)
        for b in node.body:
            self.visit(b)

    def visit_Name(self, node: Name) -&gt; None:
        if isinstance(node.ctx, Load):
            self.read[node.id] += 1

    def visit_ClassDef(self, node: ClassDef):
        # ignore the content (i.e. attribute names) of class definitions
        pass

    def visit_FunctionDef(self, node: FunctionDef):
        # ignore the type hints of function arguments
        for s in node.body:
            self.visit(s)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.CompilingNodeVisitor" href="#opshin.util.CompilingNodeVisitor">CompilingNodeVisitor</a></li>
<li><a title="opshin.util.TypedNodeVisitor" href="#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.util.NameReadCollector.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.util.NameReadCollector.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.CompilingNodeVisitor" href="#opshin.util.CompilingNodeVisitor">CompilingNodeVisitor</a></code>.<code><a title="opshin.util.CompilingNodeVisitor.visit" href="#opshin.util.CompilingNodeVisitor.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
<dt id="opshin.util.NameReadCollector.visit_AnnAssign"><code class="name flex">
<span>def <span class="ident">visit_AnnAssign</span></span>(<span>self, node) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_AnnAssign(self, node) -&gt; None:
    # ignore annotations of variables
    self.visit(node.value)
    self.visit(node.target)</code></pre>
</details>
</dd>
<dt id="opshin.util.NameReadCollector.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node: ast.ClassDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ClassDef(self, node: ClassDef):
    # ignore the content (i.e. attribute names) of class definitions
    pass</code></pre>
</details>
</dd>
<dt id="opshin.util.NameReadCollector.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node: ast.FunctionDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_FunctionDef(self, node: FunctionDef):
    # ignore the type hints of function arguments
    for s in node.body:
        self.visit(s)</code></pre>
</details>
</dd>
<dt id="opshin.util.NameReadCollector.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node: ast.Name) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node: Name) -&gt; None:
    if isinstance(node.ctx, Load):
        self.read[node.id] += 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.util.NameWriteCollector"><code class="flex name class">
<span>class <span class="ident">NameWriteCollector</span></span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NameWriteCollector(CompilingNodeVisitor):
    step = &#34;Collecting variables that are written&#34;

    def __init__(self):
        self.written = defaultdict(int)

    def visit_Name(self, node: Name) -&gt; None:
        if isinstance(node.ctx, Store):
            self.written[node.id] += 1

    def visit_ClassDef(self, node: ClassDef):
        # ignore the content (i.e. attribute names) of class definitions
        self.written[node.name] += 1
        pass

    def visit_FunctionDef(self, node: FunctionDef):
        # ignore the type hints of function arguments
        self.written[node.name] += 1
        for a in node.args.args:
            self.written[a.arg] += 1
        for s in node.body:
            self.visit(s)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.CompilingNodeVisitor" href="#opshin.util.CompilingNodeVisitor">CompilingNodeVisitor</a></li>
<li><a title="opshin.util.TypedNodeVisitor" href="#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.util.NameWriteCollector.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.util.NameWriteCollector.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.CompilingNodeVisitor" href="#opshin.util.CompilingNodeVisitor">CompilingNodeVisitor</a></code>.<code><a title="opshin.util.CompilingNodeVisitor.visit" href="#opshin.util.CompilingNodeVisitor.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
<dt id="opshin.util.NameWriteCollector.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node: ast.ClassDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ClassDef(self, node: ClassDef):
    # ignore the content (i.e. attribute names) of class definitions
    self.written[node.name] += 1
    pass</code></pre>
</details>
</dd>
<dt id="opshin.util.NameWriteCollector.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node: ast.FunctionDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_FunctionDef(self, node: FunctionDef):
    # ignore the type hints of function arguments
    self.written[node.name] += 1
    for a in node.args.args:
        self.written[a.arg] += 1
    for s in node.body:
        self.visit(s)</code></pre>
</details>
</dd>
<dt id="opshin.util.NameWriteCollector.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node: ast.Name) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node: Name) -&gt; None:
    if isinstance(node.ctx, Store):
        self.written[node.id] += 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.util.NoOp"><code class="flex name class">
<span>class <span class="ident">NoOp</span></span>
</code></dt>
<dd>
<div class="desc"><p>A variation of the Compiling Node transformer that performs no changes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoOp(CompilingNodeTransformer):
    &#34;&#34;&#34;A variation of the Compiling Node transformer that performs no changes&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.CompilingNodeTransformer" href="#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></li>
<li><a title="opshin.util.TypedNodeTransformer" href="#opshin.util.TypedNodeTransformer">TypedNodeTransformer</a></li>
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.util.NoOp.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.CompilingNodeTransformer" href="#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></code>.<code><a title="opshin.util.CompilingNodeTransformer.visit" href="#opshin.util.CompilingNodeTransformer.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
</dl>
</dd>
<dt id="opshin.util.TypedNodeTransformer"><code class="flex name class">
<span>class <span class="ident">TypedNodeTransformer</span></span>
</code></dt>
<dd>
<div class="desc"><p>A :class:<code>NodeVisitor</code> subclass that walks the abstract syntax tree and
allows modification of nodes.</p>
<p>The <code>NodeTransformer</code> will walk the AST and use the return value of the
visitor methods to replace or remove the old node.
If the return value of
the visitor method is <code>None</code>, the node will be removed from its location,
otherwise it is replaced with the return value.
The return value may be the
original node in which case no replacement takes place.</p>
<p>Here is an example transformer that rewrites all occurrences of name lookups
(<code>foo</code>) to <code>data['foo']</code>::</p>
<p>class RewriteName(NodeTransformer):</p>
<pre><code>   def visit_Name(self, node):
       return Subscript(
           value=Name(id='data', ctx=Load()),
           slice=Constant(value=node.id),
           ctx=node.ctx
       )
</code></pre>
<p>Keep in mind that if the node you're operating on has child nodes you must
either transform the child nodes yourself or call the :meth:<code>generic_visit</code>
method for the node first.</p>
<p>For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.</p>
<p>Usually you use the transformer like this::</p>
<p>node = YourTransformer().visit(node)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedNodeTransformer(ast.NodeTransformer):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.util.CompilingNodeTransformer" href="#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.util.TypedNodeTransformer.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visit a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
    node_class_name = node.__class__.__name__
    if node_class_name.startswith(&#34;Typed&#34;):
        node_class_name = node_class_name[len(&#34;Typed&#34;) :]
    method = &#34;visit_&#34; + node_class_name
    visitor = getattr(self, method, self.generic_visit)
    return visitor(node)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="opshin.util.TypedNodeVisitor"><code class="flex name class">
<span>class <span class="ident">TypedNodeVisitor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedNodeVisitor(ast.NodeVisitor):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="opshin.type_inference.ReturnExtractor" href="type_inference.html#opshin.type_inference.ReturnExtractor">ReturnExtractor</a></li>
<li><a title="opshin.type_inference.TypeCheckVisitor" href="type_inference.html#opshin.type_inference.TypeCheckVisitor">TypeCheckVisitor</a></li>
<li><a title="opshin.util.CompilingNodeVisitor" href="#opshin.util.CompilingNodeVisitor">CompilingNodeVisitor</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.util.TypedNodeVisitor.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visit a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
    node_class_name = node.__class__.__name__
    if node_class_name.startswith(&#34;Typed&#34;):
        node_class_name = node_class_name[len(&#34;Typed&#34;) :]
    method = &#34;visit_&#34; + node_class_name
    visitor = getattr(self, method, self.generic_visit)
    return visitor(node)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="opshin Home" href="https://opshin.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/opshin/master/opshin.png" alt="opshin logo"> &nbsp; opshin
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opshin" href="index.html">opshin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opshin.util.OLambda" href="#opshin.util.OLambda">OLambda</a></code></li>
<li><code><a title="opshin.util.OLet" href="#opshin.util.OLet">OLet</a></code></li>
<li><code><a title="opshin.util.OVar" href="#opshin.util.OVar">OVar</a></code></li>
<li><code><a title="opshin.util.SafeApply" href="#opshin.util.SafeApply">SafeApply</a></code></li>
<li><code><a title="opshin.util.SafeLambda" href="#opshin.util.SafeLambda">SafeLambda</a></code></li>
<li><code><a title="opshin.util.SafeOLambda" href="#opshin.util.SafeOLambda">SafeOLambda</a></code></li>
<li><code><a title="opshin.util.all_vars" href="#opshin.util.all_vars">all_vars</a></code></li>
<li><code><a title="opshin.util.custom_fix_missing_locations" href="#opshin.util.custom_fix_missing_locations">custom_fix_missing_locations</a></code></li>
<li><code><a title="opshin.util.data_from_json" href="#opshin.util.data_from_json">data_from_json</a></code></li>
<li><code><a title="opshin.util.datum_to_cbor" href="#opshin.util.datum_to_cbor">datum_to_cbor</a></code></li>
<li><code><a title="opshin.util.datum_to_json" href="#opshin.util.datum_to_json">datum_to_json</a></code></li>
<li><code><a title="opshin.util.distinct" href="#opshin.util.distinct">distinct</a></code></li>
<li><code><a title="opshin.util.externally_bound_vars" href="#opshin.util.externally_bound_vars">externally_bound_vars</a></code></li>
<li><code><a title="opshin.util.force_params" href="#opshin.util.force_params">force_params</a></code></li>
<li><code><a title="opshin.util.make_pattern" href="#opshin.util.make_pattern">make_pattern</a></code></li>
<li><code><a title="opshin.util.opshin_name_scheme_compatible_varname" href="#opshin.util.opshin_name_scheme_compatible_varname">opshin_name_scheme_compatible_varname</a></code></li>
<li><code><a title="opshin.util.patternize" href="#opshin.util.patternize">patternize</a></code></li>
<li><code><a title="opshin.util.read_vars" href="#opshin.util.read_vars">read_vars</a></code></li>
<li><code><a title="opshin.util.written_vars" href="#opshin.util.written_vars">written_vars</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opshin.util.CompilerError" href="#opshin.util.CompilerError">CompilerError</a></code></h4>
</li>
<li>
<h4><code><a title="opshin.util.CompilingNodeTransformer" href="#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></code></h4>
<ul class="">
<li><code><a title="opshin.util.CompilingNodeTransformer.step" href="#opshin.util.CompilingNodeTransformer.step">step</a></code></li>
<li><code><a title="opshin.util.CompilingNodeTransformer.visit" href="#opshin.util.CompilingNodeTransformer.visit">visit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.util.CompilingNodeVisitor" href="#opshin.util.CompilingNodeVisitor">CompilingNodeVisitor</a></code></h4>
<ul class="">
<li><code><a title="opshin.util.CompilingNodeVisitor.step" href="#opshin.util.CompilingNodeVisitor.step">step</a></code></li>
<li><code><a title="opshin.util.CompilingNodeVisitor.visit" href="#opshin.util.CompilingNodeVisitor.visit">visit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.util.NameReadCollector" href="#opshin.util.NameReadCollector">NameReadCollector</a></code></h4>
<ul class="two-column">
<li><code><a title="opshin.util.NameReadCollector.step" href="#opshin.util.NameReadCollector.step">step</a></code></li>
<li><code><a title="opshin.util.NameReadCollector.visit" href="#opshin.util.NameReadCollector.visit">visit</a></code></li>
<li><code><a title="opshin.util.NameReadCollector.visit_AnnAssign" href="#opshin.util.NameReadCollector.visit_AnnAssign">visit_AnnAssign</a></code></li>
<li><code><a title="opshin.util.NameReadCollector.visit_ClassDef" href="#opshin.util.NameReadCollector.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="opshin.util.NameReadCollector.visit_FunctionDef" href="#opshin.util.NameReadCollector.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="opshin.util.NameReadCollector.visit_Name" href="#opshin.util.NameReadCollector.visit_Name">visit_Name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.util.NameWriteCollector" href="#opshin.util.NameWriteCollector">NameWriteCollector</a></code></h4>
<ul class="">
<li><code><a title="opshin.util.NameWriteCollector.step" href="#opshin.util.NameWriteCollector.step">step</a></code></li>
<li><code><a title="opshin.util.NameWriteCollector.visit" href="#opshin.util.NameWriteCollector.visit">visit</a></code></li>
<li><code><a title="opshin.util.NameWriteCollector.visit_ClassDef" href="#opshin.util.NameWriteCollector.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="opshin.util.NameWriteCollector.visit_FunctionDef" href="#opshin.util.NameWriteCollector.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="opshin.util.NameWriteCollector.visit_Name" href="#opshin.util.NameWriteCollector.visit_Name">visit_Name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.util.NoOp" href="#opshin.util.NoOp">NoOp</a></code></h4>
<ul class="">
<li><code><a title="opshin.util.NoOp.visit" href="#opshin.util.NoOp.visit">visit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.util.TypedNodeTransformer" href="#opshin.util.TypedNodeTransformer">TypedNodeTransformer</a></code></h4>
<ul class="">
<li><code><a title="opshin.util.TypedNodeTransformer.visit" href="#opshin.util.TypedNodeTransformer.visit">visit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="opshin.util.TypedNodeVisitor" href="#opshin.util.TypedNodeVisitor">TypedNodeVisitor</a></code></h4>
<ul class="">
<li><code><a title="opshin.util.TypedNodeVisitor.visit" href="#opshin.util.TypedNodeVisitor.visit">visit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>