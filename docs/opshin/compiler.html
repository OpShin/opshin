<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/opshin/dev/docs/opshin_32.png" sizes="32x32" type="image/png">
<title>opshin.compiler API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/opshin" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>opshin.compiler</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy

from uplc.ast import data_from_cbor

from .compiler_config import DEFAULT_CONFIG
from .optimize.optimize_const_folding import OptimizeConstantFolding
from .optimize.optimize_remove_comments import OptimizeRemoveDeadconstants
from .rewrite.rewrite_augassign import RewriteAugAssign
from .rewrite.rewrite_cast_condition import RewriteConditions
from .rewrite.rewrite_comparison_chaining import RewriteComparisonChaining
from .rewrite.rewrite_empty_dicts import RewriteEmptyDicts
from .rewrite.rewrite_empty_lists import RewriteEmptyLists
from .rewrite.rewrite_forbidden_overwrites import RewriteForbiddenOverwrites
from .rewrite.rewrite_forbidden_return import RewriteForbiddenReturn
from .rewrite.rewrite_import import RewriteImport
from .rewrite.rewrite_import_dataclasses import RewriteImportDataclasses
from .rewrite.rewrite_import_hashlib import RewriteImportHashlib
from .rewrite.rewrite_import_integrity_check import RewriteImportIntegrityCheck
from .rewrite.rewrite_import_plutusdata import RewriteImportPlutusData
from .rewrite.rewrite_import_typing import RewriteImportTyping
from .rewrite.rewrite_import_uplc_builtins import RewriteImportUPLCBuiltins
from .rewrite.rewrite_inject_builtins import RewriteInjectBuiltins
from .rewrite.rewrite_inject_builtin_constr import RewriteInjectBuiltinsConstr
from .rewrite.rewrite_orig_name import RewriteOrigName
from .rewrite.rewrite_remove_type_stuff import RewriteRemoveTypeStuff
from .rewrite.rewrite_scoping import RewriteScoping
from .rewrite.rewrite_subscript38 import RewriteSubscript38
from .rewrite.rewrite_tuple_assign import RewriteTupleAssign
from .optimize.optimize_remove_pass import OptimizeRemovePass
from .optimize.optimize_remove_deadvars import OptimizeRemoveDeadvars, NameLoadCollector
from .type_inference import *
from .util import (
    CompilingNodeTransformer,
    NoOp,
)
from .typed_ast import (
    transform_ext_params_map,
    transform_output_map,
    RawPlutoExpr,
)


BoolOpMap = {
    And: plt.And,
    Or: plt.Or,
}


def rec_constant_map_data(c):
    if isinstance(c, bool):
        return uplc.PlutusInteger(int(c))
    if isinstance(c, int):
        return uplc.PlutusInteger(c)
    if isinstance(c, type(None)):
        return uplc.PlutusConstr(0, [])
    if isinstance(c, bytes):
        return uplc.PlutusByteString(c)
    if isinstance(c, str):
        return uplc.PlutusByteString(c.encode())
    if isinstance(c, list):
        return uplc.PlutusList([rec_constant_map_data(ce) for ce in c])
    if isinstance(c, dict):
        return uplc.PlutusMap(
            dict(
                zip(
                    (rec_constant_map_data(ce) for ce in c.keys()),
                    (rec_constant_map_data(ce) for ce in c.values()),
                )
            )
        )
    raise NotImplementedError(f&#34;Unsupported constant type {type(c)}&#34;)


def rec_constant_map(c):
    if isinstance(c, bool):
        return uplc.BuiltinBool(c)
    if isinstance(c, int):
        return uplc.BuiltinInteger(c)
    if isinstance(c, type(None)):
        return uplc.BuiltinUnit()
    if isinstance(c, bytes):
        return uplc.BuiltinByteString(c)
    if isinstance(c, str):
        return uplc.BuiltinString(c)
    if isinstance(c, list):
        return uplc.BuiltinList([rec_constant_map(ce) for ce in c])
    if isinstance(c, dict):
        return uplc.BuiltinList(
            [
                uplc.BuiltinPair(*p)
                for p in zip(
                    (rec_constant_map_data(ce) for ce in c.keys()),
                    (rec_constant_map_data(ce) for ce in c.values()),
                )
            ]
        )
    if isinstance(c, PlutusData):
        return data_from_cbor(c.to_cbor())
    raise NotImplementedError(f&#34;Unsupported constant type {type(c)}&#34;)


def wrap_validator_double_function(x: plt.AST, pass_through: int = 0):
    &#34;&#34;&#34;
    Wraps the validator function to enable a double function as minting script

    pass_through defines how many parameters x would normally take and should be passed through to x
    &#34;&#34;&#34;
    return OLambda(
        [f&#34;v{i}&#34; for i in range(pass_through)] + [&#34;a0&#34;, &#34;a1&#34;],
        OLet(
            [(&#34;p&#34;, plt.Apply(x, *(OVar(f&#34;v{i}&#34;) for i in range(pass_through))))],
            plt.Ite(
                # if the second argument has constructor 0 = script context
                plt.DelayedChooseData(
                    OVar(&#34;a1&#34;),
                    plt.EqualsInteger(plt.Constructor(OVar(&#34;a1&#34;)), plt.Integer(0)),
                    plt.Bool(False),
                    plt.Bool(False),
                    plt.Bool(False),
                    plt.Bool(False),
                ),
                # call the validator with a0, a1, and plug in &#34;Nothing&#34; for data
                plt.Apply(
                    OVar(&#34;p&#34;),
                    plt.UPLCConstant(uplc.PlutusConstr(6, [])),
                    OVar(&#34;a0&#34;),
                    OVar(&#34;a1&#34;),
                ),
                # else call the validator with a0, a1 and return (now partially bound)
                plt.Apply(OVar(&#34;p&#34;), OVar(&#34;a0&#34;), OVar(&#34;a1&#34;)),
            ),
        ),
    )


CallAST = typing.Callable[[plt.AST], plt.AST]


class PlutoCompiler(CompilingNodeTransformer):
    &#34;&#34;&#34;
    Expects a TypedAST and returns UPLC/Pluto like code
    &#34;&#34;&#34;

    step = &#34;Compiling python statements to UPLC&#34;

    def __init__(self, force_three_params=False, validator_function_name=&#34;validator&#34;):
        # parameters
        self.force_three_params = force_three_params
        self.validator_function_name = validator_function_name
        # marked knowledge during compilation
        self.current_function_typ: typing.List[FunctionType] = []

    def visit_sequence(self, node_seq: typing.List[typedstmt]) -&gt; CallAST:
        def g(s: plt.AST):
            for n in reversed(node_seq):
                compiled_stmt = self.visit(n)
                s = compiled_stmt(s)
            return s

        return g

    def visit_BinOp(self, node: TypedBinOp) -&gt; plt.AST:
        op = node.left.typ.binop(node.op, node.right)
        return plt.Apply(
            op,
            self.visit(node.left),
            self.visit(node.right),
        )

    def visit_BoolOp(self, node: TypedBoolOp) -&gt; plt.AST:
        op = BoolOpMap.get(type(node.op))
        assert len(node.values) &gt;= 2, &#34;Need to compare at least to values&#34;
        ops = op(
            self.visit(node.values[0]),
            self.visit(node.values[1]),
        )
        for v in node.values[2:]:
            ops = op(ops, self.visit(v))
        return ops

    def visit_UnaryOp(self, node: TypedUnaryOp) -&gt; plt.AST:
        op = node.operand.typ.unop(node.op)
        return plt.Apply(
            op,
            self.visit(node.operand),
        )

    def visit_Compare(self, node: TypedCompare) -&gt; plt.AST:
        assert len(node.ops) == 1, &#34;Only single comparisons are supported&#34;
        assert len(node.comparators) == 1, &#34;Only single comparisons are supported&#34;
        cmpop = node.ops[0]
        comparator = node.comparators[0].typ
        op = node.left.typ.cmp(cmpop, comparator)
        return plt.Apply(
            op,
            self.visit(node.left),
            self.visit(node.comparators[0]),
        )

    def visit_Module(self, node: TypedModule) -&gt; plt.AST:
        # extract actually read variables by each function
        if self.validator_function_name is not None:
            # for validators find main function
            # TODO can use more sophisiticated procedure here i.e. functions marked by comment
            main_fun: typing.Optional[InstanceType] = None
            for s in node.body:
                if (
                    isinstance(s, FunctionDef)
                    and s.orig_name == self.validator_function_name
                ):
                    main_fun = s
            assert (
                main_fun is not None
            ), f&#34;Could not find function named {self.validator_function_name}&#34;
            main_fun_typ: FunctionType = main_fun.typ.typ
            assert isinstance(
                main_fun_typ, FunctionType
            ), f&#34;Variable named {self.validator_function_name} is not of type function&#34;

            # check if this is a contract written to double function
            enable_double_func_mint_spend = False
            if len(main_fun_typ.argtyps) &gt;= 3 and self.force_three_params:
                # check if is possible
                second_last_arg = main_fun_typ.argtyps[-2]
                assert isinstance(
                    second_last_arg, InstanceType
                ), &#34;Can not pass Class into validator&#34;
                if isinstance(second_last_arg.typ, UnionType):
                    possible_types = second_last_arg.typ.typs
                else:
                    possible_types = [second_last_arg.typ]
                if any(isinstance(t, UnitType) for t in possible_types):
                    OPSHIN_LOGGER.warning(
                        &#34;The redeemer is annotated to be &#39;None&#39;. This value is usually encoded in PlutusData with constructor id 0 and no fields. If you want the script to double function as minting and spending script, annotate the second argument with &#39;NoRedeemer&#39;.&#34;
                    )
                enable_double_func_mint_spend = not any(
                    (isinstance(t, RecordType) and t.record.constructor == 0)
                    or isinstance(t, UnitType)
                    for t in possible_types
                )
                if not enable_double_func_mint_spend:
                    OPSHIN_LOGGER.warning(
                        &#34;The second argument to the validator function potentially has constructor id 0. The validator will not be able to double function as minting script and spending script.&#34;
                    )

            body = node.body + (
                [
                    TypedReturn(
                        TypedCall(
                            func=Name(
                                id=main_fun.name,
                                typ=InstanceType(main_fun_typ),
                                ctx=Load(),
                            ),
                            typ=main_fun_typ.rettyp,
                            args=[
                                RawPlutoExpr(
                                    expr=transform_ext_params_map(a)(
                                        OVar(f&#34;val_param{i}&#34;)
                                    ),
                                    typ=a,
                                )
                                for i, a in enumerate(main_fun_typ.argtyps)
                            ],
                        )
                    )
                ]
            )
            self.current_function_typ.append(FunctionType([], InstanceType(AnyType())))
            name_load_visitor = NameLoadCollector()
            name_load_visitor.visit(node)
            all_vs = sorted(set(all_vars(node)) | set(name_load_visitor.loaded.keys()))

            # write all variables that are ever read
            # once at the beginning so that we can always access them (only potentially causing a nameerror at runtime)
            validator = SafeOLambda(
                [f&#34;val_param{i}&#34; for i, _ in enumerate(main_fun_typ.argtyps)],
                plt.Let(
                    [
                        (
                            x,
                            plt.Delay(
                                plt.TraceError(f&#34;NameError: {map_to_orig_name(x)}&#34;)
                            ),
                        )
                        for x in all_vs
                    ],
                    self.visit_sequence(body)(
                        plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
                    ),
                ),
            )
            self.current_function_typ.pop()
            if enable_double_func_mint_spend:
                validator = wrap_validator_double_function(
                    validator, pass_through=len(main_fun_typ.argtyps) - 3
                )
            elif self.force_three_params:
                # Error if the double function is enforced but not possible
                raise RuntimeError(
                    &#34;The contract can not always detect if it was passed three or two parameters on-chain.&#34;
                )
        else:
            name_load_visitor = NameLoadCollector()
            name_load_visitor.visit(node)
            all_vs = sorted(set(all_vars(node)) | set(name_load_visitor.loaded.keys()))

            body = node.body
            # write all variables that are ever read
            # once at the beginning so that we can always access them (only potentially causing a nameerror at runtime)
            validator = plt.Let(
                [
                    (
                        x,
                        plt.Delay(plt.TraceError(f&#34;NameError: {map_to_orig_name(x)}&#34;)),
                    )
                    for x in all_vs
                ],
                self.visit_sequence(body)(
                    plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
                ),
            )

        cp = plt.Program((1, 0, 0), validator)
        return cp

    def visit_Constant(self, node: TypedConstant) -&gt; plt.AST:
        if isinstance(node.value, bytes) and node.value != b&#34;&#34;:
            try:
                bytes.fromhex(node.value.decode())
            except ValueError:
                pass
            else:
                OPSHIN_LOGGER.warning(
                    f&#34;The string {node.value} looks like it is supposed to be a hex-encoded bytestring but is actually utf8-encoded. Try using `bytes.fromhex(&#39;{node.value.decode()}&#39;)` instead.&#34;
                )
        plt_val = plt.UPLCConstant(rec_constant_map(node.value))
        return plt_val

    def visit_NoneType(self, _: typing.Optional[typing.Any]) -&gt; plt.AST:
        return plt.Unit()

    def visit_Assign(self, node: TypedAssign) -&gt; CallAST:
        assert (
            len(node.targets) == 1
        ), &#34;Assignments to more than one variable not supported yet&#34;
        assert isinstance(
            node.targets[0], Name
        ), &#34;Assignments to other things then names are not supported&#34;
        compiled_e = self.visit(node.value)
        varname = node.targets[0].id
        # first evaluate the term, then wrap in a delay
        return lambda x: plt.Let(
            [
                (opshin_name_scheme_compatible_varname(varname), compiled_e),
                (varname, plt.Delay(OVar(varname))),
            ],
            x,
        )

    def visit_AnnAssign(self, node: AnnAssign) -&gt; CallAST:
        assert isinstance(
            node.target, Name
        ), &#34;Assignments to other things then names are not supported&#34;
        assert isinstance(
            node.target.typ, InstanceType
        ), &#34;Can only assign instances to instances&#34;
        val = self.visit(node.value)
        if isinstance(node.value.typ, InstanceType) and isinstance(
            node.value.typ.typ, AnyType
        ):
            # we need to map this as it will originate from PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to builtin values
            val = transform_ext_params_map(node.target.typ)(val)
        if isinstance(node.target.typ, InstanceType) and isinstance(
            node.target.typ.typ, AnyType
        ):
            # we need to map this back as it will be treated as PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to from builtin values
            val = transform_output_map(node.value.typ)(val)
        return lambda x: plt.Let(
            [
                (opshin_name_scheme_compatible_varname(node.target.id), val),
                (node.target.id, plt.Delay(OVar(node.target.id))),
            ],
            x,
        )

    def visit_Name(self, node: TypedName) -&gt; plt.AST:
        # depending on load or store context, return the value of the variable or its name
        if not isinstance(node.ctx, Load):
            raise NotImplementedError(f&#34;Context {node.ctx} not supported&#34;)
        if isinstance(node.typ, ClassType):
            # if this is not an instance but a class, call the constructor
            return node.typ.constr()
        return plt.Force(plt.Var(node.id))

    def visit_Expr(self, node: TypedExpr) -&gt; CallAST:
        # we exploit UPLCs eager evaluation here
        # the expression is computed even though its value is eventually discarded
        # Note this really only makes sense for Trace
        # we use an invalid name here to avoid conflicts
        return lambda x: plt.Apply(OLambda([&#34;0&#34;], x), self.visit(node.value))

    def visit_Call(self, node: TypedCall) -&gt; plt.AST:
        # compiled_args = &#34; &#34;.join(f&#34;({self.visit(a)} {STATEMONAD})&#34; for a in node.args)
        # return rf&#34;(\{STATEMONAD} -&gt; ({self.visit(node.func)} {compiled_args})&#34;
        # TODO function is actually not of type polymorphic function type here anymore
        if isinstance(node.func.typ, PolymorphicFunctionInstanceType):
            # edge case for weird builtins that are polymorphic
            func_plt = force_params(
                node.func.typ.polymorphic_function.impl_from_args(
                    node.func.typ.typ.argtyps
                )
            )
            bind_self = None
        else:
            assert isinstance(node.func.typ, InstanceType) and isinstance(
                node.func.typ.typ, FunctionType
            )
            func_plt = self.visit(node.func)
            bind_self = node.func.typ.typ.bind_self
        bound_vs = sorted(list(node.func.typ.typ.bound_vars.keys()))
        args = []
        for a, t in zip(node.args, node.func.typ.typ.argtyps):
            assert isinstance(t, InstanceType)
            # pass in all arguments evaluated with the statemonad
            a_int = self.visit(a)
            if isinstance(t.typ, AnyType):
                # if the function expects input of generic type data, wrap data before passing it inside
                a_int = transform_output_map(a.typ)(a_int)
            args.append(a_int)
        # First assign to let to ensure that the arguments are evaluated before the call, but need to delay
        # as this is a variable assignment
        # Also bring all states of variables read inside the function into scope / update with value in current state
        # before call to simulate statemonad with current state being passed in
        return OLet(
            [(f&#34;p{i}&#34;, a) for i, a in enumerate(args)],
            SafeApply(
                func_plt,
                *([plt.Var(bind_self)] if bind_self is not None else []),
                *[plt.Var(n) for n in bound_vs],
                *[plt.Delay(OVar(f&#34;p{i}&#34;)) for i in range(len(args))],
            ),
        )

    def visit_FunctionDef(self, node: TypedFunctionDef) -&gt; CallAST:
        body = node.body.copy()
        # defaults to returning None if there is no return statement
        if node.typ.typ.rettyp.typ == AnyType():
            ret_val = plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
        else:
            ret_val = plt.Unit()
        read_vs = sorted(list(node.typ.typ.bound_vars.keys()))
        if node.typ.typ.bind_self is not None:
            read_vs.insert(0, node.typ.typ.bind_self)
        self.current_function_typ.append(node.typ.typ)
        compiled_body = self.visit_sequence(body)(ret_val)
        self.current_function_typ.pop()
        return lambda x: plt.Let(
            [
                (
                    node.name,
                    plt.Delay(
                        SafeLambda(
                            read_vs + [a.arg for a in node.args.args],
                            compiled_body,
                        )
                    ),
                )
            ],
            x,
        )

    def visit_While(self, node: TypedWhile) -&gt; CallAST:
        # the while loop calls itself, updating the values at overwritten names
        # by overwriting them with arguments to its self-recall
        if node.orelse:
            # If there is orelse, transform it to an appended sequence (TODO check if this is correct)
            cn = copy(node)
            cn.orelse = []
            return self.visit_sequence([cn] + node.orelse)
        compiled_c = self.visit(node.test)
        compiled_s = self.visit_sequence(node.body)
        written_vs = written_vars(node)
        pwritten_vs = [plt.Var(x) for x in written_vs]
        s_fun = lambda x: plt.Lambda(
            [opshin_name_scheme_compatible_varname(&#34;while&#34;)] + written_vs,
            plt.Ite(
                compiled_c,
                compiled_s(
                    plt.Apply(
                        OVar(&#34;while&#34;),
                        OVar(&#34;while&#34;),
                        *deepcopy(pwritten_vs),
                    )
                ),
                x,
            ),
        )

        return lambda x: OLet(
            [
                (&#34;adjusted_next&#34;, SafeLambda(written_vs, x)),
                (
                    &#34;while&#34;,
                    s_fun(SafeApply(OVar(&#34;adjusted_next&#34;), *deepcopy(pwritten_vs))),
                ),
            ],
            plt.Apply(OVar(&#34;while&#34;), OVar(&#34;while&#34;), *deepcopy(pwritten_vs)),
        )

    def visit_For(self, node: TypedFor) -&gt; CallAST:
        if node.orelse:
            # If there is orelse, transform it to an appended sequence (TODO check if this is correct)
            cn = copy(node)
            cn.orelse = []
            return self.visit_sequence([cn] + node.orelse)
        assert isinstance(node.iter.typ, InstanceType)
        if isinstance(node.iter.typ.typ, ListType):
            assert isinstance(
                node.target, Name
            ), &#34;Can only assign value to singleton element&#34;
            compiled_s = self.visit_sequence(node.body)
            compiled_iter = self.visit(node.iter)
            written_vs = written_vars(node)
            pwritten_vs = [plt.Var(x) for x in written_vs]
            s_fun = lambda x: plt.Lambda(
                [
                    opshin_name_scheme_compatible_varname(&#34;for&#34;),
                    opshin_name_scheme_compatible_varname(&#34;iter&#34;),
                ]
                + written_vs,
                plt.IteNullList(
                    OVar(&#34;iter&#34;),
                    x,
                    plt.Let(
                        [(node.target.id, plt.Delay(plt.HeadList(OVar(&#34;iter&#34;))))],
                        compiled_s(
                            plt.Apply(
                                OVar(&#34;for&#34;),
                                OVar(&#34;for&#34;),
                                plt.TailList(OVar(&#34;iter&#34;)),
                                *deepcopy(pwritten_vs),
                            )
                        ),
                    ),
                ),
            )
            return lambda x: OLet(
                [
                    (&#34;adjusted_next&#34;, plt.Lambda([node.target.id] + written_vs, x)),
                    (
                        &#34;for&#34;,
                        s_fun(
                            plt.Apply(
                                OVar(&#34;adjusted_next&#34;),
                                plt.Var(node.target.id),
                                *deepcopy(pwritten_vs),
                            )
                        ),
                    ),
                ],
                plt.Apply(
                    OVar(&#34;for&#34;),
                    OVar(&#34;for&#34;),
                    compiled_iter,
                    *deepcopy(pwritten_vs),
                ),
            )
        raise NotImplementedError(
            &#34;Compilation of for statements for anything but lists not implemented yet&#34;
        )

    def visit_If(self, node: TypedIf) -&gt; CallAST:
        written_vs = written_vars(node)
        pwritten_vs = [plt.Var(x) for x in written_vs]
        return lambda x: OLet(
            [(&#34;adjusted_next&#34;, SafeLambda(written_vs, x))],
            plt.Ite(
                self.visit(node.test),
                self.visit_sequence(node.body)(
                    SafeApply(OVar(&#34;adjusted_next&#34;), *deepcopy(pwritten_vs))
                ),
                self.visit_sequence(node.orelse)(
                    SafeApply(OVar(&#34;adjusted_next&#34;), *deepcopy(pwritten_vs))
                ),
            ),
        )

    def visit_Return(self, node: TypedReturn) -&gt; CallAST:
        value_plt = self.visit(node.value)
        assert self.current_function_typ, &#34;Can not handle Return outside of a function&#34;
        if isinstance(self.current_function_typ[-1].rettyp.typ, AnyType):
            value_plt = transform_output_map(node.value.typ)(value_plt)
        return lambda _: value_plt

    def visit_Pass(self, node: TypedPass) -&gt; CallAST:
        return self.visit_sequence([])

    def visit_Subscript(self, node: TypedSubscript) -&gt; plt.AST:
        assert isinstance(
            node.value.typ, InstanceType
        ), &#34;Can only access elements of instances, not classes&#34;
        if isinstance(node.value.typ.typ, TupleType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for tuples is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for tuples is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += len(node.value.typ.typ.typs)
            assert isinstance(node.ctx, Load), &#34;Tuples are read-only&#34;
            return plt.FunctionalTupleAccess(
                self.visit(node.value),
                index,
                len(node.value.typ.typ.typs),
            )
        if isinstance(node.value.typ.typ, PairType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for pairs is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for pairs is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += 2
            assert isinstance(node.ctx, Load), &#34;Pairs are read-only&#34;
            assert (
                0 &lt;= index &lt; 2
            ), f&#34;Pairs only have 2 elements, index should be 0 or 1, is {node.slice.value}&#34;
            member_func = plt.FstPair if index == 0 else plt.SndPair
            # the content of pairs is always Data, so we need to unwrap
            member_typ = node.typ
            return transform_ext_params_map(member_typ)(
                member_func(
                    self.visit(node.value),
                ),
            )
        if isinstance(node.value.typ.typ, ListType):
            if not isinstance(node.slice, Slice):
                assert (
                    node.slice.typ == IntegerInstanceType
                ), &#34;Only single element list index access supported&#34;
                return OLet(
                    [
                        (
                            &#34;l&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_i&#34;), plt.LengthList(OVar(&#34;l&#34;))
                                ),
                                OVar(&#34;raw_i&#34;),
                            ),
                        ),
                    ],
                    plt.IndexAccessList(OVar(&#34;l&#34;), OVar(&#34;i&#34;)),
                )
            else:
                return OLet(
                    [
                        (
                            &#34;xs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice.lower),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_i&#34;),
                                    plt.LengthList(OVar(&#34;xs&#34;)),
                                ),
                                OVar(&#34;raw_i&#34;),
                            ),
                        ),
                        (
                            &#34;raw_j&#34;,
                            self.visit(node.slice.upper),
                        ),
                        (
                            &#34;j&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_j&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_j&#34;),
                                    plt.LengthList(OVar(&#34;xs&#34;)),
                                ),
                                OVar(&#34;raw_j&#34;),
                            ),
                        ),
                        (
                            &#34;drop&#34;,
                            plt.Ite(
                                plt.LessThanEqualsInteger(OVar(&#34;i&#34;), plt.Integer(0)),
                                plt.Integer(0),
                                OVar(&#34;i&#34;),
                            ),
                        ),
                        (
                            &#34;take&#34;,
                            plt.SubtractInteger(OVar(&#34;j&#34;), OVar(&#34;drop&#34;)),
                        ),
                    ],
                    plt.Ite(
                        plt.LessThanEqualsInteger(OVar(&#34;j&#34;), OVar(&#34;i&#34;)),
                        empty_list(node.value.typ.typ.typ),
                        plt.SliceList(
                            OVar(&#34;drop&#34;),
                            OVar(&#34;take&#34;),
                            OVar(&#34;xs&#34;),
                            empty_list(node.value.typ.typ.typ),
                        ),
                    ),
                )
        elif isinstance(node.value.typ.typ, DictType):
            dict_typ = node.value.typ.typ
            if not isinstance(node.slice, Slice):
                return OLet(
                    [
                        (
                            &#34;key&#34;,
                            self.visit(node.slice),
                        )
                    ],
                    transform_ext_params_map(dict_typ.value_typ)(
                        plt.SndPair(
                            plt.FindList(
                                self.visit(node.value),
                                OLambda(
                                    [&#34;x&#34;],
                                    plt.EqualsData(
                                        transform_output_map(dict_typ.key_typ)(
                                            OVar(&#34;key&#34;)
                                        ),
                                        plt.FstPair(OVar(&#34;x&#34;)),
                                    ),
                                ),
                                plt.TraceError(&#34;KeyError&#34;),
                            )
                        ),
                    ),
                )
        elif isinstance(node.value.typ.typ, ByteStringType):
            if not isinstance(node.slice, Slice):
                return OLet(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_ix&#34;,
                            self.visit(node.slice),
                        ),
                        (
                            &#34;ix&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_ix&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_ix&#34;),
                                    plt.LengthOfByteString(OVar(&#34;bs&#34;)),
                                ),
                                OVar(&#34;raw_ix&#34;),
                            ),
                        ),
                    ],
                    plt.IndexByteString(OVar(&#34;bs&#34;), OVar(&#34;ix&#34;)),
                )
            elif isinstance(node.slice, Slice):
                return OLet(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice.lower),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_i&#34;),
                                    plt.LengthOfByteString(OVar(&#34;bs&#34;)),
                                ),
                                OVar(&#34;raw_i&#34;),
                            ),
                        ),
                        (
                            &#34;raw_j&#34;,
                            self.visit(node.slice.upper),
                        ),
                        (
                            &#34;j&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_j&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_j&#34;),
                                    plt.LengthOfByteString(OVar(&#34;bs&#34;)),
                                ),
                                OVar(&#34;raw_j&#34;),
                            ),
                        ),
                        (
                            &#34;drop&#34;,
                            plt.Ite(
                                plt.LessThanEqualsInteger(OVar(&#34;i&#34;), plt.Integer(0)),
                                plt.Integer(0),
                                OVar(&#34;i&#34;),
                            ),
                        ),
                        (
                            &#34;take&#34;,
                            plt.SubtractInteger(OVar(&#34;j&#34;), OVar(&#34;drop&#34;)),
                        ),
                    ],
                    plt.Ite(
                        plt.LessThanEqualsInteger(OVar(&#34;j&#34;), OVar(&#34;i&#34;)),
                        plt.ByteString(b&#34;&#34;),
                        plt.SliceByteString(
                            OVar(&#34;drop&#34;),
                            OVar(&#34;take&#34;),
                            OVar(&#34;bs&#34;),
                        ),
                    ),
                )
        raise NotImplementedError(
            f&#39;Could not implement subscript &#34;{node.slice}&#34; of &#34;{node.value}&#34;&#39;
        )

    def visit_Tuple(self, node: TypedTuple) -&gt; plt.AST:
        return plt.FunctionalTuple(*(self.visit(e) for e in node.elts))

    def visit_ClassDef(self, node: TypedClassDef) -&gt; CallAST:
        return lambda x: plt.Let([(node.name, plt.Delay(node.class_typ.constr()))], x)

    def visit_Attribute(self, node: TypedAttribute) -&gt; plt.AST:
        assert isinstance(
            node.value.typ, InstanceType
        ), &#34;Can only access attributes of instances&#34;
        obj = self.visit(node.value)
        attr = node.value.typ.attribute(node.attr)
        return plt.Apply(attr, obj)

    def visit_Assert(self, node: TypedAssert) -&gt; CallAST:
        return lambda x: plt.Ite(
            self.visit(node.test),
            x,
            plt.Apply(
                plt.Error(),
                (
                    plt.Trace(self.visit(node.msg), plt.Unit())
                    if node.msg is not None
                    else plt.Unit()
                ),
            ),
        )

    def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; plt.AST:
        return node.expr

    def visit_List(self, node: TypedList) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, ListType)
        l = empty_list(node.typ.typ.typ)
        for e in reversed(node.elts):
            l = plt.MkCons(self.visit(e), l)
        return l

    def visit_Dict(self, node: TypedDict) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, DictType)
        key_type = node.typ.typ.key_typ
        value_type = node.typ.typ.value_typ
        l = plt.EmptyDataPairList()
        for k, v in zip(node.keys, node.values):
            l = plt.MkCons(
                plt.MkPairData(
                    transform_output_map(key_type)(
                        self.visit(k),
                    ),
                    transform_output_map(value_type)(
                        self.visit(v),
                    ),
                ),
                l,
            )
        return l

    def visit_IfExp(self, node: TypedIfExp) -&gt; plt.AST:
        return plt.Ite(
            self.visit(node.test),
            self.visit(node.body),
            self.visit(node.orelse),
        )

    def visit_ListComp(self, node: TypedListComp) -&gt; plt.AST:
        assert len(node.generators) == 1, &#34;Currently only one generator supported&#34;
        gen = node.generators[0]
        assert isinstance(gen.iter.typ, InstanceType), &#34;Only lists are valid generators&#34;
        assert isinstance(gen.iter.typ.typ, ListType), &#34;Only lists are valid generators&#34;
        assert isinstance(
            gen.target, Name
        ), &#34;Can only assign value to singleton element&#34;
        lst = self.visit(gen.iter)
        ifs = None
        for ifexpr in gen.ifs:
            if ifs is None:
                ifs = self.visit(ifexpr)
            else:
                ifs = plt.And(ifs, self.visit(ifexpr))
        map_fun = OLambda(
            [&#34;x&#34;],
            plt.Let(
                [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                self.visit(node.elt),
            ),
        )
        empty_list_con = empty_list(node.elt.typ)
        if ifs is not None:
            filter_fun = OLambda(
                [&#34;x&#34;],
                plt.Let(
                    [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                    ifs,
                ),
            )
            return plt.MapFilterList(
                lst,
                filter_fun,
                map_fun,
                empty_list_con,
            )
        else:
            return plt.MapList(
                lst,
                map_fun,
                empty_list_con,
            )

    def visit_DictComp(self, node: TypedDictComp) -&gt; plt.AST:
        assert len(node.generators) == 1, &#34;Currently only one generator supported&#34;
        gen = node.generators[0]
        assert isinstance(gen.iter.typ, InstanceType), &#34;Only lists are valid generators&#34;
        assert isinstance(gen.iter.typ.typ, ListType), &#34;Only lists are valid generators&#34;
        assert isinstance(
            gen.target, Name
        ), &#34;Can only assign value to singleton element&#34;
        lst = self.visit(gen.iter)
        ifs = None
        for ifexpr in gen.ifs:
            if ifs is None:
                ifs = self.visit(ifexpr)
            else:
                ifs = plt.And(ifs, self.visit(ifexpr))
        map_fun = OLambda(
            [&#34;x&#34;],
            plt.Let(
                [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                plt.MkPairData(
                    transform_output_map(node.key.typ)(
                        self.visit(node.key),
                    ),
                    transform_output_map(node.value.typ)(
                        self.visit(node.value),
                    ),
                ),
            ),
        )
        empty_list_con = plt.EmptyDataPairList()
        if ifs is not None:
            filter_fun = OLambda(
                [&#34;x&#34;],
                plt.Let(
                    [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                    ifs,
                ),
            )
            return plt.MapFilterList(
                lst,
                filter_fun,
                map_fun,
                empty_list_con,
            )
        else:
            return plt.MapList(
                lst,
                map_fun,
                empty_list_con,
            )

    def visit_FormattedValue(self, node: TypedFormattedValue) -&gt; plt.AST:
        return plt.Apply(
            node.value.typ.stringify(),
            self.visit(node.value),
        )

    def visit_JoinedStr(self, node: TypedJoinedStr) -&gt; plt.AST:
        joined_str = plt.Text(&#34;&#34;)
        for v in reversed(node.values):
            joined_str = plt.AppendString(self.visit(v), joined_str)
        return joined_str

    def generic_visit(self, node: AST) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not compile {node}&#34;)


def compile(
    prog: AST,
    filename=None,
    validator_function_name=&#34;validator&#34;,
    config=DEFAULT_CONFIG,
) -&gt; plt.Program:
    compile_pipeline = [
        # Important to call this one first - it imports all further files
        RewriteImport(filename=filename),
        # Rewrites that simplify the python code
        RewriteForbiddenReturn(),
        OptimizeConstantFolding() if config.constant_folding else NoOp(),
        RewriteSubscript38(),
        RewriteAugAssign(),
        RewriteComparisonChaining(),
        RewriteTupleAssign(),
        RewriteImportIntegrityCheck(),
        RewriteImportPlutusData(),
        RewriteImportHashlib(),
        RewriteImportTyping(),
        RewriteForbiddenOverwrites(),
        RewriteImportDataclasses(),
        RewriteInjectBuiltins(),
        RewriteConditions(),
        # Save the original names of variables
        RewriteOrigName(),
        RewriteScoping(),
        # The type inference needs to be run after complex python operations were rewritten
        AggressiveTypeInferencer(config.allow_isinstance_anything),
        # Rewrites that circumvent the type inference or use its results
        RewriteEmptyLists(),
        RewriteEmptyDicts(),
        RewriteImportUPLCBuiltins(),
        RewriteInjectBuiltinsConstr(),
        RewriteRemoveTypeStuff(),
        # Apply optimizations
        OptimizeRemoveDeadvars() if config.remove_dead_code else NoOp(),
        OptimizeRemoveDeadconstants() if config.remove_dead_code else NoOp(),
        OptimizeRemovePass(),
    ]
    for s in compile_pipeline:
        prog = s.visit(prog)
        prog = custom_fix_missing_locations(prog)

    # the compiler runs last
    s = PlutoCompiler(
        force_three_params=config.force_three_params,
        validator_function_name=validator_function_name,
    )
    prog = s.visit(prog)

    return prog</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opshin.compiler.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>prog:ast.AST, filename=None, validator_function_name='validator', config=CompilationConfig(compress_patterns=True, iterative_unfold_patterns=False, constant_index_access_list=True, constant_folding=False, allow_isinstance_anything=False, force_three_params=False, remove_dead_code=True)) >pluthon.pluthon_ast.Program</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.rec_constant_map"><code class="name flex">
<span>def <span class="ident">rec_constant_map</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.rec_constant_map_data"><code class="name flex">
<span>def <span class="ident">rec_constant_map_data</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.wrap_validator_double_function"><code class="name flex">
<span>def <span class="ident">wrap_validator_double_function</span></span>(<span>x:pluthon.pluthon_ast.AST, pass_through:int=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps the validator function to enable a double function as minting script</p>
<p>pass_through defines how many parameters x would normally take and should be passed through to x</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opshin.compiler.PlutoCompiler"><code class="flex name class">
<span>class <span class="ident">PlutoCompiler</span></span>
<span>(</span><span>force_three_params=False, validator_function_name='validator')</span>
</code></dt>
<dd>
<div class="desc"><p>Expects a TypedAST and returns UPLC/Pluto like code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlutoCompiler(CompilingNodeTransformer):
    &#34;&#34;&#34;
    Expects a TypedAST and returns UPLC/Pluto like code
    &#34;&#34;&#34;

    step = &#34;Compiling python statements to UPLC&#34;

    def __init__(self, force_three_params=False, validator_function_name=&#34;validator&#34;):
        # parameters
        self.force_three_params = force_three_params
        self.validator_function_name = validator_function_name
        # marked knowledge during compilation
        self.current_function_typ: typing.List[FunctionType] = []

    def visit_sequence(self, node_seq: typing.List[typedstmt]) -&gt; CallAST:
        def g(s: plt.AST):
            for n in reversed(node_seq):
                compiled_stmt = self.visit(n)
                s = compiled_stmt(s)
            return s

        return g

    def visit_BinOp(self, node: TypedBinOp) -&gt; plt.AST:
        op = node.left.typ.binop(node.op, node.right)
        return plt.Apply(
            op,
            self.visit(node.left),
            self.visit(node.right),
        )

    def visit_BoolOp(self, node: TypedBoolOp) -&gt; plt.AST:
        op = BoolOpMap.get(type(node.op))
        assert len(node.values) &gt;= 2, &#34;Need to compare at least to values&#34;
        ops = op(
            self.visit(node.values[0]),
            self.visit(node.values[1]),
        )
        for v in node.values[2:]:
            ops = op(ops, self.visit(v))
        return ops

    def visit_UnaryOp(self, node: TypedUnaryOp) -&gt; plt.AST:
        op = node.operand.typ.unop(node.op)
        return plt.Apply(
            op,
            self.visit(node.operand),
        )

    def visit_Compare(self, node: TypedCompare) -&gt; plt.AST:
        assert len(node.ops) == 1, &#34;Only single comparisons are supported&#34;
        assert len(node.comparators) == 1, &#34;Only single comparisons are supported&#34;
        cmpop = node.ops[0]
        comparator = node.comparators[0].typ
        op = node.left.typ.cmp(cmpop, comparator)
        return plt.Apply(
            op,
            self.visit(node.left),
            self.visit(node.comparators[0]),
        )

    def visit_Module(self, node: TypedModule) -&gt; plt.AST:
        # extract actually read variables by each function
        if self.validator_function_name is not None:
            # for validators find main function
            # TODO can use more sophisiticated procedure here i.e. functions marked by comment
            main_fun: typing.Optional[InstanceType] = None
            for s in node.body:
                if (
                    isinstance(s, FunctionDef)
                    and s.orig_name == self.validator_function_name
                ):
                    main_fun = s
            assert (
                main_fun is not None
            ), f&#34;Could not find function named {self.validator_function_name}&#34;
            main_fun_typ: FunctionType = main_fun.typ.typ
            assert isinstance(
                main_fun_typ, FunctionType
            ), f&#34;Variable named {self.validator_function_name} is not of type function&#34;

            # check if this is a contract written to double function
            enable_double_func_mint_spend = False
            if len(main_fun_typ.argtyps) &gt;= 3 and self.force_three_params:
                # check if is possible
                second_last_arg = main_fun_typ.argtyps[-2]
                assert isinstance(
                    second_last_arg, InstanceType
                ), &#34;Can not pass Class into validator&#34;
                if isinstance(second_last_arg.typ, UnionType):
                    possible_types = second_last_arg.typ.typs
                else:
                    possible_types = [second_last_arg.typ]
                if any(isinstance(t, UnitType) for t in possible_types):
                    OPSHIN_LOGGER.warning(
                        &#34;The redeemer is annotated to be &#39;None&#39;. This value is usually encoded in PlutusData with constructor id 0 and no fields. If you want the script to double function as minting and spending script, annotate the second argument with &#39;NoRedeemer&#39;.&#34;
                    )
                enable_double_func_mint_spend = not any(
                    (isinstance(t, RecordType) and t.record.constructor == 0)
                    or isinstance(t, UnitType)
                    for t in possible_types
                )
                if not enable_double_func_mint_spend:
                    OPSHIN_LOGGER.warning(
                        &#34;The second argument to the validator function potentially has constructor id 0. The validator will not be able to double function as minting script and spending script.&#34;
                    )

            body = node.body + (
                [
                    TypedReturn(
                        TypedCall(
                            func=Name(
                                id=main_fun.name,
                                typ=InstanceType(main_fun_typ),
                                ctx=Load(),
                            ),
                            typ=main_fun_typ.rettyp,
                            args=[
                                RawPlutoExpr(
                                    expr=transform_ext_params_map(a)(
                                        OVar(f&#34;val_param{i}&#34;)
                                    ),
                                    typ=a,
                                )
                                for i, a in enumerate(main_fun_typ.argtyps)
                            ],
                        )
                    )
                ]
            )
            self.current_function_typ.append(FunctionType([], InstanceType(AnyType())))
            name_load_visitor = NameLoadCollector()
            name_load_visitor.visit(node)
            all_vs = sorted(set(all_vars(node)) | set(name_load_visitor.loaded.keys()))

            # write all variables that are ever read
            # once at the beginning so that we can always access them (only potentially causing a nameerror at runtime)
            validator = SafeOLambda(
                [f&#34;val_param{i}&#34; for i, _ in enumerate(main_fun_typ.argtyps)],
                plt.Let(
                    [
                        (
                            x,
                            plt.Delay(
                                plt.TraceError(f&#34;NameError: {map_to_orig_name(x)}&#34;)
                            ),
                        )
                        for x in all_vs
                    ],
                    self.visit_sequence(body)(
                        plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
                    ),
                ),
            )
            self.current_function_typ.pop()
            if enable_double_func_mint_spend:
                validator = wrap_validator_double_function(
                    validator, pass_through=len(main_fun_typ.argtyps) - 3
                )
            elif self.force_three_params:
                # Error if the double function is enforced but not possible
                raise RuntimeError(
                    &#34;The contract can not always detect if it was passed three or two parameters on-chain.&#34;
                )
        else:
            name_load_visitor = NameLoadCollector()
            name_load_visitor.visit(node)
            all_vs = sorted(set(all_vars(node)) | set(name_load_visitor.loaded.keys()))

            body = node.body
            # write all variables that are ever read
            # once at the beginning so that we can always access them (only potentially causing a nameerror at runtime)
            validator = plt.Let(
                [
                    (
                        x,
                        plt.Delay(plt.TraceError(f&#34;NameError: {map_to_orig_name(x)}&#34;)),
                    )
                    for x in all_vs
                ],
                self.visit_sequence(body)(
                    plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
                ),
            )

        cp = plt.Program((1, 0, 0), validator)
        return cp

    def visit_Constant(self, node: TypedConstant) -&gt; plt.AST:
        if isinstance(node.value, bytes) and node.value != b&#34;&#34;:
            try:
                bytes.fromhex(node.value.decode())
            except ValueError:
                pass
            else:
                OPSHIN_LOGGER.warning(
                    f&#34;The string {node.value} looks like it is supposed to be a hex-encoded bytestring but is actually utf8-encoded. Try using `bytes.fromhex(&#39;{node.value.decode()}&#39;)` instead.&#34;
                )
        plt_val = plt.UPLCConstant(rec_constant_map(node.value))
        return plt_val

    def visit_NoneType(self, _: typing.Optional[typing.Any]) -&gt; plt.AST:
        return plt.Unit()

    def visit_Assign(self, node: TypedAssign) -&gt; CallAST:
        assert (
            len(node.targets) == 1
        ), &#34;Assignments to more than one variable not supported yet&#34;
        assert isinstance(
            node.targets[0], Name
        ), &#34;Assignments to other things then names are not supported&#34;
        compiled_e = self.visit(node.value)
        varname = node.targets[0].id
        # first evaluate the term, then wrap in a delay
        return lambda x: plt.Let(
            [
                (opshin_name_scheme_compatible_varname(varname), compiled_e),
                (varname, plt.Delay(OVar(varname))),
            ],
            x,
        )

    def visit_AnnAssign(self, node: AnnAssign) -&gt; CallAST:
        assert isinstance(
            node.target, Name
        ), &#34;Assignments to other things then names are not supported&#34;
        assert isinstance(
            node.target.typ, InstanceType
        ), &#34;Can only assign instances to instances&#34;
        val = self.visit(node.value)
        if isinstance(node.value.typ, InstanceType) and isinstance(
            node.value.typ.typ, AnyType
        ):
            # we need to map this as it will originate from PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to builtin values
            val = transform_ext_params_map(node.target.typ)(val)
        if isinstance(node.target.typ, InstanceType) and isinstance(
            node.target.typ.typ, AnyType
        ):
            # we need to map this back as it will be treated as PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to from builtin values
            val = transform_output_map(node.value.typ)(val)
        return lambda x: plt.Let(
            [
                (opshin_name_scheme_compatible_varname(node.target.id), val),
                (node.target.id, plt.Delay(OVar(node.target.id))),
            ],
            x,
        )

    def visit_Name(self, node: TypedName) -&gt; plt.AST:
        # depending on load or store context, return the value of the variable or its name
        if not isinstance(node.ctx, Load):
            raise NotImplementedError(f&#34;Context {node.ctx} not supported&#34;)
        if isinstance(node.typ, ClassType):
            # if this is not an instance but a class, call the constructor
            return node.typ.constr()
        return plt.Force(plt.Var(node.id))

    def visit_Expr(self, node: TypedExpr) -&gt; CallAST:
        # we exploit UPLCs eager evaluation here
        # the expression is computed even though its value is eventually discarded
        # Note this really only makes sense for Trace
        # we use an invalid name here to avoid conflicts
        return lambda x: plt.Apply(OLambda([&#34;0&#34;], x), self.visit(node.value))

    def visit_Call(self, node: TypedCall) -&gt; plt.AST:
        # compiled_args = &#34; &#34;.join(f&#34;({self.visit(a)} {STATEMONAD})&#34; for a in node.args)
        # return rf&#34;(\{STATEMONAD} -&gt; ({self.visit(node.func)} {compiled_args})&#34;
        # TODO function is actually not of type polymorphic function type here anymore
        if isinstance(node.func.typ, PolymorphicFunctionInstanceType):
            # edge case for weird builtins that are polymorphic
            func_plt = force_params(
                node.func.typ.polymorphic_function.impl_from_args(
                    node.func.typ.typ.argtyps
                )
            )
            bind_self = None
        else:
            assert isinstance(node.func.typ, InstanceType) and isinstance(
                node.func.typ.typ, FunctionType
            )
            func_plt = self.visit(node.func)
            bind_self = node.func.typ.typ.bind_self
        bound_vs = sorted(list(node.func.typ.typ.bound_vars.keys()))
        args = []
        for a, t in zip(node.args, node.func.typ.typ.argtyps):
            assert isinstance(t, InstanceType)
            # pass in all arguments evaluated with the statemonad
            a_int = self.visit(a)
            if isinstance(t.typ, AnyType):
                # if the function expects input of generic type data, wrap data before passing it inside
                a_int = transform_output_map(a.typ)(a_int)
            args.append(a_int)
        # First assign to let to ensure that the arguments are evaluated before the call, but need to delay
        # as this is a variable assignment
        # Also bring all states of variables read inside the function into scope / update with value in current state
        # before call to simulate statemonad with current state being passed in
        return OLet(
            [(f&#34;p{i}&#34;, a) for i, a in enumerate(args)],
            SafeApply(
                func_plt,
                *([plt.Var(bind_self)] if bind_self is not None else []),
                *[plt.Var(n) for n in bound_vs],
                *[plt.Delay(OVar(f&#34;p{i}&#34;)) for i in range(len(args))],
            ),
        )

    def visit_FunctionDef(self, node: TypedFunctionDef) -&gt; CallAST:
        body = node.body.copy()
        # defaults to returning None if there is no return statement
        if node.typ.typ.rettyp.typ == AnyType():
            ret_val = plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
        else:
            ret_val = plt.Unit()
        read_vs = sorted(list(node.typ.typ.bound_vars.keys()))
        if node.typ.typ.bind_self is not None:
            read_vs.insert(0, node.typ.typ.bind_self)
        self.current_function_typ.append(node.typ.typ)
        compiled_body = self.visit_sequence(body)(ret_val)
        self.current_function_typ.pop()
        return lambda x: plt.Let(
            [
                (
                    node.name,
                    plt.Delay(
                        SafeLambda(
                            read_vs + [a.arg for a in node.args.args],
                            compiled_body,
                        )
                    ),
                )
            ],
            x,
        )

    def visit_While(self, node: TypedWhile) -&gt; CallAST:
        # the while loop calls itself, updating the values at overwritten names
        # by overwriting them with arguments to its self-recall
        if node.orelse:
            # If there is orelse, transform it to an appended sequence (TODO check if this is correct)
            cn = copy(node)
            cn.orelse = []
            return self.visit_sequence([cn] + node.orelse)
        compiled_c = self.visit(node.test)
        compiled_s = self.visit_sequence(node.body)
        written_vs = written_vars(node)
        pwritten_vs = [plt.Var(x) for x in written_vs]
        s_fun = lambda x: plt.Lambda(
            [opshin_name_scheme_compatible_varname(&#34;while&#34;)] + written_vs,
            plt.Ite(
                compiled_c,
                compiled_s(
                    plt.Apply(
                        OVar(&#34;while&#34;),
                        OVar(&#34;while&#34;),
                        *deepcopy(pwritten_vs),
                    )
                ),
                x,
            ),
        )

        return lambda x: OLet(
            [
                (&#34;adjusted_next&#34;, SafeLambda(written_vs, x)),
                (
                    &#34;while&#34;,
                    s_fun(SafeApply(OVar(&#34;adjusted_next&#34;), *deepcopy(pwritten_vs))),
                ),
            ],
            plt.Apply(OVar(&#34;while&#34;), OVar(&#34;while&#34;), *deepcopy(pwritten_vs)),
        )

    def visit_For(self, node: TypedFor) -&gt; CallAST:
        if node.orelse:
            # If there is orelse, transform it to an appended sequence (TODO check if this is correct)
            cn = copy(node)
            cn.orelse = []
            return self.visit_sequence([cn] + node.orelse)
        assert isinstance(node.iter.typ, InstanceType)
        if isinstance(node.iter.typ.typ, ListType):
            assert isinstance(
                node.target, Name
            ), &#34;Can only assign value to singleton element&#34;
            compiled_s = self.visit_sequence(node.body)
            compiled_iter = self.visit(node.iter)
            written_vs = written_vars(node)
            pwritten_vs = [plt.Var(x) for x in written_vs]
            s_fun = lambda x: plt.Lambda(
                [
                    opshin_name_scheme_compatible_varname(&#34;for&#34;),
                    opshin_name_scheme_compatible_varname(&#34;iter&#34;),
                ]
                + written_vs,
                plt.IteNullList(
                    OVar(&#34;iter&#34;),
                    x,
                    plt.Let(
                        [(node.target.id, plt.Delay(plt.HeadList(OVar(&#34;iter&#34;))))],
                        compiled_s(
                            plt.Apply(
                                OVar(&#34;for&#34;),
                                OVar(&#34;for&#34;),
                                plt.TailList(OVar(&#34;iter&#34;)),
                                *deepcopy(pwritten_vs),
                            )
                        ),
                    ),
                ),
            )
            return lambda x: OLet(
                [
                    (&#34;adjusted_next&#34;, plt.Lambda([node.target.id] + written_vs, x)),
                    (
                        &#34;for&#34;,
                        s_fun(
                            plt.Apply(
                                OVar(&#34;adjusted_next&#34;),
                                plt.Var(node.target.id),
                                *deepcopy(pwritten_vs),
                            )
                        ),
                    ),
                ],
                plt.Apply(
                    OVar(&#34;for&#34;),
                    OVar(&#34;for&#34;),
                    compiled_iter,
                    *deepcopy(pwritten_vs),
                ),
            )
        raise NotImplementedError(
            &#34;Compilation of for statements for anything but lists not implemented yet&#34;
        )

    def visit_If(self, node: TypedIf) -&gt; CallAST:
        written_vs = written_vars(node)
        pwritten_vs = [plt.Var(x) for x in written_vs]
        return lambda x: OLet(
            [(&#34;adjusted_next&#34;, SafeLambda(written_vs, x))],
            plt.Ite(
                self.visit(node.test),
                self.visit_sequence(node.body)(
                    SafeApply(OVar(&#34;adjusted_next&#34;), *deepcopy(pwritten_vs))
                ),
                self.visit_sequence(node.orelse)(
                    SafeApply(OVar(&#34;adjusted_next&#34;), *deepcopy(pwritten_vs))
                ),
            ),
        )

    def visit_Return(self, node: TypedReturn) -&gt; CallAST:
        value_plt = self.visit(node.value)
        assert self.current_function_typ, &#34;Can not handle Return outside of a function&#34;
        if isinstance(self.current_function_typ[-1].rettyp.typ, AnyType):
            value_plt = transform_output_map(node.value.typ)(value_plt)
        return lambda _: value_plt

    def visit_Pass(self, node: TypedPass) -&gt; CallAST:
        return self.visit_sequence([])

    def visit_Subscript(self, node: TypedSubscript) -&gt; plt.AST:
        assert isinstance(
            node.value.typ, InstanceType
        ), &#34;Can only access elements of instances, not classes&#34;
        if isinstance(node.value.typ.typ, TupleType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for tuples is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for tuples is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += len(node.value.typ.typ.typs)
            assert isinstance(node.ctx, Load), &#34;Tuples are read-only&#34;
            return plt.FunctionalTupleAccess(
                self.visit(node.value),
                index,
                len(node.value.typ.typ.typs),
            )
        if isinstance(node.value.typ.typ, PairType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for pairs is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for pairs is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += 2
            assert isinstance(node.ctx, Load), &#34;Pairs are read-only&#34;
            assert (
                0 &lt;= index &lt; 2
            ), f&#34;Pairs only have 2 elements, index should be 0 or 1, is {node.slice.value}&#34;
            member_func = plt.FstPair if index == 0 else plt.SndPair
            # the content of pairs is always Data, so we need to unwrap
            member_typ = node.typ
            return transform_ext_params_map(member_typ)(
                member_func(
                    self.visit(node.value),
                ),
            )
        if isinstance(node.value.typ.typ, ListType):
            if not isinstance(node.slice, Slice):
                assert (
                    node.slice.typ == IntegerInstanceType
                ), &#34;Only single element list index access supported&#34;
                return OLet(
                    [
                        (
                            &#34;l&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_i&#34;), plt.LengthList(OVar(&#34;l&#34;))
                                ),
                                OVar(&#34;raw_i&#34;),
                            ),
                        ),
                    ],
                    plt.IndexAccessList(OVar(&#34;l&#34;), OVar(&#34;i&#34;)),
                )
            else:
                return OLet(
                    [
                        (
                            &#34;xs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice.lower),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_i&#34;),
                                    plt.LengthList(OVar(&#34;xs&#34;)),
                                ),
                                OVar(&#34;raw_i&#34;),
                            ),
                        ),
                        (
                            &#34;raw_j&#34;,
                            self.visit(node.slice.upper),
                        ),
                        (
                            &#34;j&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_j&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_j&#34;),
                                    plt.LengthList(OVar(&#34;xs&#34;)),
                                ),
                                OVar(&#34;raw_j&#34;),
                            ),
                        ),
                        (
                            &#34;drop&#34;,
                            plt.Ite(
                                plt.LessThanEqualsInteger(OVar(&#34;i&#34;), plt.Integer(0)),
                                plt.Integer(0),
                                OVar(&#34;i&#34;),
                            ),
                        ),
                        (
                            &#34;take&#34;,
                            plt.SubtractInteger(OVar(&#34;j&#34;), OVar(&#34;drop&#34;)),
                        ),
                    ],
                    plt.Ite(
                        plt.LessThanEqualsInteger(OVar(&#34;j&#34;), OVar(&#34;i&#34;)),
                        empty_list(node.value.typ.typ.typ),
                        plt.SliceList(
                            OVar(&#34;drop&#34;),
                            OVar(&#34;take&#34;),
                            OVar(&#34;xs&#34;),
                            empty_list(node.value.typ.typ.typ),
                        ),
                    ),
                )
        elif isinstance(node.value.typ.typ, DictType):
            dict_typ = node.value.typ.typ
            if not isinstance(node.slice, Slice):
                return OLet(
                    [
                        (
                            &#34;key&#34;,
                            self.visit(node.slice),
                        )
                    ],
                    transform_ext_params_map(dict_typ.value_typ)(
                        plt.SndPair(
                            plt.FindList(
                                self.visit(node.value),
                                OLambda(
                                    [&#34;x&#34;],
                                    plt.EqualsData(
                                        transform_output_map(dict_typ.key_typ)(
                                            OVar(&#34;key&#34;)
                                        ),
                                        plt.FstPair(OVar(&#34;x&#34;)),
                                    ),
                                ),
                                plt.TraceError(&#34;KeyError&#34;),
                            )
                        ),
                    ),
                )
        elif isinstance(node.value.typ.typ, ByteStringType):
            if not isinstance(node.slice, Slice):
                return OLet(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_ix&#34;,
                            self.visit(node.slice),
                        ),
                        (
                            &#34;ix&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_ix&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_ix&#34;),
                                    plt.LengthOfByteString(OVar(&#34;bs&#34;)),
                                ),
                                OVar(&#34;raw_ix&#34;),
                            ),
                        ),
                    ],
                    plt.IndexByteString(OVar(&#34;bs&#34;), OVar(&#34;ix&#34;)),
                )
            elif isinstance(node.slice, Slice):
                return OLet(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice.lower),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_i&#34;),
                                    plt.LengthOfByteString(OVar(&#34;bs&#34;)),
                                ),
                                OVar(&#34;raw_i&#34;),
                            ),
                        ),
                        (
                            &#34;raw_j&#34;,
                            self.visit(node.slice.upper),
                        ),
                        (
                            &#34;j&#34;,
                            plt.Ite(
                                plt.LessThanInteger(OVar(&#34;raw_j&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    OVar(&#34;raw_j&#34;),
                                    plt.LengthOfByteString(OVar(&#34;bs&#34;)),
                                ),
                                OVar(&#34;raw_j&#34;),
                            ),
                        ),
                        (
                            &#34;drop&#34;,
                            plt.Ite(
                                plt.LessThanEqualsInteger(OVar(&#34;i&#34;), plt.Integer(0)),
                                plt.Integer(0),
                                OVar(&#34;i&#34;),
                            ),
                        ),
                        (
                            &#34;take&#34;,
                            plt.SubtractInteger(OVar(&#34;j&#34;), OVar(&#34;drop&#34;)),
                        ),
                    ],
                    plt.Ite(
                        plt.LessThanEqualsInteger(OVar(&#34;j&#34;), OVar(&#34;i&#34;)),
                        plt.ByteString(b&#34;&#34;),
                        plt.SliceByteString(
                            OVar(&#34;drop&#34;),
                            OVar(&#34;take&#34;),
                            OVar(&#34;bs&#34;),
                        ),
                    ),
                )
        raise NotImplementedError(
            f&#39;Could not implement subscript &#34;{node.slice}&#34; of &#34;{node.value}&#34;&#39;
        )

    def visit_Tuple(self, node: TypedTuple) -&gt; plt.AST:
        return plt.FunctionalTuple(*(self.visit(e) for e in node.elts))

    def visit_ClassDef(self, node: TypedClassDef) -&gt; CallAST:
        return lambda x: plt.Let([(node.name, plt.Delay(node.class_typ.constr()))], x)

    def visit_Attribute(self, node: TypedAttribute) -&gt; plt.AST:
        assert isinstance(
            node.value.typ, InstanceType
        ), &#34;Can only access attributes of instances&#34;
        obj = self.visit(node.value)
        attr = node.value.typ.attribute(node.attr)
        return plt.Apply(attr, obj)

    def visit_Assert(self, node: TypedAssert) -&gt; CallAST:
        return lambda x: plt.Ite(
            self.visit(node.test),
            x,
            plt.Apply(
                plt.Error(),
                (
                    plt.Trace(self.visit(node.msg), plt.Unit())
                    if node.msg is not None
                    else plt.Unit()
                ),
            ),
        )

    def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; plt.AST:
        return node.expr

    def visit_List(self, node: TypedList) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, ListType)
        l = empty_list(node.typ.typ.typ)
        for e in reversed(node.elts):
            l = plt.MkCons(self.visit(e), l)
        return l

    def visit_Dict(self, node: TypedDict) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, DictType)
        key_type = node.typ.typ.key_typ
        value_type = node.typ.typ.value_typ
        l = plt.EmptyDataPairList()
        for k, v in zip(node.keys, node.values):
            l = plt.MkCons(
                plt.MkPairData(
                    transform_output_map(key_type)(
                        self.visit(k),
                    ),
                    transform_output_map(value_type)(
                        self.visit(v),
                    ),
                ),
                l,
            )
        return l

    def visit_IfExp(self, node: TypedIfExp) -&gt; plt.AST:
        return plt.Ite(
            self.visit(node.test),
            self.visit(node.body),
            self.visit(node.orelse),
        )

    def visit_ListComp(self, node: TypedListComp) -&gt; plt.AST:
        assert len(node.generators) == 1, &#34;Currently only one generator supported&#34;
        gen = node.generators[0]
        assert isinstance(gen.iter.typ, InstanceType), &#34;Only lists are valid generators&#34;
        assert isinstance(gen.iter.typ.typ, ListType), &#34;Only lists are valid generators&#34;
        assert isinstance(
            gen.target, Name
        ), &#34;Can only assign value to singleton element&#34;
        lst = self.visit(gen.iter)
        ifs = None
        for ifexpr in gen.ifs:
            if ifs is None:
                ifs = self.visit(ifexpr)
            else:
                ifs = plt.And(ifs, self.visit(ifexpr))
        map_fun = OLambda(
            [&#34;x&#34;],
            plt.Let(
                [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                self.visit(node.elt),
            ),
        )
        empty_list_con = empty_list(node.elt.typ)
        if ifs is not None:
            filter_fun = OLambda(
                [&#34;x&#34;],
                plt.Let(
                    [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                    ifs,
                ),
            )
            return plt.MapFilterList(
                lst,
                filter_fun,
                map_fun,
                empty_list_con,
            )
        else:
            return plt.MapList(
                lst,
                map_fun,
                empty_list_con,
            )

    def visit_DictComp(self, node: TypedDictComp) -&gt; plt.AST:
        assert len(node.generators) == 1, &#34;Currently only one generator supported&#34;
        gen = node.generators[0]
        assert isinstance(gen.iter.typ, InstanceType), &#34;Only lists are valid generators&#34;
        assert isinstance(gen.iter.typ.typ, ListType), &#34;Only lists are valid generators&#34;
        assert isinstance(
            gen.target, Name
        ), &#34;Can only assign value to singleton element&#34;
        lst = self.visit(gen.iter)
        ifs = None
        for ifexpr in gen.ifs:
            if ifs is None:
                ifs = self.visit(ifexpr)
            else:
                ifs = plt.And(ifs, self.visit(ifexpr))
        map_fun = OLambda(
            [&#34;x&#34;],
            plt.Let(
                [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                plt.MkPairData(
                    transform_output_map(node.key.typ)(
                        self.visit(node.key),
                    ),
                    transform_output_map(node.value.typ)(
                        self.visit(node.value),
                    ),
                ),
            ),
        )
        empty_list_con = plt.EmptyDataPairList()
        if ifs is not None:
            filter_fun = OLambda(
                [&#34;x&#34;],
                plt.Let(
                    [(gen.target.id, plt.Delay(OVar(&#34;x&#34;)))],
                    ifs,
                ),
            )
            return plt.MapFilterList(
                lst,
                filter_fun,
                map_fun,
                empty_list_con,
            )
        else:
            return plt.MapList(
                lst,
                map_fun,
                empty_list_con,
            )

    def visit_FormattedValue(self, node: TypedFormattedValue) -&gt; plt.AST:
        return plt.Apply(
            node.value.typ.stringify(),
            self.visit(node.value),
        )

    def visit_JoinedStr(self, node: TypedJoinedStr) -&gt; plt.AST:
        joined_str = plt.Text(&#34;&#34;)
        for v in reversed(node.values):
            joined_str = plt.AppendString(self.visit(v), joined_str)
        return joined_str

    def generic_visit(self, node: AST) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not compile {node}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="opshin.util.CompilingNodeTransformer" href="util.html#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></li>
<li><a title="opshin.util.TypedNodeTransformer" href="util.html#opshin.util.TypedNodeTransformer">TypedNodeTransformer</a></li>
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="opshin.compiler.PlutoCompiler.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="opshin.compiler.PlutoCompiler.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node:ast.AST) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="opshin.util.CompilingNodeTransformer" href="util.html#opshin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></code>.<code><a title="opshin.util.CompilingNodeTransformer.visit" href="util.html#opshin.util.CompilingNodeTransformer.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_AnnAssign"><code class="name flex">
<span>def <span class="ident">visit_AnnAssign</span></span>(<span>self, node:ast.AnnAssign) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Assert"><code class="name flex">
<span>def <span class="ident">visit_Assert</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedAssert" href="typed_ast.html#opshin.typed_ast.TypedAssert">TypedAssert</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Assign"><code class="name flex">
<span>def <span class="ident">visit_Assign</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedAssign" href="typed_ast.html#opshin.typed_ast.TypedAssign">TypedAssign</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Attribute"><code class="name flex">
<span>def <span class="ident">visit_Attribute</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedAttribute" href="typed_ast.html#opshin.typed_ast.TypedAttribute">TypedAttribute</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedBinOp" href="typed_ast.html#opshin.typed_ast.TypedBinOp">TypedBinOp</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_BoolOp"><code class="name flex">
<span>def <span class="ident">visit_BoolOp</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedBoolOp" href="typed_ast.html#opshin.typed_ast.TypedBoolOp">TypedBoolOp</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedCall" href="typed_ast.html#opshin.typed_ast.TypedCall">TypedCall</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedClassDef" href="typed_ast.html#opshin.typed_ast.TypedClassDef">TypedClassDef</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Compare"><code class="name flex">
<span>def <span class="ident">visit_Compare</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedCompare" href="typed_ast.html#opshin.typed_ast.TypedCompare">TypedCompare</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedConstant" href="typed_ast.html#opshin.typed_ast.TypedConstant">TypedConstant</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Dict"><code class="name flex">
<span>def <span class="ident">visit_Dict</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedDict" href="typed_ast.html#opshin.typed_ast.TypedDict">TypedDict</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_DictComp"><code class="name flex">
<span>def <span class="ident">visit_DictComp</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedDictComp" href="typed_ast.html#opshin.typed_ast.TypedDictComp">TypedDictComp</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Expr"><code class="name flex">
<span>def <span class="ident">visit_Expr</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedExpr" href="typed_ast.html#opshin.typed_ast.TypedExpr">TypedExpr</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_For"><code class="name flex">
<span>def <span class="ident">visit_For</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedFor" href="typed_ast.html#opshin.typed_ast.TypedFor">TypedFor</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_FormattedValue"><code class="name flex">
<span>def <span class="ident">visit_FormattedValue</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedFormattedValue" href="typed_ast.html#opshin.typed_ast.TypedFormattedValue">TypedFormattedValue</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedFunctionDef" href="typed_ast.html#opshin.typed_ast.TypedFunctionDef">TypedFunctionDef</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_If"><code class="name flex">
<span>def <span class="ident">visit_If</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedIf" href="typed_ast.html#opshin.typed_ast.TypedIf">TypedIf</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_IfExp"><code class="name flex">
<span>def <span class="ident">visit_IfExp</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedIfExp" href="typed_ast.html#opshin.typed_ast.TypedIfExp">TypedIfExp</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_JoinedStr"><code class="name flex">
<span>def <span class="ident">visit_JoinedStr</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedJoinedStr" href="typed_ast.html#opshin.typed_ast.TypedJoinedStr">TypedJoinedStr</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_List"><code class="name flex">
<span>def <span class="ident">visit_List</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedList" href="typed_ast.html#opshin.typed_ast.TypedList">TypedList</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_ListComp"><code class="name flex">
<span>def <span class="ident">visit_ListComp</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedListComp" href="typed_ast.html#opshin.typed_ast.TypedListComp">TypedListComp</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Module"><code class="name flex">
<span>def <span class="ident">visit_Module</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedModule" href="typed_ast.html#opshin.typed_ast.TypedModule">TypedModule</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedName" href="typed_ast.html#opshin.typed_ast.TypedName">TypedName</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_NoneType"><code class="name flex">
<span>def <span class="ident">visit_NoneType</span></span>(<span>self, _:Optional[Any]) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Pass"><code class="name flex">
<span>def <span class="ident">visit_Pass</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedPass" href="typed_ast.html#opshin.typed_ast.TypedPass">TypedPass</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_RawPlutoExpr"><code class="name flex">
<span>def <span class="ident">visit_RawPlutoExpr</span></span>(<span>self, node:<a title="opshin.typed_ast.RawPlutoExpr" href="typed_ast.html#opshin.typed_ast.RawPlutoExpr">RawPlutoExpr</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Return"><code class="name flex">
<span>def <span class="ident">visit_Return</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedReturn" href="typed_ast.html#opshin.typed_ast.TypedReturn">TypedReturn</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Subscript"><code class="name flex">
<span>def <span class="ident">visit_Subscript</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedSubscript" href="typed_ast.html#opshin.typed_ast.TypedSubscript">TypedSubscript</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_Tuple"><code class="name flex">
<span>def <span class="ident">visit_Tuple</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedTuple" href="typed_ast.html#opshin.typed_ast.TypedTuple">TypedTuple</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedUnaryOp" href="typed_ast.html#opshin.typed_ast.TypedUnaryOp">TypedUnaryOp</a>) >pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_While"><code class="name flex">
<span>def <span class="ident">visit_While</span></span>(<span>self, node:<a title="opshin.typed_ast.TypedWhile" href="typed_ast.html#opshin.typed_ast.TypedWhile">TypedWhile</a>) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.compiler.PlutoCompiler.visit_sequence"><code class="name flex">
<span>def <span class="ident">visit_sequence</span></span>(<span>self, node_seq:List[<a title="opshin.typed_ast.typedstmt" href="typed_ast.html#opshin.typed_ast.typedstmt">typedstmt</a>]) >Callable[[pluthon.pluthon_ast.AST],pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="opshin Home" href="https://opshin.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/opshin/master/opshin.png" alt="opshin logo"> &nbsp; opshin
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opshin" href="index.html">opshin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opshin.compiler.compile" href="#opshin.compiler.compile">compile</a></code></li>
<li><code><a title="opshin.compiler.rec_constant_map" href="#opshin.compiler.rec_constant_map">rec_constant_map</a></code></li>
<li><code><a title="opshin.compiler.rec_constant_map_data" href="#opshin.compiler.rec_constant_map_data">rec_constant_map_data</a></code></li>
<li><code><a title="opshin.compiler.wrap_validator_double_function" href="#opshin.compiler.wrap_validator_double_function">wrap_validator_double_function</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opshin.compiler.PlutoCompiler" href="#opshin.compiler.PlutoCompiler">PlutoCompiler</a></code></h4>
<ul class="">
<li><code><a title="opshin.compiler.PlutoCompiler.generic_visit" href="#opshin.compiler.PlutoCompiler.generic_visit">generic_visit</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.step" href="#opshin.compiler.PlutoCompiler.step">step</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit" href="util.html#opshin.compiler.PlutoCompiler.visit">visit</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_AnnAssign" href="#opshin.compiler.PlutoCompiler.visit_AnnAssign">visit_AnnAssign</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Assert" href="#opshin.compiler.PlutoCompiler.visit_Assert">visit_Assert</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Assign" href="#opshin.compiler.PlutoCompiler.visit_Assign">visit_Assign</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Attribute" href="#opshin.compiler.PlutoCompiler.visit_Attribute">visit_Attribute</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_BinOp" href="#opshin.compiler.PlutoCompiler.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_BoolOp" href="#opshin.compiler.PlutoCompiler.visit_BoolOp">visit_BoolOp</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Call" href="#opshin.compiler.PlutoCompiler.visit_Call">visit_Call</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_ClassDef" href="#opshin.compiler.PlutoCompiler.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Compare" href="#opshin.compiler.PlutoCompiler.visit_Compare">visit_Compare</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Constant" href="#opshin.compiler.PlutoCompiler.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Dict" href="#opshin.compiler.PlutoCompiler.visit_Dict">visit_Dict</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_DictComp" href="#opshin.compiler.PlutoCompiler.visit_DictComp">visit_DictComp</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Expr" href="#opshin.compiler.PlutoCompiler.visit_Expr">visit_Expr</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_For" href="#opshin.compiler.PlutoCompiler.visit_For">visit_For</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_FormattedValue" href="#opshin.compiler.PlutoCompiler.visit_FormattedValue">visit_FormattedValue</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_FunctionDef" href="#opshin.compiler.PlutoCompiler.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_If" href="#opshin.compiler.PlutoCompiler.visit_If">visit_If</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_IfExp" href="#opshin.compiler.PlutoCompiler.visit_IfExp">visit_IfExp</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_JoinedStr" href="#opshin.compiler.PlutoCompiler.visit_JoinedStr">visit_JoinedStr</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_List" href="#opshin.compiler.PlutoCompiler.visit_List">visit_List</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_ListComp" href="#opshin.compiler.PlutoCompiler.visit_ListComp">visit_ListComp</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Module" href="#opshin.compiler.PlutoCompiler.visit_Module">visit_Module</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Name" href="#opshin.compiler.PlutoCompiler.visit_Name">visit_Name</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_NoneType" href="#opshin.compiler.PlutoCompiler.visit_NoneType">visit_NoneType</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Pass" href="#opshin.compiler.PlutoCompiler.visit_Pass">visit_Pass</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_RawPlutoExpr" href="#opshin.compiler.PlutoCompiler.visit_RawPlutoExpr">visit_RawPlutoExpr</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Return" href="#opshin.compiler.PlutoCompiler.visit_Return">visit_Return</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Subscript" href="#opshin.compiler.PlutoCompiler.visit_Subscript">visit_Subscript</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_Tuple" href="#opshin.compiler.PlutoCompiler.visit_Tuple">visit_Tuple</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_UnaryOp" href="#opshin.compiler.PlutoCompiler.visit_UnaryOp">visit_UnaryOp</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_While" href="#opshin.compiler.PlutoCompiler.visit_While">visit_While</a></code></li>
<li><code><a title="opshin.compiler.PlutoCompiler.visit_sequence" href="#opshin.compiler.PlutoCompiler.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
