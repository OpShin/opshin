<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>eopsin.util API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eopsin.util</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import ast
from enum import Enum, auto

from .typed_ast import *

import pluthon as plt
import uplc.ast as uplc


def PowImpl(x: plt.AST, y: plt.AST):
    return plt.Apply(
        plt.RecFun(
            plt.Lambda(
                [&#34;f&#34;, &#34;x&#34;, &#34;y&#34;],
                plt.Ite(
                    plt.LessThanEqualsInteger(plt.Var(&#34;y&#34;), plt.Integer(0)),
                    plt.Integer(1),
                    plt.MultiplyInteger(
                        plt.Var(&#34;x&#34;),
                        plt.Apply(
                            plt.Var(&#34;f&#34;),
                            plt.Var(&#34;f&#34;),
                            plt.Var(&#34;x&#34;),
                            plt.SubtractInteger(plt.Var(&#34;y&#34;), plt.Integer(1)),
                        ),
                    ),
                ),
            ),
        ),
        x,
        y,
    )


class PythonBuiltIn(Enum):
    all = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.Var(&#34;xs&#34;),
            plt.Lambda([&#34;x&#34;, &#34;a&#34;], plt.And(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
            plt.Bool(True),
        ),
    )
    any = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.Var(&#34;xs&#34;),
            plt.Lambda([&#34;x&#34;, &#34;a&#34;], plt.Or(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
            plt.Bool(False),
        ),
    )
    abs = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.Ite(
            plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
            plt.Negate(plt.Var(&#34;x&#34;)),
            plt.Var(&#34;x&#34;),
        ),
    )
    # maps an integer to a unicode code point and decodes it
    # reference: https://en.wikipedia.org/wiki/UTF-8#Encoding
    chr = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.DecodeUtf8(
            plt.Ite(
                plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x0)),
                plt.TraceError(&#34;ValueError: chr() arg not in range(0x110000)&#34;),
                plt.Ite(
                    plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x80)),
                    # encoding of 0x0 - 0x80
                    plt.ConsByteString(plt.Var(&#34;x&#34;), plt.ByteString(b&#34;&#34;)),
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x800)),
                        # encoding of 0x80 - 0x800
                        plt.ConsByteString(
                            # we do bit manipulation using integer arithmetic here - nice
                            plt.AddInteger(
                                plt.Integer(0b110 &lt;&lt; 5),
                                plt.DivideInteger(plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 6)),
                            ),
                            plt.ConsByteString(
                                plt.AddInteger(
                                    plt.Integer(0b10 &lt;&lt; 6),
                                    plt.ModInteger(plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 6)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x10000)),
                            # encoding of 0x800 - 0x10000
                            plt.ConsByteString(
                                plt.AddInteger(
                                    plt.Integer(0b1110 &lt;&lt; 4),
                                    plt.DivideInteger(
                                        plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 12)
                                    ),
                                ),
                                plt.ConsByteString(
                                    plt.AddInteger(
                                        plt.Integer(0b10 &lt;&lt; 6),
                                        plt.DivideInteger(
                                            plt.ModInteger(
                                                plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 12)
                                            ),
                                            plt.Integer(1 &lt;&lt; 6),
                                        ),
                                    ),
                                    plt.ConsByteString(
                                        plt.AddInteger(
                                            plt.Integer(0b10 &lt;&lt; 6),
                                            plt.ModInteger(
                                                plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 6)
                                            ),
                                        ),
                                        plt.ByteString(b&#34;&#34;),
                                    ),
                                ),
                            ),
                            plt.Ite(
                                plt.LessThanInteger(
                                    plt.Var(&#34;x&#34;), plt.Integer(0x110000)
                                ),
                                # encoding of 0x10000 - 0x10FFF
                                plt.ConsByteString(
                                    plt.AddInteger(
                                        plt.Integer(0b11110 &lt;&lt; 3),
                                        plt.DivideInteger(
                                            plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 18)
                                        ),
                                    ),
                                    plt.ConsByteString(
                                        plt.AddInteger(
                                            plt.Integer(0b10 &lt;&lt; 6),
                                            plt.DivideInteger(
                                                plt.ModInteger(
                                                    plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 18)
                                                ),
                                                plt.Integer(1 &lt;&lt; 12),
                                            ),
                                        ),
                                        plt.ConsByteString(
                                            plt.AddInteger(
                                                plt.Integer(0b10 &lt;&lt; 6),
                                                plt.DivideInteger(
                                                    plt.ModInteger(
                                                        plt.Var(&#34;x&#34;),
                                                        plt.Integer(1 &lt;&lt; 12),
                                                    ),
                                                    plt.Integer(1 &lt;&lt; 6),
                                                ),
                                            ),
                                            plt.ConsByteString(
                                                plt.AddInteger(
                                                    plt.Integer(0b10 &lt;&lt; 6),
                                                    plt.ModInteger(
                                                        plt.Var(&#34;x&#34;),
                                                        plt.Integer(1 &lt;&lt; 6),
                                                    ),
                                                ),
                                                plt.ByteString(b&#34;&#34;),
                                            ),
                                        ),
                                    ),
                                ),
                                plt.TraceError(
                                    &#34;ValueError: chr() arg not in range(0x110000)&#34;
                                ),
                            ),
                        ),
                    ),
                ),
            )
        ),
    )
    breakpoint = plt.Lambda([&#34;_&#34;], plt.NoneData())
    hex = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.DecodeUtf8(
            plt.Let(
                [
                    (
                        &#34;hexlist&#34;,
                        plt.RecFun(
                            plt.Lambda(
                                [&#34;f&#34;, &#34;i&#34;],
                                plt.Ite(
                                    plt.LessThanEqualsInteger(
                                        plt.Var(&#34;i&#34;), plt.Integer(0)
                                    ),
                                    plt.EmptyIntegerList(),
                                    plt.MkCons(
                                        plt.Let(
                                            [
                                                (
                                                    &#34;mod&#34;,
                                                    plt.ModInteger(
                                                        plt.Var(&#34;i&#34;), plt.Integer(16)
                                                    ),
                                                ),
                                            ],
                                            plt.AddInteger(
                                                plt.Var(&#34;mod&#34;),
                                                plt.IfThenElse(
                                                    plt.LessThanInteger(
                                                        plt.Var(&#34;mod&#34;), plt.Integer(10)
                                                    ),
                                                    plt.Integer(ord(&#34;0&#34;)),
                                                    plt.Integer(ord(&#34;a&#34;) - 10),
                                                ),
                                            ),
                                        ),
                                        plt.Apply(
                                            plt.Var(&#34;f&#34;),
                                            plt.Var(&#34;f&#34;),
                                            plt.DivideInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(16)
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;mkstr&#34;,
                        plt.Lambda(
                            [&#34;i&#34;],
                            plt.FoldList(
                                plt.Apply(plt.Var(&#34;hexlist&#34;), plt.Var(&#34;i&#34;)),
                                plt.Lambda(
                                    [&#34;b&#34;, &#34;i&#34;],
                                    plt.ConsByteString(plt.Var(&#34;i&#34;), plt.Var(&#34;b&#34;)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    plt.ByteString(b&#34;0x0&#34;),
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                        plt.ConsByteString(
                            plt.Integer(ord(&#34;-&#34;)),
                            plt.AppendByteString(
                                plt.ByteString(b&#34;0x&#34;),
                                plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Negate(plt.Var(&#34;x&#34;))),
                            ),
                        ),
                        plt.AppendByteString(
                            plt.ByteString(b&#34;0x&#34;),
                            plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                ),
            )
        ),
    )
    len = auto()
    max = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.TailList(plt.Var(&#34;xs&#34;)),
            plt.Lambda(
                [&#34;x&#34;, &#34;a&#34;],
                plt.IfThenElse(
                    plt.LessThanInteger(plt.Var(&#34;a&#34;), plt.Var(&#34;x&#34;)),
                    plt.Var(&#34;x&#34;),
                    plt.Var(&#34;a&#34;),
                ),
            ),
            plt.HeadList(plt.Var(&#34;xs&#34;)),
        ),
    )
    min = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.TailList(plt.Var(&#34;xs&#34;)),
            plt.Lambda(
                [&#34;x&#34;, &#34;a&#34;],
                plt.IfThenElse(
                    plt.LessThanInteger(plt.Var(&#34;a&#34;), plt.Var(&#34;x&#34;)),
                    plt.Var(&#34;a&#34;),
                    plt.Var(&#34;x&#34;),
                ),
            ),
            plt.HeadList(plt.Var(&#34;xs&#34;)),
        ),
    )
    print = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.Trace(plt.Var(&#34;x&#34;), plt.NoneData()),
    )
    # NOTE: only correctly defined for positive y
    pow = plt.Lambda([&#34;x&#34;, &#34;y&#34;, &#34;_&#34;], PowImpl(plt.Var(&#34;x&#34;), plt.Var(&#34;y&#34;)))
    oct = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.DecodeUtf8(
            plt.Let(
                [
                    (
                        &#34;octlist&#34;,
                        plt.RecFun(
                            plt.Lambda(
                                [&#34;f&#34;, &#34;i&#34;],
                                plt.Ite(
                                    plt.LessThanEqualsInteger(
                                        plt.Var(&#34;i&#34;), plt.Integer(0)
                                    ),
                                    plt.EmptyIntegerList(),
                                    plt.MkCons(
                                        plt.AddInteger(
                                            plt.ModInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(8)
                                            ),
                                            plt.Integer(ord(&#34;0&#34;)),
                                        ),
                                        plt.Apply(
                                            plt.Var(&#34;f&#34;),
                                            plt.Var(&#34;f&#34;),
                                            plt.DivideInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(8)
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;mkoct&#34;,
                        plt.Lambda(
                            [&#34;i&#34;],
                            plt.FoldList(
                                plt.Apply(plt.Var(&#34;octlist&#34;), plt.Var(&#34;i&#34;)),
                                plt.Lambda(
                                    [&#34;b&#34;, &#34;i&#34;],
                                    plt.ConsByteString(plt.Var(&#34;i&#34;), plt.Var(&#34;b&#34;)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    plt.ByteString(b&#34;0o0&#34;),
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                        plt.ConsByteString(
                            plt.Integer(ord(&#34;-&#34;)),
                            plt.AppendByteString(
                                plt.ByteString(b&#34;0o&#34;),
                                plt.Apply(plt.Var(&#34;mkoct&#34;), plt.Negate(plt.Var(&#34;x&#34;))),
                            ),
                        ),
                        plt.AppendByteString(
                            plt.ByteString(b&#34;0o&#34;),
                            plt.Apply(plt.Var(&#34;mkoct&#34;), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                ),
            )
        ),
    )
    range = plt.Lambda(
        [&#34;limit&#34;, &#34;_&#34;],
        plt.Range(plt.Var(&#34;limit&#34;)),
    )
    reversed = auto()
    sum = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.Var(&#34;xs&#34;), plt.BuiltIn(uplc.BuiltInFun.AddInteger), plt.Integer(0)
        ),
    )


class LenImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;len&#39; takes only one argument, but {len(args)} were given&#34;
        assert isinstance(
            args[0], InstanceType
        ), &#34;Can only determine length of instances&#34;
        return FunctionType(args, IntegerInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only determine length of instances&#34;
        if arg == ByteStringInstanceType:
            return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.LengthOfByteString(plt.Var(&#34;x&#34;)))
        elif isinstance(arg.typ, ListType):
            # simple list length function
            return plt.Lambda(
                [&#34;x&#34;, &#34;_&#34;],
                plt.FoldList(
                    plt.Var(&#34;x&#34;),
                    plt.Lambda(
                        [&#34;a&#34;, &#34;_&#34;], plt.AddInteger(plt.Var(&#34;a&#34;), plt.Integer(1))
                    ),
                    plt.Integer(0),
                ),
            )
        raise NotImplementedError(f&#34;&#39;len&#39; is not implemented for type {arg}&#34;)


class ReversedImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;reversed&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only reverse instances&#34;
        assert isinstance(typ.typ, ListType), &#34;Can only reverse instances of lists&#34;
        # returns list of same type
        return FunctionType(args, typ)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only reverse instances&#34;
        if isinstance(arg.typ, ListType):
            empty_l = empty_list(arg.typ.typ)
            return plt.Lambda(
                [&#34;xs&#34;, &#34;_&#34;],
                plt.FoldList(
                    plt.Var(&#34;xs&#34;),
                    plt.Lambda([&#34;a&#34;, &#34;x&#34;], plt.MkCons(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
                    empty_l,
                ),
            )
        raise NotImplementedError(f&#34;&#39;reversed&#39; is not implemented for type {arg}&#34;)


PythonBuiltInTypes = {
    PythonBuiltIn.all: InstanceType(
        FunctionType(
            [InstanceType(ListType(BoolInstanceType))],
            BoolInstanceType,
        )
    ),
    PythonBuiltIn.any: InstanceType(
        FunctionType(
            [InstanceType(ListType(BoolInstanceType))],
            BoolInstanceType,
        )
    ),
    PythonBuiltIn.abs: InstanceType(
        FunctionType(
            [IntegerInstanceType],
            IntegerInstanceType,
        )
    ),
    PythonBuiltIn.chr: InstanceType(
        FunctionType(
            [IntegerInstanceType],
            StringInstanceType,
        )
    ),
    PythonBuiltIn.breakpoint: InstanceType(FunctionType([], NoneInstanceType)),
    PythonBuiltIn.len: InstanceType(PolymorphicFunctionType(LenImpl())),
    PythonBuiltIn.hex: InstanceType(
        FunctionType(
            [IntegerInstanceType],
            StringInstanceType,
        )
    ),
    PythonBuiltIn.max: InstanceType(
        FunctionType(
            [InstanceType(ListType(IntegerInstanceType))],
            IntegerInstanceType,
        )
    ),
    PythonBuiltIn.min: InstanceType(
        FunctionType(
            [InstanceType(ListType(IntegerInstanceType))],
            IntegerInstanceType,
        )
    ),
    PythonBuiltIn.print: InstanceType(
        FunctionType([StringInstanceType], NoneInstanceType)
    ),
    PythonBuiltIn.pow: InstanceType(
        FunctionType(
            [IntegerInstanceType, IntegerInstanceType],
            IntegerInstanceType,
        )
    ),
    PythonBuiltIn.oct: InstanceType(
        FunctionType(
            [IntegerInstanceType],
            StringInstanceType,
        )
    ),
    PythonBuiltIn.range: InstanceType(
        FunctionType(
            [IntegerInstanceType],
            InstanceType(ListType(IntegerInstanceType)),
        )
    ),
    PythonBuiltIn.reversed: InstanceType(PolymorphicFunctionType(ReversedImpl())),
    PythonBuiltIn.sum: InstanceType(
        FunctionType(
            [InstanceType(ListType(IntegerInstanceType))],
            IntegerInstanceType,
        )
    ),
}


class CompilerError(Exception):
    def __init__(self, orig_err: Exception, node: ast.AST, compilation_step: str):
        self.orig_err = orig_err
        self.node = node
        self.compilation_step = compilation_step


class CompilingNodeTransformer(TypedNodeTransformer):
    step = &#34;Node transformation&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)


class CompilingNodeVisitor(TypedNodeVisitor):
    step = &#34;Node visiting&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)


def data_from_json(j: typing.Dict[str, typing.Any]) -&gt; uplc.PlutusData:
    if &#34;bytes&#34; in j:
        return uplc.PlutusByteString(bytes.fromhex(j[&#34;bytes&#34;]))
    if &#34;int&#34; in j:
        return uplc.PlutusInteger(int(j[&#34;int&#34;]))
    if &#34;list&#34; in j:
        return uplc.PlutusList(list(map(data_from_json, j[&#34;list&#34;])))
    if &#34;map&#34; in j:
        return uplc.PlutusMap({d[&#34;k&#34;]: d[&#34;v&#34;] for d in j[&#34;map&#34;]})
    if &#34;constructor&#34; in j and &#34;fields&#34; in j:
        return uplc.PlutusConstr(
            j[&#34;constructor&#34;], list(map(data_from_json, j[&#34;fields&#34;]))
        )
    raise NotImplementedError(f&#34;Unknown datum representation {j}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="eopsin.util.PowImpl"><code class="name flex">
<span>def <span class="ident">PowImpl</span></span>(<span>x: pluthon.pluthon_ast.AST, y: pluthon.pluthon_ast.AST)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PowImpl(x: plt.AST, y: plt.AST):
    return plt.Apply(
        plt.RecFun(
            plt.Lambda(
                [&#34;f&#34;, &#34;x&#34;, &#34;y&#34;],
                plt.Ite(
                    plt.LessThanEqualsInteger(plt.Var(&#34;y&#34;), plt.Integer(0)),
                    plt.Integer(1),
                    plt.MultiplyInteger(
                        plt.Var(&#34;x&#34;),
                        plt.Apply(
                            plt.Var(&#34;f&#34;),
                            plt.Var(&#34;f&#34;),
                            plt.Var(&#34;x&#34;),
                            plt.SubtractInteger(plt.Var(&#34;y&#34;), plt.Integer(1)),
                        ),
                    ),
                ),
            ),
        ),
        x,
        y,
    )</code></pre>
</details>
</dd>
<dt id="eopsin.util.data_from_json"><code class="name flex">
<span>def <span class="ident">data_from_json</span></span>(<span>j: Dict[str, Any]) ‑> uplc.ast.PlutusData</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_from_json(j: typing.Dict[str, typing.Any]) -&gt; uplc.PlutusData:
    if &#34;bytes&#34; in j:
        return uplc.PlutusByteString(bytes.fromhex(j[&#34;bytes&#34;]))
    if &#34;int&#34; in j:
        return uplc.PlutusInteger(int(j[&#34;int&#34;]))
    if &#34;list&#34; in j:
        return uplc.PlutusList(list(map(data_from_json, j[&#34;list&#34;])))
    if &#34;map&#34; in j:
        return uplc.PlutusMap({d[&#34;k&#34;]: d[&#34;v&#34;] for d in j[&#34;map&#34;]})
    if &#34;constructor&#34; in j and &#34;fields&#34; in j:
        return uplc.PlutusConstr(
            j[&#34;constructor&#34;], list(map(data_from_json, j[&#34;fields&#34;]))
        )
    raise NotImplementedError(f&#34;Unknown datum representation {j}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eopsin.util.CompilerError"><code class="flex name class">
<span>class <span class="ident">CompilerError</span></span>
<span>(</span><span>orig_err: Exception, node: _ast.AST, compilation_step: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompilerError(Exception):
    def __init__(self, orig_err: Exception, node: ast.AST, compilation_step: str):
        self.orig_err = orig_err
        self.node = node
        self.compilation_step = compilation_step</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="eopsin.util.CompilingNodeTransformer"><code class="flex name class">
<span>class <span class="ident">CompilingNodeTransformer</span></span>
</code></dt>
<dd>
<div class="desc"><p>A :class:<code>NodeVisitor</code> subclass that walks the abstract syntax tree and
allows modification of nodes.</p>
<p>The <code>NodeTransformer</code> will walk the AST and use the return value of the
visitor methods to replace or remove the old node.
If the return value of
the visitor method is <code>None</code>, the node will be removed from its location,
otherwise it is replaced with the return value.
The return value may be the
original node in which case no replacement takes place.</p>
<p>Here is an example transformer that rewrites all occurrences of name lookups
(<code>foo</code>) to <code>data['foo']</code>::</p>
<p>class RewriteName(NodeTransformer):</p>
<pre><code>   def visit_Name(self, node):
       return Subscript(
           value=Name(id='data', ctx=Load()),
           slice=Index(value=Str(s=node.id)),
           ctx=node.ctx
       )
</code></pre>
<p>Keep in mind that if the node you're operating on has child nodes you must
either transform the child nodes yourself or call the :meth:<code>generic_visit</code>
method for the node first.</p>
<p>For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.</p>
<p>Usually you use the transformer like this::</p>
<p>node = YourTransformer().visit(node)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompilingNodeTransformer(TypedNodeTransformer):
    step = &#34;Node transformation&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eopsin.typed_ast.TypedNodeTransformer" href="typed_ast.html#eopsin.typed_ast.TypedNodeTransformer">TypedNodeTransformer</a></li>
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eopsin.compiler.UPLCCompiler" href="compiler.html#eopsin.compiler.UPLCCompiler">UPLCCompiler</a></li>
<li><a title="eopsin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars" href="optimize/optimize_remove_deadvars.html#eopsin.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars">OptimizeRemoveDeadvars</a></li>
<li><a title="eopsin.optimize.optimize_remove_pass.OptimizeRemovePass" href="optimize/optimize_remove_pass.html#eopsin.optimize.optimize_remove_pass.OptimizeRemovePass">OptimizeRemovePass</a></li>
<li><a title="eopsin.optimize.optimize_varlen.OptimizeVarlen" href="optimize/optimize_varlen.html#eopsin.optimize.optimize_varlen.OptimizeVarlen">OptimizeVarlen</a></li>
<li><a title="eopsin.rewrite.rewrite_augassign.RewriteAugAssign" href="rewrite/rewrite_augassign.html#eopsin.rewrite.rewrite_augassign.RewriteAugAssign">RewriteAugAssign</a></li>
<li><a title="eopsin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites" href="rewrite/rewrite_forbidden_overwrites.html#eopsin.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites">RewriteForbiddenOverwrites</a></li>
<li><a title="eopsin.rewrite.rewrite_import.RewriteImport" href="rewrite/rewrite_import.html#eopsin.rewrite.rewrite_import.RewriteImport">RewriteImport</a></li>
<li><a title="eopsin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses" href="rewrite/rewrite_import_dataclasses.html#eopsin.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses">RewriteImportDataclasses</a></li>
<li><a title="eopsin.rewrite.rewrite_import_hashlib.RewriteImportHashlib" href="rewrite/rewrite_import_hashlib.html#eopsin.rewrite.rewrite_import_hashlib.RewriteImportHashlib">RewriteImportHashlib</a></li>
<li><a title="eopsin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData" href="rewrite/rewrite_import_plutusdata.html#eopsin.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData">RewriteImportPlutusData</a></li>
<li><a title="eopsin.rewrite.rewrite_import_typing.RewriteImportTyping" href="rewrite/rewrite_import_typing.html#eopsin.rewrite.rewrite_import_typing.RewriteImportTyping">RewriteImportTyping</a></li>
<li><a title="eopsin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr" href="rewrite/rewrite_inject_builtin_constr.html#eopsin.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr">RewriteInjectBuiltinsConstr</a></li>
<li><a title="eopsin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins" href="rewrite/rewrite_inject_builtins.html#eopsin.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins">RewriteInjectBuiltins</a></li>
<li><a title="eopsin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff" href="rewrite/rewrite_remove_type_stuff.html#eopsin.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff">RewriteRemoveTypeStuff</a></li>
<li><a title="eopsin.rewrite.rewrite_tuple_assign.RewriteTupleAssign" href="rewrite/rewrite_tuple_assign.html#eopsin.rewrite.rewrite_tuple_assign.RewriteTupleAssign">RewriteTupleAssign</a></li>
<li><a title="eopsin.type_inference.AggressiveTypeInferencer" href="type_inference.html#eopsin.type_inference.AggressiveTypeInferencer">AggressiveTypeInferencer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eopsin.util.CompilingNodeTransformer.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eopsin.typed_ast.TypedNodeTransformer" href="typed_ast.html#eopsin.typed_ast.TypedNodeTransformer">TypedNodeTransformer</a></b></code>:
<ul class="hlist">
<li><code><a title="eopsin.typed_ast.TypedNodeTransformer.visit" href="typed_ast.html#eopsin.typed_ast.TypedNodeTransformer.visit">visit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eopsin.util.CompilingNodeVisitor"><code class="flex name class">
<span>class <span class="ident">CompilingNodeVisitor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompilingNodeVisitor(TypedNodeVisitor):
    step = &#34;Node visiting&#34;

    def visit(self, node):
        try:
            return super().visit(node)
        except Exception as e:
            if isinstance(e, CompilerError):
                raise e
            raise CompilerError(e, node, self.step)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eopsin.typed_ast.TypedNodeVisitor" href="typed_ast.html#eopsin.typed_ast.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eopsin.optimize.optimize_remove_deadvars.NameLoadCollector" href="optimize/optimize_remove_deadvars.html#eopsin.optimize.optimize_remove_deadvars.NameLoadCollector">NameLoadCollector</a></li>
<li><a title="eopsin.optimize.optimize_remove_deadvars.SafeOperationVisitor" href="optimize/optimize_remove_deadvars.html#eopsin.optimize.optimize_remove_deadvars.SafeOperationVisitor">SafeOperationVisitor</a></li>
<li><a title="eopsin.optimize.optimize_varlen.NameCollector" href="optimize/optimize_varlen.html#eopsin.optimize.optimize_varlen.NameCollector">NameCollector</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eopsin.util.CompilingNodeVisitor.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="eopsin.typed_ast.TypedNodeVisitor" href="typed_ast.html#eopsin.typed_ast.TypedNodeVisitor">TypedNodeVisitor</a></b></code>:
<ul class="hlist">
<li><code><a title="eopsin.typed_ast.TypedNodeVisitor.visit" href="typed_ast.html#eopsin.typed_ast.TypedNodeVisitor.visit">visit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="eopsin.util.LenImpl"><code class="flex name class">
<span>class <span class="ident">LenImpl</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LenImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;len&#39; takes only one argument, but {len(args)} were given&#34;
        assert isinstance(
            args[0], InstanceType
        ), &#34;Can only determine length of instances&#34;
        return FunctionType(args, IntegerInstanceType)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only determine length of instances&#34;
        if arg == ByteStringInstanceType:
            return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.LengthOfByteString(plt.Var(&#34;x&#34;)))
        elif isinstance(arg.typ, ListType):
            # simple list length function
            return plt.Lambda(
                [&#34;x&#34;, &#34;_&#34;],
                plt.FoldList(
                    plt.Var(&#34;x&#34;),
                    plt.Lambda(
                        [&#34;a&#34;, &#34;_&#34;], plt.AddInteger(plt.Var(&#34;a&#34;), plt.Integer(1))
                    ),
                    plt.Integer(0),
                ),
            )
        raise NotImplementedError(f&#34;&#39;len&#39; is not implemented for type {arg}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eopsin.typed_ast.PolymorphicFunction" href="typed_ast.html#eopsin.typed_ast.PolymorphicFunction">PolymorphicFunction</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eopsin.util.LenImpl.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args: List[<a title="eopsin.typed_ast.Type" href="typed_ast.html#eopsin.typed_ast.Type">Type</a>]) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    arg = args[0]
    assert isinstance(arg, InstanceType), &#34;Can only determine length of instances&#34;
    if arg == ByteStringInstanceType:
        return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.LengthOfByteString(plt.Var(&#34;x&#34;)))
    elif isinstance(arg.typ, ListType):
        # simple list length function
        return plt.Lambda(
            [&#34;x&#34;, &#34;_&#34;],
            plt.FoldList(
                plt.Var(&#34;x&#34;),
                plt.Lambda(
                    [&#34;a&#34;, &#34;_&#34;], plt.AddInteger(plt.Var(&#34;a&#34;), plt.Integer(1))
                ),
                plt.Integer(0),
            ),
        )
    raise NotImplementedError(f&#34;&#39;len&#39; is not implemented for type {arg}&#34;)</code></pre>
</details>
</dd>
<dt id="eopsin.util.LenImpl.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args: List[<a title="eopsin.typed_ast.Type" href="typed_ast.html#eopsin.typed_ast.Type">Type</a>]) ‑> <a title="eopsin.typed_ast.FunctionType" href="typed_ast.html#eopsin.typed_ast.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    assert (
        len(args) == 1
    ), f&#34;&#39;len&#39; takes only one argument, but {len(args)} were given&#34;
    assert isinstance(
        args[0], InstanceType
    ), &#34;Can only determine length of instances&#34;
    return FunctionType(args, IntegerInstanceType)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eopsin.util.PythonBuiltIn"><code class="flex name class">
<span>class <span class="ident">PythonBuiltIn</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PythonBuiltIn(Enum):
    all = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.Var(&#34;xs&#34;),
            plt.Lambda([&#34;x&#34;, &#34;a&#34;], plt.And(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
            plt.Bool(True),
        ),
    )
    any = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.Var(&#34;xs&#34;),
            plt.Lambda([&#34;x&#34;, &#34;a&#34;], plt.Or(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
            plt.Bool(False),
        ),
    )
    abs = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.Ite(
            plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
            plt.Negate(plt.Var(&#34;x&#34;)),
            plt.Var(&#34;x&#34;),
        ),
    )
    # maps an integer to a unicode code point and decodes it
    # reference: https://en.wikipedia.org/wiki/UTF-8#Encoding
    chr = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.DecodeUtf8(
            plt.Ite(
                plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x0)),
                plt.TraceError(&#34;ValueError: chr() arg not in range(0x110000)&#34;),
                plt.Ite(
                    plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x80)),
                    # encoding of 0x0 - 0x80
                    plt.ConsByteString(plt.Var(&#34;x&#34;), plt.ByteString(b&#34;&#34;)),
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x800)),
                        # encoding of 0x80 - 0x800
                        plt.ConsByteString(
                            # we do bit manipulation using integer arithmetic here - nice
                            plt.AddInteger(
                                plt.Integer(0b110 &lt;&lt; 5),
                                plt.DivideInteger(plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 6)),
                            ),
                            plt.ConsByteString(
                                plt.AddInteger(
                                    plt.Integer(0b10 &lt;&lt; 6),
                                    plt.ModInteger(plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 6)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0x10000)),
                            # encoding of 0x800 - 0x10000
                            plt.ConsByteString(
                                plt.AddInteger(
                                    plt.Integer(0b1110 &lt;&lt; 4),
                                    plt.DivideInteger(
                                        plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 12)
                                    ),
                                ),
                                plt.ConsByteString(
                                    plt.AddInteger(
                                        plt.Integer(0b10 &lt;&lt; 6),
                                        plt.DivideInteger(
                                            plt.ModInteger(
                                                plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 12)
                                            ),
                                            plt.Integer(1 &lt;&lt; 6),
                                        ),
                                    ),
                                    plt.ConsByteString(
                                        plt.AddInteger(
                                            plt.Integer(0b10 &lt;&lt; 6),
                                            plt.ModInteger(
                                                plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 6)
                                            ),
                                        ),
                                        plt.ByteString(b&#34;&#34;),
                                    ),
                                ),
                            ),
                            plt.Ite(
                                plt.LessThanInteger(
                                    plt.Var(&#34;x&#34;), plt.Integer(0x110000)
                                ),
                                # encoding of 0x10000 - 0x10FFF
                                plt.ConsByteString(
                                    plt.AddInteger(
                                        plt.Integer(0b11110 &lt;&lt; 3),
                                        plt.DivideInteger(
                                            plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 18)
                                        ),
                                    ),
                                    plt.ConsByteString(
                                        plt.AddInteger(
                                            plt.Integer(0b10 &lt;&lt; 6),
                                            plt.DivideInteger(
                                                plt.ModInteger(
                                                    plt.Var(&#34;x&#34;), plt.Integer(1 &lt;&lt; 18)
                                                ),
                                                plt.Integer(1 &lt;&lt; 12),
                                            ),
                                        ),
                                        plt.ConsByteString(
                                            plt.AddInteger(
                                                plt.Integer(0b10 &lt;&lt; 6),
                                                plt.DivideInteger(
                                                    plt.ModInteger(
                                                        plt.Var(&#34;x&#34;),
                                                        plt.Integer(1 &lt;&lt; 12),
                                                    ),
                                                    plt.Integer(1 &lt;&lt; 6),
                                                ),
                                            ),
                                            plt.ConsByteString(
                                                plt.AddInteger(
                                                    plt.Integer(0b10 &lt;&lt; 6),
                                                    plt.ModInteger(
                                                        plt.Var(&#34;x&#34;),
                                                        plt.Integer(1 &lt;&lt; 6),
                                                    ),
                                                ),
                                                plt.ByteString(b&#34;&#34;),
                                            ),
                                        ),
                                    ),
                                ),
                                plt.TraceError(
                                    &#34;ValueError: chr() arg not in range(0x110000)&#34;
                                ),
                            ),
                        ),
                    ),
                ),
            )
        ),
    )
    breakpoint = plt.Lambda([&#34;_&#34;], plt.NoneData())
    hex = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.DecodeUtf8(
            plt.Let(
                [
                    (
                        &#34;hexlist&#34;,
                        plt.RecFun(
                            plt.Lambda(
                                [&#34;f&#34;, &#34;i&#34;],
                                plt.Ite(
                                    plt.LessThanEqualsInteger(
                                        plt.Var(&#34;i&#34;), plt.Integer(0)
                                    ),
                                    plt.EmptyIntegerList(),
                                    plt.MkCons(
                                        plt.Let(
                                            [
                                                (
                                                    &#34;mod&#34;,
                                                    plt.ModInteger(
                                                        plt.Var(&#34;i&#34;), plt.Integer(16)
                                                    ),
                                                ),
                                            ],
                                            plt.AddInteger(
                                                plt.Var(&#34;mod&#34;),
                                                plt.IfThenElse(
                                                    plt.LessThanInteger(
                                                        plt.Var(&#34;mod&#34;), plt.Integer(10)
                                                    ),
                                                    plt.Integer(ord(&#34;0&#34;)),
                                                    plt.Integer(ord(&#34;a&#34;) - 10),
                                                ),
                                            ),
                                        ),
                                        plt.Apply(
                                            plt.Var(&#34;f&#34;),
                                            plt.Var(&#34;f&#34;),
                                            plt.DivideInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(16)
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;mkstr&#34;,
                        plt.Lambda(
                            [&#34;i&#34;],
                            plt.FoldList(
                                plt.Apply(plt.Var(&#34;hexlist&#34;), plt.Var(&#34;i&#34;)),
                                plt.Lambda(
                                    [&#34;b&#34;, &#34;i&#34;],
                                    plt.ConsByteString(plt.Var(&#34;i&#34;), plt.Var(&#34;b&#34;)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    plt.ByteString(b&#34;0x0&#34;),
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                        plt.ConsByteString(
                            plt.Integer(ord(&#34;-&#34;)),
                            plt.AppendByteString(
                                plt.ByteString(b&#34;0x&#34;),
                                plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Negate(plt.Var(&#34;x&#34;))),
                            ),
                        ),
                        plt.AppendByteString(
                            plt.ByteString(b&#34;0x&#34;),
                            plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                ),
            )
        ),
    )
    len = auto()
    max = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.TailList(plt.Var(&#34;xs&#34;)),
            plt.Lambda(
                [&#34;x&#34;, &#34;a&#34;],
                plt.IfThenElse(
                    plt.LessThanInteger(plt.Var(&#34;a&#34;), plt.Var(&#34;x&#34;)),
                    plt.Var(&#34;x&#34;),
                    plt.Var(&#34;a&#34;),
                ),
            ),
            plt.HeadList(plt.Var(&#34;xs&#34;)),
        ),
    )
    min = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.TailList(plt.Var(&#34;xs&#34;)),
            plt.Lambda(
                [&#34;x&#34;, &#34;a&#34;],
                plt.IfThenElse(
                    plt.LessThanInteger(plt.Var(&#34;a&#34;), plt.Var(&#34;x&#34;)),
                    plt.Var(&#34;a&#34;),
                    plt.Var(&#34;x&#34;),
                ),
            ),
            plt.HeadList(plt.Var(&#34;xs&#34;)),
        ),
    )
    print = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.Trace(plt.Var(&#34;x&#34;), plt.NoneData()),
    )
    # NOTE: only correctly defined for positive y
    pow = plt.Lambda([&#34;x&#34;, &#34;y&#34;, &#34;_&#34;], PowImpl(plt.Var(&#34;x&#34;), plt.Var(&#34;y&#34;)))
    oct = plt.Lambda(
        [&#34;x&#34;, &#34;_&#34;],
        plt.DecodeUtf8(
            plt.Let(
                [
                    (
                        &#34;octlist&#34;,
                        plt.RecFun(
                            plt.Lambda(
                                [&#34;f&#34;, &#34;i&#34;],
                                plt.Ite(
                                    plt.LessThanEqualsInteger(
                                        plt.Var(&#34;i&#34;), plt.Integer(0)
                                    ),
                                    plt.EmptyIntegerList(),
                                    plt.MkCons(
                                        plt.AddInteger(
                                            plt.ModInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(8)
                                            ),
                                            plt.Integer(ord(&#34;0&#34;)),
                                        ),
                                        plt.Apply(
                                            plt.Var(&#34;f&#34;),
                                            plt.Var(&#34;f&#34;),
                                            plt.DivideInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(8)
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;mkoct&#34;,
                        plt.Lambda(
                            [&#34;i&#34;],
                            plt.FoldList(
                                plt.Apply(plt.Var(&#34;octlist&#34;), plt.Var(&#34;i&#34;)),
                                plt.Lambda(
                                    [&#34;b&#34;, &#34;i&#34;],
                                    plt.ConsByteString(plt.Var(&#34;i&#34;), plt.Var(&#34;b&#34;)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    plt.ByteString(b&#34;0o0&#34;),
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                        plt.ConsByteString(
                            plt.Integer(ord(&#34;-&#34;)),
                            plt.AppendByteString(
                                plt.ByteString(b&#34;0o&#34;),
                                plt.Apply(plt.Var(&#34;mkoct&#34;), plt.Negate(plt.Var(&#34;x&#34;))),
                            ),
                        ),
                        plt.AppendByteString(
                            plt.ByteString(b&#34;0o&#34;),
                            plt.Apply(plt.Var(&#34;mkoct&#34;), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                ),
            )
        ),
    )
    range = plt.Lambda(
        [&#34;limit&#34;, &#34;_&#34;],
        plt.Range(plt.Var(&#34;limit&#34;)),
    )
    reversed = auto()
    sum = plt.Lambda(
        [&#34;xs&#34;, &#34;_&#34;],
        plt.FoldList(
            plt.Var(&#34;xs&#34;), plt.BuiltIn(uplc.BuiltInFun.AddInteger), plt.Integer(0)
        ),
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eopsin.util.PythonBuiltIn.abs"><code class="name">var <span class="ident">abs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.all"><code class="name">var <span class="ident">all</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.any"><code class="name">var <span class="ident">any</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.breakpoint"><code class="name">var <span class="ident">breakpoint</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.chr"><code class="name">var <span class="ident">chr</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.hex"><code class="name">var <span class="ident">hex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.len"><code class="name">var <span class="ident">len</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.min"><code class="name">var <span class="ident">min</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.oct"><code class="name">var <span class="ident">oct</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.pow"><code class="name">var <span class="ident">pow</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.print"><code class="name">var <span class="ident">print</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.range"><code class="name">var <span class="ident">range</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.reversed"><code class="name">var <span class="ident">reversed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="eopsin.util.PythonBuiltIn.sum"><code class="name">var <span class="ident">sum</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="eopsin.util.ReversedImpl"><code class="flex name class">
<span>class <span class="ident">ReversedImpl</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReversedImpl(PolymorphicFunction):
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        assert (
            len(args) == 1
        ), f&#34;&#39;reversed&#39; takes only one argument, but {len(args)} were given&#34;
        typ = args[0]
        assert isinstance(typ, InstanceType), &#34;Can only reverse instances&#34;
        assert isinstance(typ.typ, ListType), &#34;Can only reverse instances of lists&#34;
        # returns list of same type
        return FunctionType(args, typ)

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        arg = args[0]
        assert isinstance(arg, InstanceType), &#34;Can only reverse instances&#34;
        if isinstance(arg.typ, ListType):
            empty_l = empty_list(arg.typ.typ)
            return plt.Lambda(
                [&#34;xs&#34;, &#34;_&#34;],
                plt.FoldList(
                    plt.Var(&#34;xs&#34;),
                    plt.Lambda([&#34;a&#34;, &#34;x&#34;], plt.MkCons(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
                    empty_l,
                ),
            )
        raise NotImplementedError(f&#34;&#39;reversed&#39; is not implemented for type {arg}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eopsin.typed_ast.PolymorphicFunction" href="typed_ast.html#eopsin.typed_ast.PolymorphicFunction">PolymorphicFunction</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eopsin.util.ReversedImpl.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args: List[<a title="eopsin.typed_ast.Type" href="typed_ast.html#eopsin.typed_ast.Type">Type</a>]) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    arg = args[0]
    assert isinstance(arg, InstanceType), &#34;Can only reverse instances&#34;
    if isinstance(arg.typ, ListType):
        empty_l = empty_list(arg.typ.typ)
        return plt.Lambda(
            [&#34;xs&#34;, &#34;_&#34;],
            plt.FoldList(
                plt.Var(&#34;xs&#34;),
                plt.Lambda([&#34;a&#34;, &#34;x&#34;], plt.MkCons(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
                empty_l,
            ),
        )
    raise NotImplementedError(f&#34;&#39;reversed&#39; is not implemented for type {arg}&#34;)</code></pre>
</details>
</dd>
<dt id="eopsin.util.ReversedImpl.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args: List[<a title="eopsin.typed_ast.Type" href="typed_ast.html#eopsin.typed_ast.Type">Type</a>]) ‑> <a title="eopsin.typed_ast.FunctionType" href="typed_ast.html#eopsin.typed_ast.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    assert (
        len(args) == 1
    ), f&#34;&#39;reversed&#39; takes only one argument, but {len(args)} were given&#34;
    typ = args[0]
    assert isinstance(typ, InstanceType), &#34;Can only reverse instances&#34;
    assert isinstance(typ.typ, ListType), &#34;Can only reverse instances of lists&#34;
    # returns list of same type
    return FunctionType(args, typ)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eopsin" href="index.html">eopsin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="eopsin.util.PowImpl" href="#eopsin.util.PowImpl">PowImpl</a></code></li>
<li><code><a title="eopsin.util.data_from_json" href="#eopsin.util.data_from_json">data_from_json</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eopsin.util.CompilerError" href="#eopsin.util.CompilerError">CompilerError</a></code></h4>
</li>
<li>
<h4><code><a title="eopsin.util.CompilingNodeTransformer" href="#eopsin.util.CompilingNodeTransformer">CompilingNodeTransformer</a></code></h4>
<ul class="">
<li><code><a title="eopsin.util.CompilingNodeTransformer.step" href="#eopsin.util.CompilingNodeTransformer.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eopsin.util.CompilingNodeVisitor" href="#eopsin.util.CompilingNodeVisitor">CompilingNodeVisitor</a></code></h4>
<ul class="">
<li><code><a title="eopsin.util.CompilingNodeVisitor.step" href="#eopsin.util.CompilingNodeVisitor.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eopsin.util.LenImpl" href="#eopsin.util.LenImpl">LenImpl</a></code></h4>
<ul class="">
<li><code><a title="eopsin.util.LenImpl.impl_from_args" href="#eopsin.util.LenImpl.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="eopsin.util.LenImpl.type_from_args" href="#eopsin.util.LenImpl.type_from_args">type_from_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eopsin.util.PythonBuiltIn" href="#eopsin.util.PythonBuiltIn">PythonBuiltIn</a></code></h4>
<ul class="two-column">
<li><code><a title="eopsin.util.PythonBuiltIn.abs" href="#eopsin.util.PythonBuiltIn.abs">abs</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.all" href="#eopsin.util.PythonBuiltIn.all">all</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.any" href="#eopsin.util.PythonBuiltIn.any">any</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.breakpoint" href="#eopsin.util.PythonBuiltIn.breakpoint">breakpoint</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.chr" href="#eopsin.util.PythonBuiltIn.chr">chr</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.hex" href="#eopsin.util.PythonBuiltIn.hex">hex</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.len" href="#eopsin.util.PythonBuiltIn.len">len</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.max" href="#eopsin.util.PythonBuiltIn.max">max</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.min" href="#eopsin.util.PythonBuiltIn.min">min</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.oct" href="#eopsin.util.PythonBuiltIn.oct">oct</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.pow" href="#eopsin.util.PythonBuiltIn.pow">pow</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.print" href="#eopsin.util.PythonBuiltIn.print">print</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.range" href="#eopsin.util.PythonBuiltIn.range">range</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.reversed" href="#eopsin.util.PythonBuiltIn.reversed">reversed</a></code></li>
<li><code><a title="eopsin.util.PythonBuiltIn.sum" href="#eopsin.util.PythonBuiltIn.sum">sum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eopsin.util.ReversedImpl" href="#eopsin.util.ReversedImpl">ReversedImpl</a></code></h4>
<ul class="">
<li><code><a title="eopsin.util.ReversedImpl.impl_from_args" href="#eopsin.util.ReversedImpl.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="eopsin.util.ReversedImpl.type_from_args" href="#eopsin.util.ReversedImpl.type_from_args">type_from_args</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>